:chapterNumber: 3
:sourceDir: ./examples
:sourceSample: server-crash.js
:nodeCurrentVersion: v6
:npmCurrentVersion: v4
:toc-title: Table des matières
:sectnums:
:revdate: {docdate}
:imagesdir: {indir}
ifdef::env[]
:imagesdir: .
endif::[]

= Développer une application web

[CAUTION]
====
Ce chapitre va prochainement être remanié.
====

Maintenant que nous en savons davantage sur Node en théorie et en pratique, il est temps de plonger dans quelque chose de plus ambitieux : la gestion d'un projet entier.

Ce chapitre se focalise sur les différentes étapes d'un projet Node, de son initialisation jusqu'à son exécution sur votre poste de travail en passant par l'installation et la vérification de dépendances npm.

====
.Sommaire
- Organiser son espace de travail
- Gérer les différentes étapes du cycle de vie d'un projet Node
- Connaître et choisir des dépendances npm
- Design pattern
====

[abstract]
--
Comment organiser, installer maintenir du code dans le cadre d'un projet Node ?
C'est la question à laquelle nous allons répondre dans les prochaines pages.

Vos projets peuvent bénéficier de la richesse de l'écosystème npm dont les modules fournissent fonctionnalités, outillage et des utilitaires d'organisation de code dont il serait dommage de se passer.
En plus de vous faire gagner un temps précieux, ils vous éviteront de réinventer la roue.

Nous terminerons le chapitre par un ensemble de _design patterns_ utiles et récurrents.
Les connaître vous facilitera la lecture du code source de modules tiers, tout en vous donnant les moyens de développer des applications optimisant au maximum l'usage des ressources systèmes.

Ces millisecondes et méga-octets de mémoire peuvent avoir l'air de rien du tout… mais ces techniques vous aideront à créer et maintenir des applications résistant à la charge, de quelques dizaines à plusieurs milliers d'utilisateurs en simultané !
--

include::../resources/tip-versions.adoc[]
include::../resources/tip-examples.adoc[]

toc::[]

== Cycles de vie d'un projet

La pierre angulaire d'un projet Node est le fichier `package.json`.
Incontournable, il décrit les composants essentiels du projet.
Il se situe à la racine de chaque module et contient plusieurs catégories d'informations :

- *textuels* : titre, descriptions, liens et licence ;
- *version* : une chaîne respectant le fonctionnement de _node-semver_ ([URL]#https://github.com/npm/node-semver#) ;
- *dépendances* : emplacement du module principal et liste explicite de modules nécessaires au bon fonctionnement du projet ;
- *actions* : commandes à exécuter lors des différentes étapes du cycle de vie du projet ;
- *divers* : données de configuration ou utilisées par des modules Node.

.Exemple minimaliste d'un fichier `package.json`
image::images/package-json.png[align="center",width="85%"]

Le fichier `package.json` est un mécanisme de description, d'installation et de documentation distribué avec les sources de tout projet.

Considérez ce fichier comme obligatoire.
Il explicite les dépendances, facilite leur installation et leurs mises à jour.

Donc tant qu'à faire, autant le créer dès le début d'un projet — même si on ne sait pas encore ce dont on va avoir besoin de manière exhaustive.

=== Initialisation

L'initialisation d'un projet Node passe par la création du fichier `package.json`, et ce, quelle que soit sa taille : petit ou grand, application ou module, public ou privé.

Nous pourrions créer ce fichier à la main et le compléter en suivant la spécification.
Cependant il existe une commande bien utile qui réduit le risque d'erreurs et en accélère sa complétion : `npm init`.

==== npm init

L'utilisation de la commande `npm init` est une bonne habitude à prendre pour débuter tout projet Node.

La commande démarre une série de questions interactives.
Certaines réponses seront pré-remplies, par exemple si un dépôt Git ou un fichier README sont détectés.

À l'issue de la série de questions, le fichier `package.json` sera créé dans le répertoire courant.
Ensuite libre à vous de le compléter avec d'autres éléments optionnels de configuration.

.Exemple de questions posées lors de la séquence `npm init`
image::images/npm-init.png[align="center",width="85%"]

On peut gagner du temps en utilisant l'option `--yes` (et son raccourci `-y`) pour créer le fichier `package.json` sans avoir à répondre aux questions :

----
$ npm init -y
----

==== Configurer package.json

Que votre projet soit public ou non, il est important de renseigner les champs décrits ci-après.
Ils indiqueront aux utilisateurs les intentions du projet ainsi que l'emplacement des ressources pour en savoir davantage à son propos ou tout simplement, pour y contribuer.

[TIP]
.[RemarquePreTitre]#Commande# `npm help json`
====
Le détail de chaque clé de configuration est expliqué _via_ cette commande.
Des exemples vous permettront également de mieux comprendre leur utilité.

Cette même documentation est disponible en ligne, en anglais :

- [URL]#https://docs.npmjs.com/files/package.json#
====

- *name* : il s'agit de l'identifiant du module lorsqu'il est chargé via la fonction `require()`. Ce sera également l'identifiant npm si vous publiez ce module dans un registre public ou privé. Par exemple, si la propriété *name* vaut _nodebook_, le module se chargera via `require('nodebook')` et s'installera avec la commande `npm install nodebook` ;
- *description* : une indication textuelle des objectifs et fonctionnalités du module, écrite généralement en anglais ;
- *version* : chaîne respectant la sémantique _semver_ — par exemple `1.0.0`. Nous verrons un peu plus loin dans ce chapitre comment utiliser intelligemment cette valeur pour assurer des mises à jour tout en préservant la compatibilité descendante au sein des projets dépendants de ce module ;
- *main* : emplacement du fichier Node chargé par défaut lors d'un appel à `require(<name>)`. S'il n'est pas spécifié, Node tentera de charger par défaut le fichier `index.js` ;
- *repository* : objet spécifiant le type de dépôt de code ainsi que son URL. Présent essentiellement à titre informatif ;
- *preferGlobal* : booléen indiquant si ce module a davantage vocation à être installé globalement au niveau du système ou non (`false` par défaut) ;
- *bin* : emplacement du fichier. npm effectue un lien symbolique pour rendre `<name>` disponible en tant qu'exécutable système lors d'une installation globale ;
- *private* : boolean spécifiant que le module ne doit pas être publié dans un registre npm (`false` par défaut) ;
- *dependencies* : objet représentant respectivement en clé/valeur les noms/versions des modules dont le projet dépend ;
- *engines* : objet spécifiant des contraintes de compatibilité suivant la sémantique _semver_ dans lesquelles le projet s'exécute sans accroc. Par exemple `{ "node": "~0.10.0 || ~0.12.0" }` indiquera une compatibilité avec toutes les versions de Node `v0.10` et de Node `v0.12` — une installation sur Node `v0.8` échouera car la compatibilité n'est pas assurée.

[TIP]
.[RemarquePreTitre]#Aide# dependencies, devDependencies, optionalDependencies, peerDependencies
====
Il existe plusieurs types de dépendances, chacune ayant sa propre utilité :

- *dependencies* : dépendances utiles à un fonctionnement en production ;
- *devDependencies* : dépendances utiles uniquement dans le cadre du développement, par exemple pour exécuter des tests ou s'assurer de la qualité du code ou encore empaqueter le projet ;
- *optionalDependencies* : dépendances dont l'installation ne sera pas nécessairement satisfaite, notamment pour des raisons de compatibilité. En général votre code prévoira que le chargement de ces modules via `require()` pourra échouer en prévoyant le traitement des exceptions avec un `try {} catch ()` ;
- *peerDependencies* : modules dont l'installation vous est recommandée ; pratique couramment employée dans le cas de _plugins_. +
Par exemple, si votre projet `A` installe `gulp-webserver` en `devDependencies` et que `gulp-webserver` déclare `gulp` en `peerDependencies`, npm vous recommandera d'installer également `gulp` en tant que `devDependencies` de votre projet `A`.
====

Voyons maintenant comment organiser notre code au sein de notre espace de travail.

==== Organiser l'espace de travail

Chaque développeur possède sa propre manière de ranger et d'organiser son code.

La méthode suivante combine à la fois du bon sens et les conventions employées par une majorité de modules publiés sur npm. +
Elle a également l’avantage de fonctionner de manière agnostique selon que votre code soit destiné à être exécuté par un navigateur web ou un système informatique.

Quoiqu’il en soit, l’objectif est de créer des repères pérennes pour naviguer au sein de vos projets de manière similaire — en tous cas, de manière claire et non-anarchique.

----
├── bin
├── config
├── data
├── dist
├── doc
├── lib
│   └── models
├── node_modules
├── src
│   ├── assets
│   │   ├── images
│   │   ├── js
│   │   └── less
│   ├── routes
│   └── views
├── tests
│   ├── fixtures
│   ├── functional
│   └── unit
├── package.json
└── README
----

[TIP]
.[RemarquePreTitre]#Remarque# Persistence des données
====
L’application ne devrait *jamais persister de fichiers* au sein de cette arborescence.

Considérez un emplacement système qui persistera aux installations diverses et répétées. +
Cet emplacement sera défini par mécanisme de configuration type  variable d’environnement.
Lire <<project-configuration,fichier de configuration>> de ce même chapitre pour plus d'informations et recommandations à ce sujet.
====

La suggestion d’organisation ci-avant s’explique de la manière suivante :

- *bin* : fichiers exécutables depuis un shell ;
- *config* : environnements de configuration pour éviter d’écrire ces valeurs en dur dans le code source ;
- *data* : données diverses (type binaires ou CSV) nécessaires au fonctionnement de l’application ;
- *dist* : artéfacts produits après une compilation ou un résultat de _build_ — souvent une bibliothèque Node prête à l’usage pour le navigateur ou une arborescence d’application prête à être déployée ;
- *doc* : fichiers de documentation relatifs à la version courante de l’application ;
- *lib* : bibliothèque et modèles utilisées par l’application. Ce code peut typiquement grossir suffisamment pour ainsi justifier qu’il soit extrait en tant que projet(s) indépendant(s) ;
- *node_modules* : modules tiers installés automatiquement via la commande npm. Autrement dit, ne créez jamais de fichiers dans ce répertoire autrement que par la commande npm ;
- *src* : code source spécifique au projet, des routes aux vues/templates en passant par les images et le code à compiler (Sass, LESS, JSX etc.) ;
- *tests* : tests unitaires, fonctionnels et _fixtures_ nécessaires à leur fonctionnement ;
- *package.json* : fichier de configuration précédemment décrit dans cet ouvrage ;
- *README* : présentation, description et documentation minimaliste — mais suffisamment pour installer, faire fonctionner et contribuer au projet.

[TIP]
.[RemarquePreTitre]#Remarque# Échafaudage de projet
=====

Certains modules tels que _Yeoman_ ou _Express Generator_ mettent à disposition une commande pour échafauder automatiquement un projet.

Servez-vous en pour automatiser l’initialisation de vos projets — surtout s’il s’agit d’une opération récurrente.

- [URL]#https://npmjs.com/yo#
- [URL]#https://npmjs.com/express-generator#
=====

Intéressons-nous plus particulièrement au répertoire _node_modules_.

==== Ajouter des dépendances

Comme nous l'avons vu auparavant, le répertoire _node_modules_ contient les dépendances requises par la fonction `require()` (lire la section _modules_ du _Chapitre 2_).

Le mécanisme principal d'installation est la commande `npm install`. +
L'installation d'un module est par défaut _locale_ au projet.
Mais elle peut également être globale au système — nous le verrons plus tard.

Il est toutefois recommandé d'installer les modules localement, afin de limiter leur portée uniquement au projet tout en maintenant une dépendance explicite et gérable via le fichier _package.json_.

Déroulons ensemble l'algorithme d'installation de `npm install` par le biais de cet exemple :

----
npm install --save async yargs
----

La commande précédente effectue plusieurs opérations :

1. requête du registre _npmjs.com_ à propos des deux modules _async_ et _yargs_ ;
2. si les modules existent, la version compatible la plus récente est retournée (équivalent à `npm view async version` et `npm view yargs version` — respectivement `2.1.4` et `6.6.0`) ;
3. téléchargement et décompression des paquets dans les répertoire `node_modules/async` et `node_modules/yargs` ;
4. introspection récursive des dépendances de ces modules et si besoin est, téléchargement et décompression dans leur répertoire _node_modules_ respectif (ici `node_modules/async/node_modules` et `node_modules/yargs/node_modules`) ;
5. inscription de _async_ et de _yargs_ dans la configuration _dependencies_ de notre fichier `package.json`.

.Exemple de résultat de la commande `npm install`
image::images/npm-install-save.png[align="center",width="85%"]

La commande npm prend soin de télécharger et de persister les dépendances, à la fois dans le répertoire _node_modules_ et dans le fichier _package.json_.
Ce dernier contient désormais une section _dependencies_ :

[source,javascript]
.package.json
----
{
  ...
  "dependencies": {
    "async": "^2.1.4",
    "yargs": "^6.6.0"
  }
}
----

Vous remarquerez que les numéros de versions sont préfixés du symbole `^` (ou `~` selon la version de npm).
Nous y reviendrons dans <<semver, Choisir un bon numéro de version>>.

[TIP]
.[RemarquePreTitre]#Aide# --save, --save-dev, --save-optional et --save-exact
=====
Plusieurs options à la commande npm inscrivent les dépendances dans le fichier _package.json_.
Leur comportement varie légèrement :

- *--save* : enregistre le module dans la clé _dependencies_ ;
- *--save-exact* : idem que `--save` mais ne rajoute pas de préfixe au numéro de version (exemple : `1.3.1` au lieu de `~1.3.1`) ;
- *--save-dev* : enregistre le module dans la clé _devDependencies_ ;
- *--save-optional* : enregistre le module dans la clé _optionalDependencies_.

Sans la présence de ces options, les modules seront installés dans le répertoire _node_modules_ mais ils n'apparaitront pas dans _package.json_. +
Cela posera problème si vous cherchez à installer ou déployer l'application sur une autre machine ou après avoir effacé le contenu du répertoire _node_modules_.

*Remarque* : il n’existe pas de mécanisme pour enregistrer automatiquement une dépendance en tant que _peerDependency_.
=====

Les modules installés sont désormais manipulables via la fonction `require` au sein de notre code :

[source,javascript]
----
const async = require('async');
const { argv } = require('yargs');
----

Maintenant que nous savons installer et sauvegarder des dépendances par le biais du fichier `package.json`, sauvegardons l'état actuel du projet avec un gestionnaire de versions.

==== Versionner son code

Node s'intègre parfaitement avec les gestionnaires de version de code.
Nous illustrerons la démarche à l'aide de Git mais sachez qu'il est tout à fait possible d'utiliser Mercurial, SVN, Team Foundation Server ou tout autre gestionnaire de version gérant les fichiers texte.

La règle est simple : vous pouvez *tout versionner sauf* deux exceptions.
Deux règles suffisent dans la majorité des cas :

- *node_modules* : le fichier _package.json_ contenant déjà les références aux dépendances requises, nous n'avons pas besoin d'en versionner leur code source ;
- **.log* : la commande npm ou l'interpréteur interactif de Node peuvent générer occasionnellement des fichiers log en cas d'erreur.


[source]
.{empty}.gitignore
----
# Code source des dépendances externes
node_modules

# Erreurs et logs d'exécution de Node/npm
*.log
----

[TIP]
.[RemarquePreTitre]#Astuce# Automatisation sans effort
====
Certains IDE comme WebStorm ou des plateformes comme GitHub vous proposent de créer le fichier _.gitignore_ configuré pour Node.

Une attention sympathique qui vous évitera de versionner inutilement certains fichiers.
====

Versionner le contenu produit dans les deux précédentes sections se résume à ces quelques commandes :

----
git init
git add package.json .gitignore
git commit -m "Premier commit"
git remote add origin git@votre-serveur-git:repo.git
git push origin master
----

La suite du cycle de vie Git sera similaire à ce que vous aviez l'habitude de pratiquer.

À ce stade, nous savons initialiser un projet Node, installer des dépendances et maintenir son état dans un gestionnaire de version.

==== Approche modulaire

La force de Node réside dans sa facilité à créer et réutiliser du code dont la portée est contenue.
C'est un atout considérable pour créer et maintenir du code modulaire ne se limitant pas qu'à une seule application.

Il faut imaginer et penser une application comme étant le sens donné en créant du _liant_ entre des modules encapsulés.

Un exécutable shell configure des modules et retourne une sortie vers le terminal ou des fichiers. +
Une application web configure des modèles, les expose via des routes et met la sortie en forme au travers d'un formatage JSON ou HTML par exemple.

Une application accepte des informations en entrée : paramètres HTTP, arguments shell etc. +
Une application retourne des informations en sortie : HTML, JSON, binaire etc.

Un module accepte des informations en entrée : valeurs, objets et fonctions ECMAScript. +
Un module retourne des informations en sortie : valeurs, objets et fonctions ECMAScript.

Cela revient à constamment _designer_ des API et à les exposer, que ce soit au travers d'une interface Node, système ou HTTP.

Une application en ligne de commande devrait contenir une orchestration d'API mettant en relation l'intention exprimée par un shell système envers une bibliothèque Node :

[source,javascript]
.cli-app.js
----
include::{sourceDir}/cli-app.js[]
----
<1> `.argv` retourne l'objet `process.argv` filtré et transformé par `yargs` ;
<2> `argv.year` contient soit la valeur du paramètre `--year` passé par l'utilisateur au programme, sinon à sa valeur par défaut définie auparavant.

Un exemple d'application en ligne de commande est développé plus en détail dans le <<../chapter-05/index.adoc#,chapitre 5>>.

Une application HTTP devrait contenir une orchestration d'API mettant en relation l'intention exprimée par une requête HTTP envers une application Node :

[source,javascript]
.http-app.js
----
include::{sourceDir}/http-app.js[]
----

Une route obéissant elle-aussi au même principe :

[source,javascript]
.route.js
----
include::{sourceDir}/route.js[]
----

Nous verrons dans un chapitre ultérieur comment utiliser cette même logique de développement et l'exécuter du côté du navigateur.

Non seulement la modularité renforcera la facilité à tester votre code, à expliciter ses intentions mais en plus il accentuera l'ubiquité de son utilisation.

[[install]]
=== Installation

À ce stade, nous avons toutes les cartes en main pour créer une application Node.

Il ne reste plus qu'à pouvoir l'installer, dans un état identique sur un autre poste de travail, dans un environnement de test ou de production ou encore en tant que dépendance d'un autre module/projet ou à l'échelle du système.

Dans tous les cas décrits ci-après, que ce soit via Git ou via une archive, npm requiert que le fichier `package.json` soit situé à sa racine.

==== Autonome

Une installation autonome concerne aussi bien un développeur ayant besoin de contribuer à un projet qu'un projet exposant une ou plusieurs interfaces.

La procédure d'installation est relativement simple :

1. Cloner le dépôt Git ;
2. Lancer la commande `npm install`.

Dans le cadre des exemples contenus dans ce chapitre, il suffirait d'exécuter ces commandes :

----
$ git clone https://github.com/oncletom/nodebook.git
$ cd nodebook/chapter-03/examples
$ npm install
----

Vous remarquerez que la commande `npm install` est utilisée seule, sans nom de module.
Dans ce cas, npm se contente d'installer récursivement les dépendances listées dans le fichier `package.json`.

[TIP]
.[RemarquePreTitre]#npm# --production
====
Si vous suffixez la commande `npm install` avec l'option `--production`, toutes les dépendances seront installées à _l'exception_ de celles listées en tant que _devDependences_.

Il s'agit d'un moyen d'installer moins de dépendances lors d'une livraison — à condition de ne pas avoir besoin de l'outillage de tests.
====

Le clonage du dépôt pour être remplacé par des méthodes alternatives, de type empaquetage sous forme de fichier DEB, de module Puppet, d'archive ZIP… ou encore d'archive Node via la commande `npm pack`.

Ces méthodes permettent entre autres d'inclure les dépendances contenues dans le répertoire _node_modules_ et de garantir la version exacte de l'intégralité de l'arbre de dépendance.

==== Locale

Dans le cas où votre projet n'est pas autonome et/ou expose une API Node _mais_ n'est pas disponible dans un registre npm, il existe tout de même une méthode d'installation à partir d'un dépôt Git :

----
npm install --save git+https://github.com/oncletom/nodebook.chapter-03.git#master
----

Si l'interface HTTP de Git n'est pas disponible ou que son authentification est exclusivement gérée à partir de certificat SSH, vous pouvez opter pour le préfixe `git+ssh` :

----
npm install --save git+ssh://git@github.com:oncletom/nodebook.chapter-03.git#master
----

À défaut d'un dépôt Git, vous pouvez également installer une dépendance à partir d'une archive Tar compressée (extension `.tar.gz`), produite à l'aide de `npm pack` par exemple.

----
npm install --save https://github.com/oncletom/nodebook.chapter-03/archive/master.tar.gz
----

==== Globale

L'installation globale est une installation rendant disponible votre module sur tout le système d'exploitation.

Il s'agit d'une installation à privilégier pour les modules Node exposant un ou plusieurs exécutables — ces exécutables ayant une vocation utilitaire pour l'utilisateur final ou pour interagir avec d'autres programmes informatiques.

----
$ npm install -g npm
----

L'exécution de la précédente commande installera la dernière version de npm et rendra disponible l'exécutable du même nom au niveau du système.

Bravo, vous venez d'apprendre à mettre à jour l'exécutable npm !

[TIP]
.[RemarquePreTitre]#npm# Répertoires et exécutables
====
npm se charge de créer les liens symboliques pour vous.
Et ce, en fonction du contexte d'installation — qu'il soit global ou local donc.

- `npm install -g eslint` : exécutable mis à disposition dans le répertoire `$(npm config get prefix)/bin` (par exemple `/usr/local/node/bin`) ;
- `npm install eslint` : exécutable mis à disposition dans le répertoire `./node_modules/.bin`.
====

=== Configuration

Certaines applications ou modules nécessitent d'en savoir plus sur le contexte d'exécution, l'emplacement de ressources ou la manière de se connecter à des serveurs distants, par exemple.

C'est à la fois une bonne pratique en terme de flexibilité… et en même temps, vous n'aurez surement pas envie de partager publiquement vos identifiants de base de données, qu'elles contiennent ou pas des informations sensibles.

==== Variables d'environnement

L'utilisation d'une variable d'environnement pour configurer l'exécution d'une application est la solution la plus aisée à implémenter.

Ces variables sont accessibles via l'objet `process.env`, et ce, quel que soit le contexte d'exécution de Node.

L'exemple suivant décrit comment définir le port sur lequel écoutera le serveur HTTP en fonction d'un contexte d'exécution (environnement de test ou environnement de production) ou d'un réglage surchargeant le dit contexte.

[source,javascript]
.config/env.js
----
include::{sourceDir}/config/env.js[]
----

Ainsi que l'illustration de leur définition (ou non) :

----
PORT=8000 node config/env.js <1>
NODE_ENV=test node config/env.js <2>
node config/env.js <3>
----
<1> Le port sélectionné est le port 8000 ;
<2> Le port sélectionné est le port 3001 ;
<3> Le port sélectionné (par défaut) est le port 3000.

Ces variables d'environnement ont l'avantage d'avoir une portée au niveau du processus uniquement ou d'être propagées à l'échelle du système — via `export` en bash, par exemple.

==== Arguments

Les arguments correspondent à un tableau de chaînes exposé par `process.argv`.

Cette approche est recommandée si la passation d'informations fait partie de la logique métier du module Node, requiert des arguments obligatoires ou implique un _parsing_ avancé.

Le script suivant illustre leur lecture par l'interpréteur Node :

[source,javascript]
.config/argv.js
----
include::{sourceDir}/config/argv.js[]
----

Et leur invocation :

----
node config/argv.js -y 2014 2012 --title 'fromage baguette' #<1>
----
<1> Affiche `["-y", "2014", "2012", "--title", "fromage baguette"]`.

C'est rudimentaire mais heureusement des parseurs d'arguments vont nous faciliter la vie.
Ils permettent de configurer des valeurs par défaut, de valider les valeurs, de les rendre obligatoire et même de générer automatiquement une aide à l'utilisateur.

L'un de ces modules est `yargs`.
Nous l'avons évoqué et installé précédemment dans ce chapitre.

[source,javascript]
.config/yargs.js
----
include::{sourceDir}/config/yargs.js[]
----

Et leur invocation :

----
node config/yargs.js 2012 --title 'fromage baguette' <1> <2> <3>
----
<1> 2014 (sa valeur étant définie par défaut si `-y` n'est pas spécifié comme argument shell) ;
<2> fromage baguette ;
<3> 2012 (`_` étant l'attribut fourre-tout récupérant les arguments non-assignés).

L'invocation suivante omet volontairement l'argument `--title` afin de tester le comportement du module :

----
node config/yargs.js <1>
----
<1> Affiche le message suivant en flux d'erreur (`process.stderr`) : `Argument requis manquant: title`.

Consultez la documentation de ce module pour davantage d'exemples variés et avancés.

[[project-configuration]]
==== Fichier de configuration

Opter pour un fichier de configuration fait sens si de nombreux paramètres sont à fournir à l'application — ou si certains de ces paramètres impliquent des arborescences d'objets ou de tableaux ECMAScript.

Plusieurs stratégies s'offrent à vous :

- un fichier unique pour éviter les valeurs en dur dans le code ;
- un fichier par environnement d'exécution (test, préprod, production etc.) ;
- un fichier par domaine d'application (base de données, API etc.) ;
- un fichier par domaine de sécurité (backend, frontend etc.).

Le choix reste ouvert et le votre.
En revanche nous allons voir comment _techniquement_ mettre en œuvre ces possibles stratégies.

Commençons par l'approche par environnement d'exécution, reposant sur la notion d'un fichier de configuration par environnement.

[source,javascript]
.config/file.js
----
include::{sourceDir}/config/file.js[]
----

Ainsi, un appel au module précédent chargera :

- `production.json` lors du premier appel ;
- `dev.json` lors du second appel ;
- `test.json` lors du premier appel si `NODE_ENV=test` ;
- `dev.json` lors du second appel si `NODE_ENV=test`.

[TIP]
.[RemarquePreTitre]#npm# Le module nconf
====
Des modules comme _nconf_ proposent des abstractions gérant de multiples cas de figure.

Ils vont jusqu'à la prise en charge des notions d'héritage et de cascade pour faciliter la maintenance et ne gérer que les différences entre environnement, plutôt que d'avoir à tout spécifier à chaque fois.

- [URL]#https://npmjs.com/nconf#
====

Une autre approche, tout aussi voire plus simple consiste à réutiliser le fichier `package.json` en y ajoutant des propriétés supplémentaires.

[source,javascript]
.config/file-package.js
----
include::{sourceDir}/config/file-package.js[]
----
<1> Affiche `{ port: '3000' }`.

On peut également se passer de l'étape `require()` si la commande npm invoque un script Node :

[source,javascript]
.config/file-npm.js
----
include::{sourceDir}/config/file-npm.js[]
----

npm aplatira la structure d'objet du fichier `package.json` et séparera chaque niveau de profondeur par le caractère `_`, le préfixera par `npm_package_` et l'injectera dans l'objet `process.env`. +
Par exemple, `require('./package.json').config.port` sera accessible via `process.env.npm_package_config_port`.

----
node config/file-npm.js <1>
npm run display-config/port <2>
----
<1> Affiche `undefined` ;
<2> Affiche `3000`.

On comprend ainsi que l'exposition du contenu du fichier `package.json` sous forme de variables d'environnement est l'œuvre de la commande npm.

[TIP]
.[RemarquePreTitre]#Astuce# Combinaison avec les variables d'environnement
====
Un bon moyen de ne pas inscrire en dur l'emplacement d'un fichier de configuration est encore d'indiquer son emplacement via une variable d'environnement :

----
CONFIG_FILE=~/.secured/config.json node app.js
----
====

=== Exécution de l'application

Nous avons vu les différentes manières d'utiliser l'interpréteur Node dans le _chapitre 2_.
Pour autant, comment exécuter une application de longue durée… par exemple un serveur HTTP ?

Il existe plusieurs méthodes, allant de la simple exécution d'un script Node à l'utilisation de gestionnaire de processus voire même des gestionnaires système tels que _System V_ ou _systemd_.

[[node-exec]]
==== Invocation Node

L'utilisation seule de l'interpréteur Node pour démarrer une application est évidemment la plus simple mais également la moins robuste.

----
$ node server.js
----

Elle est pratique et acceptable dans le cadre d'un développement local voire encore dans le cadre d'un exécutable à usage ponctuel.

==== Plantage applicatif

Un programme Node s'arrête en général pour deux raisons :

. la *pile d'exécution est terminée* et il n'y a plus rien à exécuter ;
. une *erreur s'est produite* et n'a pas été capturée.

C'est souvent le cas lorsqu'une erreur se produit dans un endroit imprévu de notre code, lorsqu'une variable inexistante est appelée dans une branche de notre code appelée de manière asynchrone etc.

C'est une *bonne chose* que le programme s'arrête car cela nous permet de repérer l'erreur, de lire la trace et d'éventuellement patcher notre programme pour éviter cette même erreur dans le futur.

Quand un programme s'arrête de manière imprévue, le `process` émet un événement `uncaughtException`.
Il existe des cas où il est intéressant de l'écouter, notamment si la route d'un serveur cause une erreur et que l'on souhaite maintenir le service disponible malgré tout.

Dans ce cas, il convient d'écouter cet événement et de déterminer quelle est la meilleure action à suivre :

[source,javascript]
.server-crash.js
----
include::{sourceDir}/server-crash.js[]
----
<1> En cas de réception d'une requête HTTP sur le port `4001`, nous allons parser l'URL appélée — sauf qu'une _typo_ s'est glissée (`reb` au lieu de `req`) et provoquera une exception ;
<2> Cette exception remontera jusqu'au niveau du `process` qui déclenchera l'événement `uncaughtException` ;
<3> Une seconde après voir lancé le script, une requête HTTP est envoyée au serveur, entrainant l'exécution du _point 1_.

Encore une fois, *il vaut mieux qu'un programme plante* plutôt que de le protéger faiblement avec `uncaughtException`.

Il se peut qu'un aucun code ne capture une erreur dans une <<../chapter-02/index.adoc#primitive-promise,promesse>>.
C'est notamment le cas s'il n'y a aucun appel à `.catch()` après un `.then()`.

L'événement du `process` `unhandledRejection` est alors émis, sans pour autant faire planter le programme.
Ce comportement est toutefois amené à être modifié dans Node v8.
Il conviendrait alors de gérer le plantage d'un programme avec l'événement `uncaughtException` de la même manière que vous le feriez avec `uncaughtException`.

Dans tous les cas, il est recommandé de gérer le redémarrage de votre application Node _en dehors_ de Node.
Différentes stratégies sont présentées dans le <<../chapter-07/index.adoc#,chapitre 7>>.

==== Pendant le développement

Seulement voilà, il est fréquent qu'une application plante pendant le développement ou que l'on souhaite la relancer suite à un changement de code.

_nodemon_ est un excellent moyen d'y parvenir lorsque vous développez sur votre ordinateur (et _certainement pas_ en production).
Dès qu'un fichier est modifié, _nodemon_ interrompt le serveur et le relance aussitôt avec les arguments originels.

Au lieu d'exécuter `node server.js`, exécutez `nodemon server.js`.

[URL]#https://npmjs.com/nodemon#

[[npm-scripts]]
==== Scripts npm

L'utilisation de _scripts npm_ permet d'invoquer Node de manière légèrement différente tout en masquant la complexité des scripts au niveau du fichier `package.json`.

L'invocation d'un _script npm_ peut se faire de deux manières :

. `npm <script-natif>` pour les scripts natifs à _npm_ (`start`, `publish`, `test` etc.) ;
. `npm run <script>` pour les scripts additionnels définis par l'utilisateur.

----
$ npm start
# équivalent de `npm run start`
----

Cette action exécute la commande contenue dans la section `scripts.start` du fichier `package.json` :

[source]
.package.json
----
{
  "name": "nodebook",
  ...
  "scripts": {
    "start": "node server.js"
  }
}
----

L'avantage de cette approche est double :

- uniformisation du _workflow_ au sein de tous les projets ;
- npm modifie la *variable système `$PATH`*.

Ce dernier point est important.
Cela signifie que l'exécution d'un _script npm_ rend disponible les exécutables contenus dans le répertoire `./node_modules/.bin` (voir l'encadré _Répertoires et exécutables_ de la section <<install,Installation>>).

[source]
.package.json
----
{
  "name": "nodebook",
  ...
  "scripts": {
    "test": "eslint ." // <1>
  },
  "devDependencies": {
    "eslint": "^3.0.0"
  }
}
----
<1> Équivaut donc à `./node_modules/.bin/eslint ./src`.

La liste détaillée des commandes supportées nativement par _npm_ est documentée sur [URL]#https://docs.npmjs.com/misc/scripts#.

Toutefois les solutions précédemment citées n'adresseront pas les problématiques suivantes :

- *démarrage automatique* du processus ;
- notification et *reprise sur erreur* en cas de plantage de l'application ;
- *redémarrage* ou arrêt des services.

Nous aborderons les différentes stratégies de _provisionning_ d'applications Node dans le <<../chapter-07/index.adoc#,chapitre 7 : Héberger, déployer et monitorer>>.


=== Modification de l'application

Vous disposez d'une application qui démarre et dont le versioning est mis en place… mais concrètement, on fait quoi quand le code change ?

Cette section s'intéresse aux habitudes à prendre avant de pousser le code modifié dans votre dépôt.

==== Mise à jour des dépendances

L'erreur classique : l'application fonctionne sur votre machine mais pas sur celle de votre collègue.
Un module manque mais vous ne comprenez pas pourquoi…

Cela se résume en deux points :

- vous avez une dépendance installée dans votre projet qui n'est pas déclarée dans le fichier `package.json` ;
- la version de vos dépendances et celles de l'autre personne diffèrent.

La commande npm adresse très exactement ces problèmes grâce aux actions suivantes :

----
npm prune
npm update
----

La première supprimera du répertoire _node_modules_ toute dépendance non-déclarée dans le fichier `package.json`.
La seconde installera les dépendances manquantes et mettra à jour les dépendances locales.

`npm update` se comporte de manière similaire à `npm install` à une différence près : les dépendances préalablement installées seront mises à jour si nécessaire.

Ces deux commandes vous assureront un état d'installation similaire à ce qu'une personne aurait en procédant à une installation _fraîche_.

[TIP]
.[RemarquePreTitre]#npm# EPEERINVALID
====
Il se peut qu'une erreur _EPEERINVALID_ se déclare lors d'une mise à jour ou d'une fraîche installation.

image::images/npm-outdated-peerinvalid.png[align="center",width="85%"]

Cela signifie qu'un paquet réclame une dépendance d'une version différente et incompatible avec celle que vous déclarer dans votre fichier `package.json`.

Trois solutions s'offrent à vous :

- monter en version sur le module incriminé (dans notre exemple, le module `browserify`) ;
- si la version la plus récente de ce module casse la compatibilité de votre application, sélectionnez une version majeure satisfaisant la condition de compatibilité (ici, `>= 3.20.5`) ;
- en dernier recours, supprimer le contenu de _node_modules_ et tout réinstaller proprement — des fois cela suffit à écarter les conflits de version.
====

==== Exécution des tests

L'écriture de tests et la vérification de la qualité de votre code sont un excellent moyen de vous assurez que de nouveaux bugs ne sont pas introduits dans votre application.

Écrire des modules et les empiler sans écrire de tests revient à construire un château de carte : le moindre changement accentue le risque de propager des erreurs dans tous les applications en dépendant.

Nous verrons ultérieurement comment écrire des tests unitaires pour vos applications et votre code exécuté dans un contexte Web.

À la manière du démarrage d'une application, la commande npm fournit un contexte d'exécution dédié aux tests :

----
npm test
----

Cette commande effectue deux choses :

- elle règle la variable d'environnement `NODE_ENV` à `test` ;
- elle exécute l'instruction du script `test` déclarée dans le fichier `package.json` :

[source]
.package.json
----
{
  "name": "nodebook",
  ...
  "scripts": {
    "test": "mocha tests/**/*.js"
  },
  "devDependencies": {
    "mocha": "*"
  }
}
----

Dans cet exemple, exécuter la commande `npm test` revient à actionner l'exécutable déclaré par le module _mocha_ avec comme argument l'ensemble des fichiers JavaScript contenus dans le répertoire `tests/` de notre projet.

En cas de test fautif, l'exécutable de tests affichera des précisions quant à leur origine et se terminera avec un code de sortie différent de 0.

Ce qui signifie en jargon Unixien que vous pouvez chaîner la commande avec d'autres actions basées sur un état de réussite des tests :

----
npm test && git push
----

Cette précédente commande a deux scénarios possibles :

1. `npm test` échoue et `git push` ne sera pas exécuté ;
2. `npm test` réussit et `git push` sera exécuté.

En se basant sur ce principe de chaîne, vous pouvez faire évoluer votre commande de test en quelque chose de plus poussé :

[source]
.package.json
----
{
  "name": "nodebook",
  ...
  "scripts": {
    "test": "npm run lint-code && npm run unit-tests",
    "lint-code": "eslint ",
    "unit-tests": "mocha tests/**/*.js"
  },
  "devDependencies": {
    "mocha": "*",
    "eslint": "^3.0.0"
  }
}
----

La commande `npm test` est alors composée de deux autres commandes personnalisées.
Vous maintenez ainsi une lisibilité au sein de votre fichier `package.json` tout en bénéficiant d'une indépendance d'exécution de vos commandes.

[[semver]]
==== Choisir un bon numéro de version

Bien versionner chaque publication de votre projet n'apporte que des avantages.
Et ce, que vous choisissiez ou non de publier vos modules dans un registre npm public ou privé.

Modifier le numéro de version dans votre fichier `package.json` revient à déclarer deux choses :

1. l'*intention du changement*, à savoir mineur, fonctionnel ou très important ;
2. un `git tag` s'impose, pour marquer l'historique de version et faciliter la *reprise du code à un stade identique* à celui livré en production ou dans le registre npm.

Il est temps d'expliquer la spécification _semver_ pour mieux comprendre en tirer profit.

Un numéro de version suivant la logique _semver_ est structuré en quatre parties : MAJEUR.MINEUR.PATCH-EXTRA.

- *Majeur* : changement important d'API cassant la compatibilité avec les versions majeures précédentes ;
- *Mineur* : changement fonctionnel d'API ne cassant pas la compatibilité avec les autres publications associées à la même version majeure ;
- *Patch* : changement trivial impliquant souvent un simple correctif et n'ayant aucun impact de compatibilité ;
- *Extra* (optionnel) : métadonnée spécifique indiquant le statut (beta, alpha etc.), la cible (architecture de CPU, compilateur visé etc.) ou autre (identifiant de commit, numéro de _build_ ayant généré le paquet etc.).

Autrement dit, si vous modifier le numéro de version de `1.1.1` vers :

- `2.0.0` : incompatibilité de code avec toutes les versions de la branche `1.x` ;
- `1.2.0` : fonctionnalités modifiées mais compatibles avec le reste de la branche `1.x` ;
- `1.1.2` : correctif de la version `1.1.1` ;
- `1.1.2-beta.2` : deuxième version beta du correctif de la version `1.1.1`.

À ce stade, nous sommes dans le déclaratif : chaque projet ajoutant une dépendance vers un autre module _choisit_ sa manière d'accepter les nouvelles versions.

==== Publication du code

Puisque nous utilisons un outil de suivi de version comme Git, il est facile non seulement d'installer le projet sur les machines autorisées.
Mais il est aussi aisé d'utiliser ce même mécanisme pour déclarer notre code comme dépendance d'un autre de nos projets.

Dans le cas où votre module est publié dans un dépôt Git privé, accessible au travers de SSH, utilisez la syntaxe suivante :

[source]
.package.json
----
{
  ...
  "dependencies": {
    "votre-module": "git+ssh://git@votre-serveur-git:projet/module.git#branche"
  }
}
----

Seules les personnes ayant un accès SSH à ce dépôt seront à même d'obtenir le code au travers de la commande `npm install`.

Dans le cas où votre module est publié dans un dépôt Git public accessible au travers de HTTP, utilisez la syntaxe suivante :

[source]
.package.json
----
{
  ...
  "dependencies": {
    "votre-module": "git+https://votre-serveur-git/projet/module.git#branche"
  }
}
----

[TIP]
.[RemarquePreTitre]#npm# Mise à jour d'une dépendance Git
====
La commande `npm update` actualise vos dépendances… sauf les dépendances Git.

Pour mettre à jour une dépendance Git, il vous faut recourir à la commande… `npm install`.
====

Enfin, optez pour une publication dans le registre npm si vous considérez votre projet comme étant suffisamment solide et testé pour être partagé avec les communautés Node.

Cette simple commande suffit à déclarer une nouvelle version :

----
npm publish
----

`npm publish` téléversera une archive compressée associée au numéro de version déclaré par le fichier `package.json` et contenant tous les fichiers du projet.
Tous les fichiers sauf ceux correspondant aux motifs déclarés dans les fichiers `.gitignore` et `.npmignore`.

Pour résumer, si le module est nommé `nodebook` et est en version `0.4.0`, `npm publish` enregistrera cette version dans le registre npm.
L'installation du module fraichement publié est accessible à travers ces différentes variantes :

----
npm install nodebook
npm install nodebook@latest
npm install nodebook@0.4.0
----

Utilisez l'installation versionnée pour installer spécifiquement cette version à tout moment :

----
npm install --save-exact nodebook@0.4.0
----

=== Opérations de routine

Votre projet fonctionne de manière autonome.
Mieux encore : il n'y a plus de bug à corriger ni de nouvelle fonctionnalité à apporter pour le moment.

Alors que faire d'une application Node en production avant qu'elle ne prenne la poussière ?

[[npm-outdated]]
==== Vérifier l'état des dépendances

Maintenir ses dépendances à jour est important pour deux raisons :

- colmater des bugs qui pourraient se répercuter sur votre application ;
- se prémunir de faille de sécurité mettant en danger vos données et votre système informatique.

En dernier recours, vérifier la fraîcheur de ses dépendances permet de prendre connaissance de nouvelles versions majeures ou mineures dont vous pourriez bénéficier.

Quoiqu'il en soit, une commande npm nous aidera une fois de plus à obtenir les informations voulues :

----
npm outdated
----

La lecture de sa sortie peut être déroutante au premier abord, notamment dans le cas d'un module qui n'a pas été mis à jour via `npm update` depuis un moment :

.Résultats obsolètes issus de `npm outdated`
image::images/npm-outdated.png[align="center",width="85%"]

Le tableau ne liste que les dépendances considérées comme obsolètes en l'état actuel d'installation de votre projet.
Il se peut donc que le résultat varie d'une machine à l'autre, en fonction des versions installées localement. +
Les résultats est divisé en cinq colonnes :

- *Package* : npm du paquet concerné — en jaune une dépendance qui sera satisfaite en cas de `npm update`, en rouge une dépendance qui nécessite une mise à jour manuelle ;
- *Current* : version installée localement — _MISSING_ sera affiché si la dépendance n'est pas encore installée, _git_ indique que la dépendance est installée via git ;
- *Wanted* : version installée après exécution de `npm update` ;
- *Latest* : version la plus récente publiée dans le registre npm ;
- *Location* : emplacement de la dépendance — dépendance directe ou dépendance incluse dans une autre dépendance etc.

[TIP]
.[RemarquePreTitre]#Remarque# Et si une dépendance n'est pas listée ?
====
Toute dépendance listée dans le fichier `package.json` mais absente du tableau est considérée comme à jour.
====

La première action à mener est de procéder à l'exécution de la commande `npm update`, puis de relancer la commande `npm outdated` :

.Résultats `npm outdated` après mise à jour
image::images/npm-outdated-wanted.png[align="center",width="85%"]

Le résultat est probant : de nombreuses dépendances précédemment listées en rouge ont disparu.
Il ne reste que trois dépendances sur lesquelles nous pouvons avoir une action directe en modifiant la version référencées dans le fichier `package.json`.

Pour forcer l'installation de la version correspondant à la colonne _Latest_ de la commande `npm outdated`, il suffit d'utiliser le suffixe `@latest` lors de l'installation :

----
npm install --save-dev mocha@latest karma@latest …
----

Et ainsi de suite pour les autres dépendances de premier niveau.
La commande `npm outdated` ne devrait pas retourner de résultats, sauf si une de vos dépendances n'est pas à jour elle-même.

[TIP]
.[RemarquePreTitre]#Outil# David et Greenkeeper
====
L'outil en ligne _David_ se charge de vérifier l'état des dépendances de chaque module publié dans le registre npm.

_Greenkeeper_ vérifie également l'état de vos dépendances tout en étant plus strict sur la version à autoriser dans le fichier `package.json`.
Il notifie votre projet et propose automatiquement une _pull request_ en cas de mise à jour d'une de vos dépendances.

- [URL]#https://david-dm.org/#
- [URL]#https://greenkeeper.io/#
====

==== Éclater sa base de code

Le temps sédimente votre base de code.
Elle grossit, se densifie et devient à chaque fois un peu plus difficile à lire et naviguer.

Plusieurs raisons peuvent vous pousser à extraire une partie de votre code afin de le placer dans un autre module :

- le besoin de partager la logique métier d'une application avec une autre application ;
- une portion de votre application n'est pas spécifique à son métier et gagnerait à devenir autonome ;
- un composant pourrait être partagé et réutilisé dans un contexte web ;
- un besoin de clarification des dépendances de votre application ainsi que de leur documentation ;
- les chemins de vos appels à `require()` deviennent longs et compliqués.

C'est quelque chose de facilement identifiable à l'œil nu :

[source,javascript]
----
const User = require('.lib/model/user.js');
const Validator = require('./app/middlewares/validator');
const csvParser = require('./lib/parsers/csv');
----

Dans le cas présent, ces trois modules pourrait être extraits dans les modules indépendants suivants :

- *my-app-models* : pour bénéficier d'un module global gérant tous vos modèles de données — la limite se présentera quand vous aurez beaucoup de modèles dont la compatibilité occasionnera des collisions ;
- *my-app-models-user* : pour bénéficier d'un module dédié à la description de la persistence d'un utilisateur ;
- *validator-middleware* : pour bénéficier d'un module de validation générique et disponible dans le registre npm ;
- *csv-parser* : pour bénéficier d'un parseur CSV utilisable dans toutes vos applications — avez-vous pensé à regarder dans le registre npm avant de réinventer la roue ? ;-)

Il s'agit d'une logique de maintenabilité et d'expression des intentions de votre application.
Elle sera plus facile à maintenir si elle isole et rend explicite les dépendances entre les différents modules. +
À moins que vous ne soyez fan du code spaghetti ;-)

==== Alertes de sécurité

Il existe quatre niveaux où des failles de sécurité peuvent s'immiscer :

- votre propre code — des revues de code, une amélioration de vos connaissances et la commande d'audits vous aideront à identifier les possibles failles et vulnérabilités ;
- des vulnérabilités contenues dans vos dépendances et dans les dépendances de vos dépendances ;
- des vulnérabilités occasionnées par Node ;
- des vulnérabilités occasionnées par V8, dont le développement est indépendant du projet Node.

On n'oubliera pas les vulnérabilités liés à votre système d'exploitation, à ses logiciels ainsi qu'à son exposition au monde extérieur — mais ce n'est pas l'objet de cet ouvrage.

Plusieurs canaux sont à votre disposition pour être notifié très rapidement de mises à jour correctives :

- *Failles de sécurité de modules npm* : [URL]#https://nodesecurity.io/advisories# — et son flux RSS [URL]#https://nodesecurity.io/rss.xml# ;
- *Failles de sécurité de Node* : son flux RSS [URL]#https://nodejs.org/en/feed/vulnerability.xml# ;
- *Mises à jour de Node* : [URL]#https://nodejs.org/en/blog/# — et son flux RSS [URL]#https://nodejs.org/en/feed/blog.xml#.


== Conclusion

TBD.

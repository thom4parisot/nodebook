:chapterNumber: 7
:chapterId: chapter-07
:sourceDir: ./examples
:serverUrl: http://localhost:4000
:nodeCurrentVersion: v10
:npmCurrentVersion: v6
:sectnums:
:revdate: {docdate}
:imagesdir: {indir}
ifdef::env[]
:imagesdir: .
endif::[]

= Créer une application web

TBD.

====
.Sommaire
- TBD.
====

[abstract]
--
TBD.
--

include::../docs/tip-versions.adoc[]

Une application web est une *construction applicative qui est à l'écoute*
de connexions réseaux initiées par un client.
Elle est structurée autour de la lecture d'une requête entrante (lecture)
et l'émission d'une réponse sortante (écriture).
Chaque *requête porte en elle une intention* — un chemin d'accès, une préférence
de format, des éléments d'identification — et implique une réponse en retour
— des données et des éléments pour les contextualiser.

L'ingénierie d'une application web consiste à comprendre les requêtes entrantes
et à construire une réponse appropriée à chaque fois, le plus rapidement possible.

Ce chapitre s'inscrit dans la continuité du
<<../chapter-04/index.adoc#http,module `http`>> (re)découvert au cours du
<<../chapter-04/index.adoc#,chapitre 4>>.

////
# Et si je devais créer un serveur web, comment ça se passe ?
- distingo serveur web/serveur http ? (pas sûr que ça vaille le coup/coût à ce stade là)
- c'est quoi cette histoire d'ouvrir un port pour lancer un serveur ?

- dans le cas de formulaire, le client _envoie_ des informations en même temps que la requête
  - comme on est dans un format texte, il faut l'interpréter le parser

- les trucs auxquels il faut faire gaffe
  - qu'est-ce qui occupe de la mémoire ?
  - ça a d'autant plus d'impact qu'on est sur des processus longs (aka programme qui tourne en continu — le serveur web)
  - donc si on nettoie pas (ce qu'on ouvre, si on charge tout d'un coup), les ressources disponibles diminuent jusqu'au plantage
////

[NOTE]
.[RemarquePreTitre]#Documentation# Entêtes HTTP
====
Ce chapitre fait souvent référence à des entêtes HTTP.
La documentation _MDN web docs_ ([URL]#https://developer.mozilla.org/fr/docs/Web/HTTP/Headers#)
les liste toutes, avec le détail de leurs valeurs possibles.

C'est un onglet intéressant à ouvrir en parallèle de cette lecture
— je l'ai ouvert en permanence pour écrire ce chapitre.
====

[[webapp]]
== Composer son application web

Dans cette première section, nous allons nous focaliser sur la construction
d'une application web avec une approche modulaire.
Nous partirons du concept de requête et de réponse
Petit à petit, nous allons greffer des modules pour comprendre et
donner du sens à leur contenu respectif.

Le _protocole HTTP_ est le dialecte informatique utilisé et compris pour exprimer
les requêtes (émises par un client) et les réponses (émises par un serveur).
Les navigateurs web sont des clients tandis que notre application Node est un serveur.

Le logiciel _curl_ ([URL]#https://curl.haxx.se#) est un client en ligne de commande.
Il est souvent installé par défaut sur les distributions Linux, sur macOS et
à partir de Windows 7 — via le terminal _PowerShell_.

Utilisons _curl_ pour observer le contenu d'une requête et sa réponse.

.Exemple de requête HTTP vers le site [URL]#perdu.com#.
----
$ curl -v http://perdu.com  # <1>
GET / HTTP/1.1              # <2>
Host: perdu.com             # <3>
User-Agent: curl/7.54.0
Accept: */*
----
<1> Exécution de la requête.
<2> Expression de la méthode, du chemin d'accès demandé et du protocole de discussion employé — ici, le protocole HTTP dans sa version `1.1`.
<3> Entête de requête.

Un entête est exprimé sous la forme `Clé: Valeur`.
Chaque entête précise un élément de contexte.
Certaines entêtes influencent plus que d'autres la réponse du serveur, si
celui-ci la comprend.

Voyons maintenant la réponse.

.Exemple de réponse HTTP transmise en retour.
----
HTTP/1.1 200 OK                                       # <1>
Date: Thu, 28 Jun 2018 19:02:27 GMT                   # <2>
Server: Apache
Last-Modified: Thu, 02 Jun 2016 06:01:08 GMT
ETag: "cc-5344555136fe9"
Accept-Ranges: bytes
Content-Length: 204
Vary: Accept-Encoding
Content-Type: text/html                               # <3>

&lt;html>&lt;head>&lt;title>Vous Etes Perdu ?&lt;/title> …&lt;/html> # <4>
----
<1> Expression du statut de la réponse avec un code numérique et une version intelligible.
<2> Entête de réponse.
<3> Entête de réponse — celle-ci indique au client comment interpréter le corps du message.
<4> Corps du message.

La réponse dispose elle aussi d'entêtes.
Cette fois, elles guident le client dans son interprétation du résultat.
Le corps du message est séparé par une ligne vide.
C'est la partie visible de la réponse dans un navigateur web, c'est le contenu
qui s'affiche sous nos yeux.

Dans la prochaine section, nous allons visualiser ces mêmes informations
à partir d'un serveur HTTP que nous allons créer par nous-même.
Nous retracerons plus en détail l'odyssée d'une requête HTTP dans la section
<<http,Comprendre le modèle HTTP>>, en fin de chapitre.

include::../docs/tip-examples.adoc[]

[[server]]
=== Démarrer un serveur HTTP

Nous l'avons vu juste avant : une requête HTTP envoyée vers un hôte
renvoie une réponse.
Cet hôte doit au préalable avoir installé et démarré un serveur HTTP qui
écoute ces demandes.

Le script d'exemple `server/start.js` répond à ce besoin.
Une fois démarré, il est joignable à l'adresse `{serverUrl}`.
Il affichera alors les entêtes des requêtes et de leur réponse :

----
$ node server/start.js
----

[source%interactive%endpoint,javascript]
.server/start.js
----
include::{sourceDir}/server/start.js[]
----
<1> Comme nous retournons du HTML au client, nous explicitons le type de contenu retourné en réponse.
<2> Affiche les entêtes de la requête reçue par le serveur — le contenu varie selon le client utilisé.
<3> Affiche les entêtes de la réponse — en l'occurrence `{ 'content-type': 'text/html' }`.

Nous avons composé la fondation minimum pour créer une application web
en étant en mesure d'accepter des requêtes et de répondre, quelque chose
d'arbitraire certes mais quelque chose qui est compris par un navigateur web.

*Pourquoi avoir démarré le serveur sur le port 4000* dans l'exemple précédent ?
C'est un choix arbitraire de ma part : nous pouvons démarrer un serveur HTTP
sur n'importe quel port tant qu'il est libre et supérieur ou égal à 1000.
Quand on cherche à se connecter à une adresse comme `http://localhost` (HTTP)
ou `https://localhost` (HTTPS), la valeur du port vaut implicitement 80 et 443,
respectivement.

Le module npm _get-port_ ([URL]#https://npmjs.com/get-port#) retourne
un numéro de port parmi ceux disponibles sur le système d'exploitation.

----
$ node server/port.js
http://localhost:51765
----

[source%interactive,javascript]
.server/port.js
----
include::{sourceDir}/server/port.js[]
----
<1> Exprime une préférence pour retourner le port 4000 s'il est disponible.
<2> Affiche `{serverUrl}` si le port est disponible, sinon un autre nombre s'affichera à la place.
<3> Le serveur se met à l'écoute sur ce port.

Pour vous en rendre compte, démarrez le script `server/start.js` pour utiliser
le port 4000 et démarrez ensuite `server/port.js`.

[[path]]
=== Répondre à un chemin (_routing_)

Nous avons vu qu'une URL est un identifiant qui se décompose en plusieurs
parties grâce au <<../chapter-04/index.adoc#url,module `url`>>
(cf. <<../chapter-04/index.adoc#,chapitre 4>>).
Une de ces parties est le _chemin d'accès_ à une ressource. +
Par exemple, le chemin de l'URL `{serverUrl}/coucou` est `/coucou`.

----
$ node path/request-url.js
----

[source,javascript]
.path/request-url.js
----
include::{sourceDir}/path/request-url.js[]
----
<1> Affiche un message spécifique au chemin `/`.
<2> Affiche un autre message spécifique au chemin `/coucou`.

Les deux seules ressources mises à disposition sur `http://localhost:4000`
sont accessibles avec les chemins `/` et `/coucou`.
Tout autre chemin n'aboutira pas.

C'est d'ailleurs un problème puisqu'en réalité, nous n'envoyons pas de réponse
pour un chemin inconnu.
Et c'est à nous de gérer ce cas de figure :

----
$ node path/404.js
----

[source,javascript]
.path/404.js
----
include::{sourceDir}/path/404.js[]
----
<1> Seul le chemin `/` est disponible dans l'application.
<2> Le code HTTP de la réponse est réglé sur `404`.
<3> Une page introuvable peut quand même retourner du contenu.

La prise en compte d'une ressource inconnue à notre application fait émerger
un nouveau concept : le _statut de la réponse_.
Ce statut est un code numérique qui donne des indications sur la ressource retournée.
Dans ce cas de figure le statut `404` de la réponse indique au client de
ne pas considérer le contenu comme celui qui était demandé. +
Par défaut et sauf mention contraire, le statut est `200`.

[format="csv", options="header", cols="1,2,4"]
.Principaux codes HTTP et leur signification.
|===
Code, Raison, Explication
`200`, `OK`, La ressource demandée est retournée en réponse.
`301`, `Moved Permanently`, La ressource demandée a été déplacée.
`304`, `Not Modified`, La ressource n'a pas été modifiée depuis la dernière fois.
`400`, `Bad Request`, La requête est incomplète ou incompréhensible par le serveur.
`401`, `Unauthorized`, La ressource est accessible sur preuve d'identification.
`403`, `Forbidden`, L'accès à la ressource est interdit.
`404`, `Not Found`, La ressource n'existe pas.
`500`, `Internal Server Error`, Le serveur distant est en erreur.
|===

Les statuts HTTP sont importants dans la création d'applications web.
Leur code permet de vérifier que le client et le serveur se sont bien compris. +
Si une page d'erreur est affichée avec un statut `200`, le client sera dans
l'impossibilité de deviner qu'il ne s'agit pas du contenu attendu.

[options="header", cols="1,1,4"]
.D'autres codes HTTP utiles à connaître.
|===
| Code | Raison | Explication
| `201` | `Created` | La ressource demandée a été créée.
| `202` | `Accepted` | La demande a été acceptée et la ressource sera disponible ultérieurement.
| `204` | `No Content` | La ressource demandée n'a pas de contenu.
| `302` | `Found` | La ressource demandée est temporairement disponible à une autre adresse.
| `503` | `Service Unavailable` | Le serveur distant répond qu'il n'est pas disponible pour l'instant.
|===

Une application web devient vite compliquée à se gérer si nous avons à lister
tous les chemins possibles.
C'est à ce moment qu'entre en jeu le _routing_, une technique pour décrire
des chemins d'accès au lieu de s'embourber dans une longue liste de `if/else`.

Nous utilisons le module npm _find-my-way_ ([URL]#https://npmjs.com/find-my-way#)
pour transformer l'exemple `path/request-url.js`
en quelque chose de plus modulaire :

----
$ node path/routes.js
----

[source,javascript]
.path/routes.js
----
include::{sourceDir}/path/routes.js[]
----
<1> Création de la table de routage.
<2> Définition de la réponse du chemin d'accès `/`.
<3> Définition de la réponse du chemin d'accès `/coucou`.
<4> Intégration du routeur aux requêtes entrantes du serveur HTTP.

Les routeurs commencent à nous vraiment nous faire gagner du temps
lorsqu'il s'agit d'extraire des informations utiles depuis le chemin et
de les gérer dynamiquement :

----
$ node path/route-params.js
----

[source,javascript]
.path/route-params.js
----
include::{sourceDir}/path/route-params.js[]
----
<1> Création d'une route paramétrée — le symbole `:word` est accessible dans le troisième argument, en tant que `params.word`.
<2> Affiche une phrase composée avec le paramètre de notre route.

Dirigez-vous vers `{serverUrl}/hello/word` pour voir le résultat s'afficher.
Changez le dernier segment du chemin pour observer le changement.

Ce mécanisme est utile pour relier un identifiant à un enregistrement précis
en base de données, par exemple.
Il se complète avec les <<argument,arguments d'URL>> pour véhiculer des
éléments optionnels — nous en parlons quelques sections plus loin.

[CAUTION]
.[RemarquePreTitre]#Sécurité# Filtrer les données entrantes
====
C'est le moment de rappeler que *toute information saisie par l'utilisateur*
doit être filtrée et nettoyée avant d'être utilisée.
L'exemple `path/route-params.js` n'est pas sécurisé ; vous vous en rendrez
compte en visitant [URL]#{serverUrl}/hello/++<script>alert(h4ck)<%2Fscript>++#. +
Ce type de failles s'exploite pour faire fuiter des données confidentielles.

Nous verrons tous ces aspects plus en détail dans la section
<<security,protéger l'application>>.
====

Enfin, les routeurs contextualisent les actions à effectuer vis-à-vis d'une
ressource grâce au _verbe HTTP_.
Le verbe communique une intention — récupération, mise à jour, suppression.
Le routeur organise notre code pour déclencher une action adaptée
à la méthode employée :

----
$ node path/method.js
----

[source,javascript]
.path/method.js
----
include::{sourceDir}/path/method.js[]
----
<1> Définition du chemin d'accès `/` — verbe `GET` (récupération).
<2> Définition du chemin d'accès `/` — verbe `HEAD` cette fois.
<3> La méthode `response.writeHead` est un moyen de définir le statut en même temps que les entêtes de réponse.
<4> Définition d'un entête personnalisé — le préfixe `X-` indique qu'il n'est pas lié au standard HTTP.
<5> Écriture du corps du message — nous verrons qu'il est ignoré et n'est pas transmis au client.

Les navigateurs web affichent seulement notre route `GET` car c'est
leur fonctionnement par défaut.
Ils comprennent le verbe `POST` pour <<upload,uploader des fichiers>> ou
<<post,transmettre des formulaires>>. +
Tournons-nous à nouveau vers le programme `curl` pour observer les différences
entre la réponse nos deux verbes HTTP `GET` et `HEAD` :

[subs="+attributes,+quotes"]
----
$ curl {serverUrl}
Bienvenue
$ curl ##--head## {serverUrl}
HTTP/1.1 200 OK
##X-Jobs: https://jobs.humancoders.com##
Date: Sun, 01 Jul 2018 15:43:56 GMT
Connection: keep-alive
----

L'utilisation de `HEAD` renvoie uniquement les entêtes de réponse et nous
économise la <<templating,génération d'un gabarit>>.
D'un point de vue client, le verbe `HEAD` aide à inspecter des ressources
sans avoir à télécharger le contenu — ce sont autant de kilo ou méga-octets
d'économisés.

[options="header", cols="1,4"]
.Principaux verbes HTTP et leur utilisation.
|===
| Verbe | Description
| `GET` | Récupération d'une ressource.
| `HEAD` | Récupération d'une ressource — seulement les entêtes.
| `POST` | Création d'une ressource.
| `PUT` | Mise à jour d'une ressource.
| `PATCH` | Mise à jour _partielle_ d'une ressource.
| `DELETE` | Demande de suppression d'une ressource.
|===

La responsabilité de comprendre ces verbes revient à notre application.
C'est donc à nous de leur associer une action pour les prendre en charge.

[[static]]
=== Répondre avec des fichiers statiques

Les <<path,chemins d'accès>> s'associent aussi à des fichiers statiques.
Ainsi, une URL correspond un fichier placé sur notre disque dur.
J'ai placé 3 fichiers de différente nature (texte, image, PDF) pour illustrer
les exemples de cette section.

----
$ tree -a static/files
static/files
├── .eslintrc.yaml
├── doc.pdf
└── screenshot.jpg
----

Nous allons commencer par mettre à disposition un seul fichier, quel que soit
le chemin demandé :

----
$ node static/routes.js
----

[source,javascript]
.static/routes.js
----
include::{sourceDir}/static/routes.js[]
----
<1> Nous constituons un chemin d'accès avec `path.join` — cf. <<../chapter-04/index.adoc#path,chapitre 4>>, module `path`.
<2> Nous créons un flux de lecture vers ce fichier — cf. <<../chapter-04/index.adoc#stream,chapitre 4>>, module `stream`.
<3> Nous redirigeons le flux de lecture vers la réponse.

Ce que cet exemple nous apprend,
c'est que l'*objet de réponse est aussi un flux d'écriture*.
Peu importe le volume du fichier, l'envoi se régulera en fonction de la capacité
de téléchargement du client et en consommant le minimum de mémoire possible.
La lecture sera interrompue si le client annule le téléchargement.

Nous pouvons à présent étendre ce savoir nouvellement acquis en
<<path,routant un chemin d'accès>> vers le répertoire qui contient nos fichiers.

----
$ node static/routes.js
----

[source,javascript]
.static/routes.js
----
include::{sourceDir}/static/routes.js[]
----
<1> Création d'une route paramétrée qui répond avec la fonction `staticFiles`.
<2> Réutilisation de la fonction `staticFiles` pour répondre à la méthode `HEAD` — nous verrons plus loin pourquoi c'est important.
<3> Composition dynamique du chemin d'accès au fichier.
<4> Comme toute à l'heure, nous redirigeons le flux de lecture du fichier vers la réponse.

Si nous accédons à `{serverUrl}/files/doc.pdf` et `{serverUrl}/files/screenshot.jpg`,
nous verrons les deux documents s'afficher dans notre navigateur.
Un problème cependant : l'accès à un chemin inconnu fait planter l'application.

Notre approche est un peu trop naïve en regardant les entêtes
de réponse d'un peu plus près :

----
$ curl --head 'http://localhost:4000/files/doc.pdf' # <1>
HTTP/1.1 200 OK
Date: Mon, 02 Jul 2018 15:47:33 GMT
Connection: keep-alive
----
<1> C'est pour exécuter cette commande que j'ai ajouté l'écoute de la méthode `HEAD`.

En fait, nous gagnerions à documenter la ressource en transmettant
des entêtes supplémentaires.
La question est : lesquelles ?

[CAUTION]
.[RemarquePreTitre]#Sécurité# Filtrer les données entrantes
====
*Toute information saisie par l'utilisateur* doit être filtrée et nettoyée avant
d'être utilisée.
L'exemple `static/routes.js` n'est pas sécurisé ; vous vous rendrez
compte en visitant [URL]#{serverUrl}/files/..%2F..%2Fhello.js# que ce chemin
permet de remonter jusqu'à un fichier situé hors du répertoire `static/files`. +
Ce type de faille s'exploite pour accéder aux données confidentielles de notre
système d'exploitation.

Nous verrons tous ces aspects plus en détail dans la section
<<security,protéger l'application>>.
====

Nous allons nous baser sur le module npm _send_ ([URL]#https://npmjs.com/send#)
pour améliorer l'exemple précédent et constater par nous-même quelles
entêtes sont utiles.

----
$ node static/send.js
----

[source,javascript]
.static/send.js
----
include::{sourceDir}/static/send.js[]
----
<1> En utilisant la syntaxe `*`, le routeur accepte une arborescence de chemins — `doc.pdf` tout comme `un/long/chemin.pdf`.
<2> L'arborescence se récupère avec un paramètre du même nom — `*`.
<3> Le module _send_ prend en charge la suite de la transmission.

Pas de grands bouleversements donc.
Si ce n'est que les fichiers inexistants ne font plus planter l'application
et que les entêtes de réponses sont plus fournies qu'avant :

----
$ curl --head 'http://localhost:4000/files/doc.pdf'
HTTP/1.1 200 OK
Accept-Ranges: bytes
Cache-Control: public, max-age=0
Last-Modified: Tue, 12 Jun 2018 08:02:40 GMT
ETag: W/"10c5d-163f304b0d2"
Content-Type: application/pdf
Content-Length: 68701
Date: Mon, 02 Jul 2018 15:52:18 GMT
Connection: keep-alive
----

Parmi les entêtes les plus importantes, nous trouvons `Content-Type`,
`Content-Length` et `Last-Modified`.
Elles aident le client à interpréter ou représenter le contenu de manière optimale,
à informer de la taille du contenu (utile à l'animation de la barre de
téléchargement du navigateur web) et à distinguer l'ancienneté du fichier.

[options="header", cols="1,3"]
.Entêtes de réponse utiles pour transmettre des fichiers.
|===
| Entête                | Utilité
| `Content-Type`        | Explicite la nature du contenu mis à disposition.
| `Content-Disposition` | Indique si le contenu doit être affiché dans le client ou téléchargé sous un nom particulier.
| `Cache-Control`       | Active ou désactive la mise en cache de ce fichier par le client.
| `Last-Modified`       | Indique la date de dernière modification du contenu.
| `Content-Length`      | Indique la longueur (en octets) du contenu.
| `Content-Encoding`    | Indique le mode de compression utilisé pour transmettre les données.
| `Accept-Ranges`       | Indique la possibilité ou non de reprendre un téléchargement ou d'en choisir un segment avec l'entête de requête `Range`.
|===

[TIP]
.[RemarquePreTitre]#Performance# Utiliser Apache ou nginx en production
====
Si Node s'en sort bien pour envoyer des fichiers vers le client,
les serveurs web _Apache_ et _nginx_ sont encore plus performants à ce niveau.
C'est quelque chose à considérer si votre application sert principalement
des fichiers statiques.

Lisez le <<../chapter-06/index.adoc#,chapitre 6>> pour apprendre à configurer
Node derrière un autre serveur web.
====

[[arguments]]
=== Réagir aux arguments d'URL

Les arguments d'une URL servent à *affiner le contexte d'affichage* d'une
ressource donnée.
Ces options servent par exemple à paginer du contenu ou spécifier une dimension,
un filtre d'affichage ou encore une expression de recherche.
En clair, elles servent à influencer la représentation d'une ressource
ou information.

Par défaut, les arguments sont représentés de manière textuelle avec
le chemin d'accès, dans l'attribut `request.url` :

----
$ node arguments/intro.js
----

[source,javascript]
.arguments/intro.js
----
include::{sourceDir}/arguments/intro.js[]
----
<1> La page demandée affiche l'attribut de requête `url`.

Nous voyons s'afficher `/test?cle=valeur&option` en nous rendant à l'adresse
`{serverUrl}/test?cle=valeur&option`.
Ce n'est pas utilisable en l'état.

Le <<../chapter-04/index.adoc#url,module `url`>>
(cf. <<../chapter-04/index.adoc#,chapitre 4>>) entre en jeu.
En plus de déstructurer une URL entière, il sait aussi décomposer les options
et les transformer en un objet utilisable côté Node :

----
$ node arguments/parse.js
----

[source,javascript]
.arguments/parse.js
----
include::{sourceDir}/arguments/parse.js[]
----
<1> Le deuxième argument de la fonction `url.parse` décompose les arguments, disponibles dans l'attribut `query` de l'objet retourné.
<2> L'attribut `search` correspond aux arguments, sous forme textuelle.
<3> L'attribut `query` est un objet — ici, transformé pour être affiché dans la page sous forme de texte.

Cette fois, nous voyons s'afficher `{"cle": "valeur", "option": ""}` dans notre
navigateur lorsque nous nous rendons sur `{serverUrl}/test?cle=valeur&option`.
C'est tout ce qu'il nous fallait pour l'utiliser dans notre application.

----
$ node arguments/format.js
----

[source,javascript]
.arguments/format.js
----
include::{sourceDir}/arguments/format.js[]
----
<1> Nous rentrons dans ce bloc en présence de l'argument d'URL `format=svg`.
<2> L'entête `Content-Type` fait que le contenu est interprété (et affiché) comme du HTML — en retirant cette ligne, le document sera alors téléchargé.
<3> Sinon, le reste du temps nous affichons la date telle quelle, en tant que texte.

Les deux URL `{serverUrl}/date?format=svg` et `{serverUrl}/date` font
référence à une même ressource mais l'affichage s'adapte au contexte.

[options="header"]
.Exemples d'arguments et de leur représentation en structure ECMAScript.
|===
| Argument            | Représentation
| `?cle=valeur`        | `{cle: "valeur"}`
| `?cle`               | `{cle: ""}`
| `?cle[]=1&cle[]=2`   | `{cle: [1,2]}`
|===

[TIP]
.[RemarquePreTitre]#Performance# Module npm _parseurl_
====
Si vous êtes à la recherche de performance, le module npm _parseurl_
([URL]#https://npmjs.com/parseurl#) retourne les mêmes résultats
tout en étant jusqu'à 10 fois plus rapide que le module natif à Node.
====

[[post]]
=== Recevoir des données de formulaire (`POST`)

Lorsque nous ne précisons pas la méthode employée, les outils et logiciels
utilisent par défaut la méthode `GET`.
Elle est associée à une récupération de données sans transmettre autre chose
que des entêtes et un chemin d'accès.

Il y a des cas où nous avons besoin d'envoyer des données, pour les stocker
ou pour demander à créer un enregistrement.
Dans ce cas, nous utilisons la méthode `POST` et nous transmettons les informations
d'une manière différente des <<arguments>>.

Le serveur suivant affichera deux choses à chaque requête reçue : l'entête
`Content-Type` et le corps du message transmis par la requête.

----
$ node post/server.js
----

La commande `curl` règle le nom et la valeur d'un champ de formulaire
avec l'option `-d`.
Nous pouvons ainsi transmettre des données avec la méthode `POST` à notre
serveur :

----
$ curl -XPOST -d 'fromage=cabécou' -d 'remember_me=1' \
  http://localhost:4000
----

C'est vraiment l'équivalent d'un classique formulaire HTML.

.Représentation d'un formulaire HTML qui envoie les mêmes informations que la commande `curl` précédente.
image::images/send-data.png[]

[source,html]
.post/index.html
----
include::{sourceDir}/post/index.html[]
----
<1> Nous retrouvons l'indication de la méthode `POST`.

L'ouverture dans un navigateur web d'une page HTML affichera les mêmes informations
que la commande `curl` sur appui du bouton btn:[Transmettre].

Il se trouve que Node aussi sait envoyer des informations de formulaire
avec le <<../chapter-04/index.adoc#http,module `http`>>
(cf. <<../chapter-04/index.adoc#,chapitre 4>>).

----
$ node post/send.js
----

[source,javascript]
.post/send.js
----
include::{sourceDir}/post/send.js[]
----
<1> Création de la structure des données à transmettre.
<2> Indication de la méthode `POST`.
<3> Cette entête caractérise la manière d'organiser les données de formulaire — personnellement, je n'arrive jamais à retenir cette valeur et je la copie/colle toujours depuis Stack Overflow ou une documentation technique.
<4> Les données sont sérialisées sous forme d'une chaîne de caractères, identique à ce que ferait un navigateur web avec les données d'un formulaire.

Nous retrouvons l'entête `Content-Type` dans l'affichage du script `post/server.js`.
Le contenu du message envoyé ressemble beaucoup à des arguments d'URL
encodés avec <<encode-uri,encodeURIComponent>>.

.Extrait d'affichage d'un message reçu par `post/server.js`.
----
application/x-www-form-urlencoded
fromage=cab%C3%A9cou&remember_me=1
----

Comme dans les sections précédentes, nous devons _décoder_ une chaîne de
caractères pour en extraire sa signification et en faire quelque chose
en ECMAScript.

Nous pourrions utiliser la fonction `parse` du module Node `querystring`
pour décoder le contenu de cette chaîne  mais nous allons plutôt faire appel
au module npm _co-body_ ([URL]#https://npmjs.com/co-body#).
Ce module décode plusieurs types de requêtes `POST`, illustrés dans d'autres
exemples de cette même section.

----
$ node post/server-parse.js
----

[source,javascript]
.post/server-parse.js
----
include::{sourceDir}/post/server-parse.js[]
----
<1> Le module _co-body_ transforme une requête HTTP en un objet utilisable dans Node.
<2> Le contenu de la variable ressemblera plutôt à quelque chose du genre de `{fromage: 'cabécou', remember_me: '1'}`.
<3> Une erreur s'affichera en cas de problème pour décoder le corps de la requête entrante.

Il nous suffit d'exécuter à nouveau le script `post/send.js` pour observer
la différence et constater que nous pouvons désormais interpréter les données
d'un formulaire.

Le fichier `post/send.js` se simplifie si on utilise le module npm _superagent_
([URL]#https://npmjs.com/superagent#).
Je le trouve simple d'utilisation et il fonctionne avec des promesses,
des formulaires et les <<upload,uploads de fichiers>>.

[source,javascript]
.post/send-data.js
----
include::{sourceDir}/post/send-data.js[]
----
<1> URL de la ressource vers laquelle poster les informations.
<2> La définition d'un champ de formulaire s'effectue à l'aide de la méthode `send()` et d'une valeur ayant la forme d'une chaîne de caractères.

À ce stade-là, nous avons fait le nécessaire pour interpréter le contenu d'un
formulaire sans pièce-jointe.
Notre serveur est même prêt à recevoir des données transmises en dehors d'un
formulaire, au format JSON :

----
$ node post/send-json.js
----

[source,javascript]
.post/send-json.js
----
include::{sourceDir}/post/send-json.js[]
----
<1> L'utilisation d'un objet ECMAScript suffit au module _superagent_ pour transmettre les données au format JSON.

Nous constatons que la valeur de l'entête `Content-Type` change pour devenir
`application/json`.
Là aussi, le module _co-body_ nous est utile car il s'adapte au type de données
entrantes et les décode de manière transparente.

Il existe un dernier type d'encodage de données que nous pouvons nous
attendre à recevoir.
Ce sont les formulaires dits "_multipart_".

----
$ node post/send-multipart.js
----

[source,javascript]
.post/send-multipart.js
----
include::{sourceDir}/post/send-multipart.js[]
----
<1> Le module _superagent_ utilise la méthode `field()` pour définir la valeur d'un champ _multipart_.

Le serveur va pourtant afficher une erreur du type :

----
Unsupported content-type: multipart/form-data;
  boundary=--------------------------070345340228095473881249
----

Ce type d'encodage de données est plus complexe à gérer.
Il va nous falloir passer à une autre stratégie ; elle est incontournable
pour gérer l'<<upload,upload de fichiers>>.
C'est l'objet de la section suivante.

[[upload]]
=== Uploader des fichiers

L'upload de fichier implique un peu plus de travail qu'un <<post,simple formulaire>>
car la structure des données envoyées diffère mais surtout,
parce que la réception et la gestion des fichiers demandent encore plus
d'attention.

Voyons par nous-même à quoi ressemble une requête qui contient une pièce-jointe.

----
$ node upload/server.js
----

[source,javascript]
.upload/server.js
----
include::{sourceDir}/upload/server.js[]
----

Ce serveur affiche le contenu d'une requête entrante.
La requête suivante illustre l'upload d'un fichier avec le programme `curl`.
Notez que cette fois-ci nous utilisons l'options `-F` et que la valeur
est préfixée avec le caractère `@`, suivi du chemin d'accès au fichier en question.

[subs="+quotes"]
----
$ curl -XPOST -F 'hello=##@upload/hello.txt##' \
    http://localhost:4000
----

Cette commande est équivalente à l'envoi du formulaire HTML suivant :

.Représentation d'un formulaire HTML qui téléverse un fichier.
image::images/send-file.png[]

[source,html]
.upload/index.html
----
include::{sourceDir}/upload/index.html[]
----
<1> Nous retrouvons l'encodage `multipart/form-data` dans l'attribut `enctype`.
<2> Un fichier se téléverse avec un champ de type `file`.

Ainsi, la commande `curl` ou l'envoi du formulaire précédent affiche quelque
chose de cet ordre-là :

----
multipart/form-data; boundary=-----1acfa07ebbd71d3c # <1>

-----1acfa07ebbd71d3c                               # <2>
Content-Disposition: form-data; name="hello";
  filename="hello.txt"                              # <3>
Content-Type: text/plain                            # <4>

Hello World

-----1acfa07ebbd71d3c----                           # <5>
----
<1> Contenu de l'entête `Content-Type` — l'attribut `boundary` précise le motif de délimitation des différents champs.
<2> Ouverture des informations du premier champ.
<3> Les attributs `name` et `filename` définissent le nom du champ de formulaire et le nom du fichier en question, respectivement.
<4> L'attribut `Content-Type` concerne le fichier et aide à comprendre comment interpréter son contenu — ici, du texte brut.
<5> Fermeture des informations du premier champ.

Ça nous demanderait d'écrire davantage que 20 lignes de code si nous devions
nous-même interpréter un contenu de requête qui contient des pièces-jointes.
C'est suffisamment compliqué à programmer de manière robuste que le module
_co-body_ vu dans la <<post,section précédente>> ne s'en charge pas et recommande
le module _formidable_ ([URL]#https://npmjs.com/formidable#).
C'est exactement ce que nous allons faire pour outiller un nouveau serveur.

----
$ node upload/server-parse.js
----

[source,javascript]
.upload/server-parse.js
----
include::{sourceDir}/upload/server-parse.js[]
----
<1> Le module _formidable_ différencie les données et les fichiers.
<2> Nous accédons aux informations d'un fichier au travers d'une clé, identique à celle de son champ `name` dans le formulaire.
<3> Affiche `text/plain` — la valeur du `Content-Type` du fichier.
<4> Affiche `hello.txt` — c'est le nom du fichier tel qu'il était nommé sur le poste client.
<5> Affiche `12` — c'est le poids total du fichier.
<6> Affiche un chemin d'accès vers l'emplacement de stockage temporaire du fichier téléversé.

Nous sommes en mesure de recevoir des pièces-jointes depuis un formulaire.
Le <<../chapter-04/index.adoc#fs,module `fs`>> (cf. <<../chapter-04/index.adoc#,chapitre 4>>)
propose le nécessaire pour déplacer le fichier ailleurs sur le système ou
pour en lire le contenu et le stocker ailleurs — sur un service de stockage distant
comme Amazon S3, par exemple.

[CAUTION]
.[RemarquePreTitre]#Sécurité# Un fichier texte n'a de texte que le nom
====
Comme toutes données transmises par un utilisateur ou une utilisatrice,
nous devons rester vigilant·e sur le contenu des fichiers pour
éviter des attaques malicieuses.

Un fichier texte qui contient du JavaScript pourrait être exécuté comme un
script sur le poste client et ainsi servir à subtiliser des données privées
ou aider quelqu'un·e à usurper une identité sur le service.
====

Je recommande deux approches sensibles avant même de faire quoique ce soit
avec pièce-jointe fraichement téléversée :

- s'il s'agit d'un *fichier texte* : filtrer le contenu du fichier en retirant
tout ce qui ressemble à du code arbitraire et filtrer le contenu à l'affichage
pour retirer tout balisage HTML — cf. section <<security,protéger son application>>
dans ce même chapitre ;
- s'il s'agit d'un *fichier binaire* (image, vidéo, PDF) : utiliser un antivirus
en ligne de commande pour scanner le contenu — _ClamAV_ ([URL]#https://www.clamav.net#)
est un excellent antivirus _open source_.

Ces opérations peuvent prendre du temps — de quelques secondes à plusieurs
minutes dans le cas de fichiers volumineux.
Au lieu de faire attendre l'utilisateur devant son écran, je recommande
de faire appel à un <<job-queue,mécanisme de file d'attente>> pour traiter
l'effort indépendamment, en fonction des capacités de calcul disponibles.

Enfin, quand vous avez fini d'utiliser la pièce-jointe — ou si vous ne l'utilisez pas —
pensez aussi à la *supprimer du répertoire temporaire*.
Le disque dur du serveur pourrait manquer d'espace si plusieurs fichiers volumineux
étaient déposés en peu de temps.

[[cookies]]
=== Garder un lien avec les cookies

Un cookie est une information partagée entre un client et un serveur pour
une durée limitée dans le temps.
Le client transmet les cookies au serveur afin que ce dernier contextualise
la demande — un identifiant utilisateur, des préférences ou autre.
Un cookie créé par le domaine `example.com` est envoyé seulement lors d'une
visite à `example.com` — sous-domaines inclus.

Ce mécanisme est aujourd'hui tristement célèbre pour son détournement
par les industries de la publicité, du marketing et de la revente de données.

----
$ node cookies/set-cookie.js
----

[source,javascript]
.cookies/set-cookie.js
----
include::{sourceDir}/cookies/set-cookie.js[]
----
<1> L'entête de réponse `Set-Header` crée/modifie la valeur d'un cookie chez le client — ici, le cookie `compteur` est créé avec la valeur `1`.

Nous pouvons observer la création du cookie en nous rendant sur `{serverUrl}`
avec un navigateur, puis en ouvrant les outils de développement.

.Visualisation des cookies avec les outils de développement du navigateur Firefox.
image::images/cookies-browser.png[]

Les cookies sont transmis du client au serveur *à chaque requête*.

----
$ node cookies/read.js
----

[source,javascript]
.cookies/read.js
----
include::{sourceDir}/cookies/read.js[]
----
<1> Les cookies se lisent en inspectant l'entête de requête `Cookie`.
<2> Affiche `Contenu : compteur=1`.

Nous avons récupéré la valeur de l'entête contenant le cookie.
Nous devons faire un effort supplémentaire pour transformer cette valeur textuelle
en une structure ECMAScript qui fait sens pour notre application.

Nous allons nous aider pour cela du module npm _cookie_
([URL]#https://npmjs.com/cookie#).
Il sait interpréter le contenu d'un entête HTTP et il sait également faire
l'inverse, transformer une structure ECMAScript vers du texte utilisable
dans l'entête de réponse `Set-Cookie`.

----
$ node cookies/parse.js
----

[source,javascript]
.cookies/parse.js
----
include::{sourceDir}/cookies/parse.js[]
----
<1> Nous passons l'intégralité de l'entête de requête `Cookie` à la fonction `cookie.parse`.
<2> Affiche `{"compteur":"1"}`.

La méthode `response.setHeader()` accepte un tableau pour créer plusieurs
cookies en même temps :

----
$ node cookies/set-multiple.js
----

[source,javascript]
.cookies/set-multiple.js
----
include::{sourceDir}/cookies/set-multiple.js[]
----
<1> Nous créons plusieurs cookies en passant un tableau de valeurs à la méthode `response.setHeader()`.
<2> Crée un cookie dont la durée est limitée à 9 millions de secondes (~104 jours).
<3> Crée un cookie visible pour le chemin d'accès `/path` (et les sous-chemins) — la deuxième directive empêche les scripts clients de lire et modifier la valeur du cookie.
<4> L'utilisation de `cookie.serialize` est une autre manière de créer des cookies en construisant un objet ECMAScript au lieu d'une chaîne de caractères.
<5> La ligne précédente équivaut à l'écriture de cette ligne.

Le précédent exemple était aussi l'occasion de compléter les cookies avec
des directives.
Ces directives impactent leur durée de vie et leur visibilité.

Ça s'observe en lançant à nouveau le script `cookies/parse.js` :

----
$ node cookies/parse.js
----

L'accès à `{serverUrl}` affiche quelque chose comme `{"compteur":"1","language":"fr"}`
tandis que `{serverUrl}/admin` affiche un cookie supplémentaire —
`{"is_admin":"1","compteur":"1","language":"fr"}`.

[options="header", cols="1,4a"]
.Directives complémentaires à la valeur d'un cookie.
|===
| Directive | Explication
| `Max-Age` | Durée de vie du cookie en secondes. +
Si le nombre est inférieur ou égal à zéro, le cookie est supprimé. +
Si cette valeur n'est pas précisée, le cookie est supprimé à la fin de la session.
| `Domain` | Spécifie le domaine ou les sous-domaines applicables au cookie.
| `Path` | Contraint le cookie à ce répertoire et tous ses sous-répertoires.
| `Secure` | Le cookie est envoyé seulement si le document est demandé via HTTPS.
| `HttpOnly` | Le cookie ne peut pas être lu ou modifié côté client, via la variable `document.cookie`.
|===

Nous savons maintenant garder le lien avec nos utilisateurs.
Nous utiliserons d'ailleurs les cookies pour <<sessions,maintenir une session>>
avec un framework web.

[[templating]]
=== Structurer l'affichage avec les gabarits de présentation

Les gabarits de présentation (ou _templating_) répondent à deux problèmes :
séparer le code applicatif (le fond) de la présentation (la forme) et aussi
de structurer la complexité visuelle avec des composants réutilisables.

Nous allons nous pencher sur le module _nunjucks_ ([URL]#https://npmjs.com/nunjucks#).
Je l'apprécie pour son élégance et pour son caractère extensible.
Il y en a d'<<templating-engines,autres modules de présentation>> bien sûr,
et je vous invite à choisir celui qui vous parle le plus,
quitte à en changer par la suite.

J'attends plusieurs choses d'un système de gabarits : itérer facilement
sur des collections (tableaux, objets), appliquer des filtres, inclure des
portions de présentation et imbriquer ma page dans un modèle de présentation
— une sorte de décoration qui contient des choses que je veux garder hors du gabarit
(le menu principal, les balises `<meta>`, etc.).

Dans la suite de cette section, nous allons créer une présentation à partir
d'une liste de modules npm contenue dans un fichier JSON.
L'image suivante illustre très bien ce que nous cherchons à atteindre.

.Exemple de présentation qui met en scène des données dynamiques et des composants HTML.
image::images/template.png[width="70%"]

[source,javascript]
.templating/server.js
----
include::{sourceDir}/templating/server.js[]
----
<1> Nous configurons le module _nunjucks_ pour qu'il cherche les gabarits dans le même répertoire que le script de l'application.
<2> La méthode `render()` prend le contenu du fichier `list.njk` ainsi que les variables passées en argument pour compiler du HTML.
<3> Ce HTML est envoyé en réponse pour être interprété par un navigateur web.

Dans cet exemple, nous répondons la même chose peu importe le chemin demandé
au serveur.
Nous pourrions tout à fait ajouter un <<path,routeur>> afin de répondre avec
un template différent pour chacune des routes.
Nous verrons aussi dans la section <<express,organiser une application>>
qu'un des buts des _frameworks web_ est d'apporter ce genre de cohérence.

Côté serveur, nous prenons une structure qui ne change pas (le gabarit)
et nous la combinons avec une structure qui change (les données) pour générer
un rendu HTML adapté au client à l'origine de la requête.

[source,html]
.templating/list.njk
----
include::{sourceDir}/templating/list.njk[]
----
<1> Nous indiquons à _nunjuck_ d'envelopper ce gabarit avec la structure décrite dans `layout.njk`.
<2> Début de la déclaration d'un bloc nommé `content`.
<3> L'objet `dependencies` (qui est passé en paramètre au gabarit) est affiché après avoir été filtré avec la fonction native _nunjucks_ `length`.
<4> La boucle `for` répète le bloc de gabarit pour chaque élément de la collection — à la manière des méthodes `map()` et `forEach` des <<../chapter-03/index.adoc#array,tableaux ECMAScript>>.
<5> Les valeurs de `pkg` et de `version` changent à chaque itération.

Le gabarit se concentre sur la *transformation de données*.
Il faut au préalable avoir réuni et structuré les données nécessaires à l'affichage.
Nous avons la possibilité de fragmenter notre code de sorte à ce que chaque
gabarit contienne uniquement ce qui dépend de sa responsabilité.

Nous retrouvons ces principes de fonctionnement dans d'autres langages, à quelques
variations près.

[horizontal]
.Fonctionnement des expressions _nunjucks_.
`{%{nbsp}...{nbsp}%}`::
  Expression _nunjucks_ qui peut marquer le début ou la fin d'un bloc.
  Ce bloc contient une expression dont le contenu est affiché, inclus ou répété
  selon certaines conditions.
`{{{nbsp}variable{nbsp}}}`::
  Affichage de la valeur d'une variable sous forme d'une chaîne de caractères.
`{{{nbsp}variable{nbsp}|{nbsp}filtre{nbsp}}}`::
  Affichage de la valeur d'une variable après application d'un filtre de transformation.
  Le filtre n'est autre qu'une fonction ECMAScript intégrée au mécanisme de _nunjucks_.
  Nous pouvons accumuler les filtres pour transformer la valeur jusqu'à obtenir
  le résultat attendu.

Intéressons-nous maintenant au gabarit parent, `layout.njk` :

[source,html]
.templating/layout.njk
----
include::{sourceDir}/templating/layout.njk[]
----
<1> La variable `title` est elle aussi un argument passé au template dans `templating/server.js` — ce gabarit y a aussi accès.
<2> Le bloc `content` défini dans le fichier `list.njk` est injecté à cet endroit du gabarit.

Ce gabarit sert de "décoration", en englobant puis injectant son contenu de
manière précise et contrôlée.
Nous sommes en mesure de hiérarchiser l'organisation de la présentation et de
choisir comment imbriquer les gabarits entre eux.

[NOTE]
.[RemarquePreTitre]#Documentation# Gabarit et API
====
La documentation complète des fonctions de gabarit se trouve sur
[URL]#https://mozilla.github.io/nunjucks/templating.html#.
La section _API_ vous aidera à ajuster son intégration à votre application Node.
====

[options="header", cols="1,2,4a", id="templating-engines"]
.Sélection de moteurs de gabarits et dans quelle situation j'aurais une préférence à les utiliser.
|===
| Module      | Adresse                             | Pourquoi l'utiliser ?
| ejs         | [URL]#https://npmjs.com/ejs#        | Pour écrire ses gabarits avec ECMAScript.
| handlebars  | [URL]#https://npmjs.com/handlebars# | Performant, éprouvé et large catalogue de filtres prêt à l'emploi.
| nunjucks    | [URL]#https://npmjs.com/nunjucks#   | Mécanisme élégant de blocs, de filtres et d'héritage de gabarit.
| pug         | [URL]#https://npmjs.com/pug#        | Écriture très concise des balises avec un système d'indentation.
| React       | [URL]#https://npmjs.com/react#      | Pour réutiliser les mêmes composants que le front-end.
|===

Nous détaillons des <<../appendix-a/index.adoc#templating,exemples de rendu de gabarit>>
en <<../appendix-a/index.adoc#,annexe A>>.


[[dev]]
=== Pendant le développement : relancer le serveur automatiquement

Vous avez modifié un des exemples de ce chapitre pendant qu'il était en
cours d'exécution et vous avez remarqué que résultat ne changeait pas ?

C'est normal : la version du code utilisée par Node est celle qui a été évaluée
au lancement du script.
Les *changements sont pris en compte manuellement, à la prochaine exécution*.
C'est-à-dire après avoir stoppé et lancé à nouveau le script.

Le module npm exécutable _nodemon_ ([URL]#https://npmjs.com/nodemon#)
relance automatiquement une commande dès qu'il détecte un changement
dans le répertoire courant.

----
$ nodemon cookies/parse.js
# au lieu de "node cookies/parse.js"
----

La commande précédente relance `cookies/parse.js` si ce fichier change,
si un fichier dans le répertoire `cookies/` change mais aussi si un fichier
dans les répertoires voisins au répertoire `cookies/` change.

L'option `--watch` restreint ou élargit le champ d'observation.
La commande suivante relance le serveur seulement si un fichier JavaScript
est modifié dans le répertoire `cookies/` :

----
$ nodemon --watch cookies cookies/parse.js
----

L'option `--ext` filtre les fichiers observés en fonction de leur type.
La commande suivante relance le serveur si un fichier JavaScript, CSS ou HTML
est modifié dans le répertoire courant :

----
$ nodemon --ext js,css,html cookies/parse.js
----

[NOTE]
.[RemarquePreTitre]#Question# Installation globale, installation locale ?
====
Vous n'êtes pas sûr·e de la meilleure manière d'installer et d'utiliser
le module _nodemon_ ?
Je vous invite à relire la section
<<../chapter-05/index.adoc#install.global,exécutable système>> du chapitre 5
consacré à npm.
====


[[express]]
== Organiser une application avec le _framework_ express

La section précédente a détaillé un ensemble de fonctionnalités individuelles
qui permettent à la fois de mieux comprendre comment fonctionne HTTP mais aussi
comment constituer des briques d'une application web avec Node. +
Les _frameworks applicatifs web_ sont des outils qui proposent de créer une
cohérence dans l'organisation de ces fonctionnalités, de sorte à ce que nos
efforts se concentrent plus sur l'écriture du code et moins sur la création du cadre.

Dans cette section, je vous propose d'appliquer ces connaissances au framework
_express_ ([URL]#https://npmjs.com/express#).
C'est un outil versatile, flexible et bien documenté.
Ça en fait un choix de prédilection pour commencer. +
Vous pouvez vous en tenir à ce framework ou bien évoluer ou compléter son utilisation
avec _fastify_ (plus récent et plus rapide), _restify_ (orienté <<api,API REST>>),
_koa_ (asynchrone et plus rapide) ou encore _hapi_ (plus structuré et plus complexe).

J'ai une préférence pour les outils qui ne font pas trop de choix à notre place,
bien documentés et si possible, qui travaillent autour du
<<../chapter-04/index.adoc#http,module `http`>> — ça conserve une certaine
clarté autour des concepts que nous manipulons.

[[setup]]
=== Configuration du framework

La configuration initiale d'_express_ configure un serveur HTTP — à la manière
de ce que nous pouvions déjà faire avec `http.createServer()` — et retourne
un <<paths,routeur>> pour attacher des comportements à des chemins d'accès.

----
$ node framework/setup.js
----

[source,javascript]
.framework/setup.js
----
include::{sourceDir}/framework/setup.js[]
----
<1> Création de l'application _express_.
<2> Déclaration d'une <<paths,route>> pour la page d'accueil.
<3> La méthode `response.send()` est un raccourci qui automatise qui combine et configure `response.write()`, `response.statusCode` et de `response.end()`.
<4> Branchement du serveur HTTP sur l'interface réseau du système d'exploitation.

C'est vraiment très proche de ce que nous avons déjà appris
à faire dans les sections <<server,démarrer un serveur HTTP>> et
<<paths,répondre à un chemin>>.

[NOTE]
.[RemarquePreTitre]#Documentation# Quelles méthodes et pour quoi faire ?
====
La documentation d'_express_ est le meilleur endroit pour savoir quoi faire
avec les différents objets du module.
Leur lecture vous aidera à mieux suivre cette section car vous comprendrez
d'où sortent les méthodes utilisées.

- *express* : [URL]#https://expressjs.com/4x/api.html#express#
- *application* : [URL]#https://expressjs.com/4x/api.html#app#
- *requête* : [URL]#https://expressjs.com/4x/api.html#req#
- *réponse* : [URL]#https://expressjs.com/4x/api.html#res#
- *routeur* : [URL]#https://expressjs.com/4x/api.html#routeur#
====

[[middleware]]
=== Greffer des extensions (_middlewares_)

Un des premiers éléments différenciant est le *branchement d'extensions*.
Une fois configurées, ces extensions s'appliquent à chaque requête entrante.
Elles offrent la liberté d'ajouter des capacités de compréhension de la requête
(<<post,parser des données de formulaire>> par exemple), de modifier la réponse
ou de <<views,connecter des gabarits de présentation>>.

Chaque couche de transformation est appelée un _middleware_ — une fonction
intermédiaire entre la requête et la réponse.

----
$ node framework/middleware.js
----

[source,javascript]
.framework/middleware.js
----
include::{sourceDir}/framework/middleware.js[]
----
<1> Un _middleware_ se branche avec la méthode `app.use()`.
<2> L'objet `response.locals` passe des données jusqu'à la route — les données sont effacées une fois la réponse envoyée.
<3> La fonction `next()` passe la main au prochain _middleware_.
<4> Nous récupérons l'objet `response.locals.pokemon` créé par notre _middleware_.
<5> Affichage d'un message similaire à `Pokémon aléatoire : Patrat`.

Un _middleware_ n'est pas très différent d'une route : c'est une fonction
qui a accès à la requête et à la réponse HTTP.
Elle n'est pas forcément assignée à une méthode HTTP (`app.get()`, `app.post()`,
etc.) ni à un chemin d'accès.

Dans l'exemple suivant, nous allons connecter plusieurs _middlewares_ grâce
aux modules npm _helmet_ ([URL]#https://npmjs.com/helmet#) et _serve-static_
([URL]#https://npmjs.com/serve-static#).
Ce dernier est une version embarquée de <<static,serve>> par le module _express_.

----
$ node framework/middleware-multi.js
----

[source,javascript]
.framework/middleware-multi.js
----
include::{sourceDir}/framework/middleware-multi.js[]
----
<1> Nous branchons le _middleware_ utilisé dans la section <<static,répondre avec des fichiers statiques>> sur l'URL `{serveUrl}/files`.
<2> Nous branchons les _middlewares_ de <<security,sécurité>> à notre application.
<3> La racine de l'application affiche une image contenue dans un autre répertoire.

Le mécanisme de _middlewares_ est minimaliste et pourtant, il nous permet de
brancher des modules dont leur seul pré-requis est de comprendre les objets
de requête et de réponse HTTP.
*Les _middlewares_ relient tous les concepts* évoqués dans la section
<<webapp,composer son application web>>.

.Extraits des entêtes d'une réponse HTTP une fois le module _helmet_ configuré.
----
$ curl --head http://localhost:4000
HTTP/1.1 200 OK
X-DNS-Prefetch-Control: off
X-Frame-Options: SAMEORIGIN
Strict-Transport-Security: max-age=15552000; includeSubDomains
X-Download-Options: noopen
X-Content-Type-Options: nosniff
X-XSS-Protection: 1; mode=block
Content-Type: text/html; charset=utf-8
Content-Length: 33
ETag: W/"21-tmPtjMCysQ8MzbRDY67vN+isCos"
Date: Sun, 15 Jul 2018 17:12:48 GMT
Connection: keep-alive
----

Le module _helmet_ agit seulement sur les entêtes de réponse.
Nous verrons dans la section <<security,protéger nos applications>> quelles
entêtes sont essentielles à la sécurité et pourquoi.

Enfin, notons une méthode alternative pour appliquer un _middleware_ : au niveau
d'une route, au lieu de toutes les routes — avec `app.use()`.
Pour cela nous allons transformer l'exemple `framework/middleware.js` et
l'appliquer à une seule route :

----
$ node framework/middleware-function.js
----

[source,javascript]
.framework/middleware-function.js
----
include::{sourceDir}/framework/middleware-function.js[]
----
<1> Nous avons factorisé la route dans une fonction afin de la rendre réutilisable.
<2> La route `/` reçoit d'abord le middleware puis la fonction d'affichage.
<3> La route `/rondoudou` reçoit uniquement la fonction d'affichage.

Nous verrons que même si la fonction d'affichage est identique, les routes
`{serverUrl}/` et `{serverUrl}/rondoudou` produisent des résultats différents.
Cette dernière n'ayant pas reçu le _middleware_ `pokéMiddleware`, sa variable
`response.locals.pokemon` n'a pas été définie et elle vaut donc `undefined`.

[[views]]
=== Brancher les gabarits de présentation

La configuration des gabarits de présentation n'est pas très différente
de ce que nous avons vu dans la section
<<templating,structurer l'affichage avec les gabarits de présentation>>.

----
$ node framework/templating.js
----

[source,javascript]
.framework/templating.js
----
include::{sourceDir}/framework/templating.js[]
----
<1> Configuration de _nunjucks_, comme dans la section <<templating,structurer l'affichage avec les gabarits de présentation>>.
<2> Utilisation de la méthode `express()` pour laisser à _nunjucks_ le travail de configuration d'_express_.
<3> Nous appelons la méthode `response.render()` au lieu de `response.send()` — elle charge le template donné et lui passe un objet dont chaque clé devient une variable dans le gabarit.

Nous avons de la chance car _nunjucks_ prend en charge toute la configuration
d'_express_ pour nous.
La seule différence avec les précédents exemples est l'utilisation de la
méthode `response.render()`.
Le premier effet que ça me fait c'est une sensation de légèreté — nous avons
le strict minimum à gérer pour que ça fonctionne.

En comparaison, voilà comment _express_ se configure à la main :

----
$ node framework/templating-manual.js
----

[source,javascript]
.framework/templating-manual.js
----
include::{sourceDir}/framework/templating-manual.js[]
----
<1> On indique à _express_ de contextualiser le répertoire racine où se trouvent les gabarits.
<2> Déclaration de la fonction de rendu pour les fichiers `.njk` — elle est appelée à chaque fois que `response.render()` est appelée avec un fichier `.njk`.
<3> Rendu du fichier passé en paramètre — comme dans la section <<templating,structurer l'affichage avec les gabarits de présentation>>.
<4> Le HTML généré est passé à la fonction de _callback_ `next()` — le premier argument est utilisé pour transmettre une erreur, le second le résultat en cas de succès.

Cette méthode demande davantage de travail.
Elle implique aussi d'être suffisamment familier·ère avec _express_ pour en
venir à créer cette fonction de rendu.

Au final, nous pourrions utiliser différents moteurs de gabarits si le besoin
se faisait ressentir, pour les exploiter à leur(s) avantage(s).
Leur intégration demande un effort minimum et retire tous les aspects de
présentation de la configuration du routeur.

[TIP]
.[RemarquePreTitre]#Pratique# Un module pour les présenter tous
====
Le module npm _consolidate_ ([URL]#https://npmjs.com/consolidate#)
gomme les différences de configuration pour plusieurs dizaines de moteurs
de gabarit.

Il pourra vous être utile si vous peinez à configurer _express_ avec le
moteur de gabarits favori.
====

[[frontend]]
=== Intégrer les ressources front-end (CSS, JavaScript)

mieux vaut les générer statiquement
rebuild à la demande
des fois y'a des outils qui font ça (on perd de vue les erreurs je trouve)


[[database]]
=== Brancher une base de données

Mémoriser les données entre deux redémarrages
Partager les données entre plusieurs instances

on va utiliser sqlite parce que pas de dépendance logicielle
node-sqlite pour les promesses mais on aurait très bien pu utiliser sqlite3

voir plus loin à <<database-choice>>.

[[sessions]]
=== Sessions utilisateurs

[[logs]]
=== Tracer les actions

importants pour retrouver des problèmes
contexte où plein de personnes accèdent à une application, font plein de trucs
(ça dépasse l'échelle de compréhension d'un cerveau)

[[tests]]
== Vers un code réutilisable et testable

le but est d'arriver à un fichier qui assemble les composants : server.js qui assemble la base de données aux routes
des composants les plus indépendants possibles des requêtes/réponses
des données toutes prêtes envoyées au template
fonctions des

=== Modulariser le code des routes

but est de rendre une fonction de render la plus fine possible

- fichier server le plus fin possible
- si ça plante, que ça plante le plus vite possible (avant la première requête) car plus rapide à corriger
- créer des middlewares pour mettre en commun/sortir des choses qui n'ont rien à voir avec l'objet de la route (genre, l'authentification)
- dans les routes, appeler des fonctions testables

=== Un code testable est un code indépendant du framework

la modularisation découple les différents aspects et les rend testable

tester les helpers
tester les middlewares
tester les données entrantes
tester le code qui retourne des données

mocha, chai, bon duo

=== Tester les aspects cruciaux du front-end

supertest pour assurer de bout en bout que la page génère ce qu'il faut
Cf. chapter-09/karma pour tester les interactions (rendering JavaScript compris)

=== Déployer automatiquement

on se rend plus vite compte des erreurs quand on publie souvent,
on peut corriger plus rapidement ce qui bloque l'automatisation
on fait davantage gaffe à ce qu'on fait quand tout le monde peut déployer

Cf. chapter-06

[[advanced]]
== Pour aller plus loin


[[advanced.server]]
=== Pourquoi lancer un serveur ?

Il y a des environnements ou des logiciels comme Apache ou Nginx intègrent
notre langage de programmation avec des modules, par exemple PHP avec le `mod_php`
ou Perl avec le `mod_cgi`.
Les requêtes entrantes sont dirigées vers un script que le module interprète
et retourne une réponse, dynamiquement.

Le *script PHP est interprété à chaque requête* et tout cette représentation
est détruite une fois la réponse envoyée — mémoire, valeurs des variables, configuration.
Il faut recourir à un ensemble de modules additionnels pour optimiser ce gâchis
de ressources informatiques — cache d'interprétation, cache applicatif, cache de configuration.

Démarrer un serveur HTTP dans le langage de notre application nous éloigne de
ce modèle coûteux et nous rapproche d'un fonctionnement plus performant, organisé
autour de ces 3 piliers :

- *Node et Apache/Nginx fonctionnent ensemble* — ils se font le relais des requêtes
et des réponses car ils parlent le même protocole ;
- *le serveur Node est préchauffé* — une requête entrante trouve une application
déjà opérationnelle, déjà configurée, déjà connectée à une base de données
et prête à répondre ;
- *le code exécuté est spécifique à la requête* — l'application reçoit chaque
requête de manière indépendante en ayant le minimum d'effort à faire pour
générer une réponse.

Autrement dit, ce modèle réduit le temps de parcours entre une requête entrante
et une réponse sortante.
Ça a un impact significatif sur le temps d'apparition de l'icône de chargement
côté client.

[[http]]
=== Comprendre le modèle HTTP

Deux éléments ressortent du modèle de fonctionnement du protocole HTTP :
*tout est du texte* (entêtes et contenu) et *chaque requête est indépendante*.
C'est-à-dire que chaque requête emporte son contexte avec elle, toutes les
informations nécessaires à sa compréhension.

Qu'est-ce qu'il se passe lorsque notre navigateur web ou que le programme `curl`
demande à accéder à `http://example.com` ?

. *résolution de DNS* : nous ne savons pas encore à quelle adresse IP parler ;
la résolution de DNS interroge un des annuaires DNS pour savoir quelle adresse
IP est associée au nom de domaine ;
. *établissement de la connexion* : le client (nous) ouvre une connexion réseau
avec le serveur pour échanger des données ;
. *envoi de la requête HTTP* : la requête contient des informations au format
texte (méthode, entêtes, des fois un corps de message) pour que le serveur
s'adapte au mieux à notre demande ;
. *réception de la requête* : le serveur interprète la demande
(est-ce qu'il la comprend ?), cherche la ressource associée au chemin demandé ;
. *envoi de la réponse* : le serveur répond avec des données au format texte
(statut, entêtes, corps de message) ;
. *interprétation de la réponse* : l'entête `Content-Type` aide le client à déterminer
comment afficher les informations - XML, HTML, JSON, CSS, vidéo etc — et si
le document contient d'autres ressources à aller récupérer.

Dans le cas du programme `curl`, la réponse est affichée telle quelle, en texte.

Avec un navigateur web en revanche, le HTML est interprété et le navigateur
demande les ressources listées dans les différentes balises (`img`, `video`, `audio`).
Le navigateur fait ensuite autant de nécessaires — l'indicateur de chargement
s'arrête quand toutes les ressources ont été demandées et téléchargées.

.Cascade de requêtes HTTP suite à l'interprétation d'un document HTML par un navigateur web.
image::images/http-waterfall.png[]

Le nombre de requêtes et la taille des ressources impactent donc la vitesse de
chargement d'une page.
Plus il y en a, plus le client doit en demander et plus le serveur multiplie le
nombre de réponses.
Le temps de téléchargement augmente

[NOTE]
.[RemarquePreTitre]#Technique# Les WebViews sur mobile
====
Les WebViews sont des composants proposés par les systèmes d'exploitation
pour embarquer du contenu HTML dans une application native.

Elles fonctionnent comme des navigateurs web, sans les boutons de navigation.
====

Le module npm _jshttp_ ([URL]#https://github.com/jshttp#) affiche les entêtes
de réponse comme le programme `curl` le ferait et détaille le parcours réseau,
de la résolution du nom de domaine jusqu'au temps passé à négocier une transaction
sécurisée. +
Nous comprenons ainsi mieux des temps qui sont rendus invisibles et où nous
pouvons faire des efforts — réduire les temps de transfert ou le temps de réponse
de notre application par exemple.

.Temporalité de l'exécution d'une requête HTTP et des entêtes de réponse.
image::images/httpstat.png[]


[[database-choice]]
=== Quelle(s) base(s) de données choisir ?

Quand je faisais du PHP, nous parlions beaucoup de la pile technique _LAMP_
— pour Linux, Apache, MySQL et PHP.
C'était la combinaison _de facto_ des différents projets.
MySQL était la base de données de choix tandis que les Pythonistes et Rubyistes
se focalisaient plutôt sur PostgreSQL.

J'ai croisé beaucoup de développeurs et développeuses qui se lançaient dans
les bases de données dite "documents" comme MongoDB "parce que les données
sont stockées en JSON et donc c'est un choix logique pour Node".

Je suis fortement en désaccord avec cette affirmation et je pense que la bonne
base de données est celle qui tient la route par rapport
Node n'est pas meilleur en MongoDB qu'en MySQL.
Le *débit de données* entre Node et la base de données compte davantage, ainsi que
la *rapidité de la base à exécuter une requête* et retourner des résultats
— certaines gèrent mieux que d'autres la concurrence d'accès ou les critères
de filtrage.
Le troisième critère est subjectif : c'est le *confort d'utilisation* de la base
en question.
Postgres est peut-être plus rapide pour un cas d'usage précis mais si vous
êtes plus à l'aise avec MariaDB ou MySQL, commencez avec la base qui vous parle
le plus — ou expérimentez et réservez-vous le droit de changer d'avis après
avoir joué avec un nombre représentatif de données en base.

Je choisis une base de données en fonction de plusieurs critères :
la rapidité de lecture, l'intégrité des données, la volumétrie acceptée avant
de devoir distribuer les données sur plusieurs machines et enfin,
des fonctionnalités spéciales (recherche géographique, type de champ particulier
comme le champ JSON de Postgres).

Stockage fichier::
  Nous pourrions tout à fait décider d'utiliser un fichier JSON ou CSV pour
  lire et écrire des données.
  C'est facile à mettre en œuvre mais c'est la solution la plus lente en tous
  points de vue : la recherche est lente et l'écriture aussi.
Stockage en mémoire::
  _Redis_ et _memcache_ sont des bases de données très rapides en lecture et en écriture
  — elles sont idéales pour accéder et modifier fréquemment des données, avant
  de les persister sur un stockage moins rapide mais plus sûr.
  Elles sont généralement dites "clé/valeur" car nous cherchons un identifiant
  donné pour récupérer un, voire plusieurs champs associés.
Stockage sur disque::
  _MySQL_, _MSSQL_, _Postgres_ et _MongoDB_ stockent leurs données sur disque,
  dans des fichiers optimisés pour la recherche d'informations — les _index_.
  Elles sont souvent rapides en lecture et plus lentes en écriture — selon
  le type de disque dur utilisé pour le stockage.
  Certaines sont contraintes par des schémas (les bases SQL) tandis que d'autres
  ont une structure libre (MongoDB). +
  En pratique, nous typons ou structurons les données d'une manière ou d'une autre
  — à minima pour les manipuler de manière cohérente dans notre code.
  Certaines bases SQL ont un type de champ JSON, en structure libre.
Stockage sur un service en ligne::
  _Firebase_, _DynamoDB_, _Parse_ et _Kinto_ sont des bases de données accessibles
  comme des services, avec des requêtes HTTP.
  Les services d'hébergement gèrent la distribution des données et leur résilience.

J'utilise souvent SQLite pour prototyper quelque chose de rapide sur ma machine.
Je passe ensuite à MySQL ou Postsgres selon le projet — je me sens autonome sur
MySQL pour l'installation tandis que je préfère un service qui gère tout de
bout en bout avec Postgres.

Je peux être amené à indexer les données dans une base de données ElasticSearch
ou Algolia pour leur donner une autre structure, spécialement optimisée pour
la recherche — une lecture très rapide sur des critères variables.
Je le fais si un des aspects principaux du projet est de préserver des performances
élevées, qui ne soient pas ralenties par l'activité d'une base SQL.

Je complète en général avec Redis pour gérer les <<job-queues,files d'attente>>,
des données intermédiaires que je considère comme "jetables".

S'il est plus simple de tout gérer avec un seul support de stockage, utiliser
*plusieurs bases de données* dans une même application est quelque chose de tout
à fait encouragé pour profiter de leurs caractéristiques.

[[security]]
=== Protéger nos applications

https://npmjs.com/helmet
https://npmjs.com/safe-regex pour utiliser une regex sur du contenu fourni par utilisateur
https://npmjs.com/xss
https://npmjs.com/sql-escape-string
https://npmjs.com/dompurify

path traversal (indexOf)
use strict (réduit les possibilités d'exploiter des bizarreries de JS)

[options="header", cols="2, 4a"]
|===
| Entête | Description
| `X-DNS-Prefetch-Control` |
| `X-Frame-Options` |
| `Strict-Transport-Security` |
| `X-Download-Options` |
| `X-Content-Type-Options` |
| `X-XSS-Protection` |
|===

////
L'organisme _Open Web Application Security Project_ (_OWASP_) recueille et diffuse nombre de critères de sécurité à connaître et vérifier pour déjouer au mieux des attaques.
Citons quelques uns de ces critères :

* *dépendences logicielles* ;
* *injection de code arbitraire* ;
* *données d'authentification* (vols, interceptions, brute force etc.) ;
* *contrôles d'accès* (impersonnification etc.) ;
* *optimisme sécuritaire* et *absences de vérifications* ;
* exposition de *données critiques* ;
* attaques *CSRF* (un script tiers actionne des commandes à notre insu) ;
* *uploads de fichiers* (poids limite, formats, chevaux de Troie etc.)
* *redirections* non-contrôlées.

[TIP]
.[RemarquePreTitre]#Ressources# [URL]#owasp.org#
====
Le site d'OWASP offre guides, référentiels, fiches récapitulatives, applications types, outils et tutoriaux pour sensibiliser à la sécurité applicative.

- [URL]#https://www.owasp.org/#
- [URL]#https://nodegoat.herokuapp.com/tutorial#
====
////


////
[[authentication]]
=== Authentifier des utilisateurs

L'authentification utilisateur consiste à vérifier des informations de connexion
auprès d'une source de vérité (base de données, service tiers, lien secret)
et à <<sessions,créer une session>> en déposant un <<cookies,cookie>> côté client.

[TIP]
.[RemarquePreTitre]#Important# Utiliser l'attribut de cookie `HttpOnly`
====
Les cookies ne sont pas modifiables par un script tiers lorsqu'ils sont créés
avec l'attribut `HttpOnly`.
C'est une mesure de protection parmi d'autres.
====

idéalement qui ne puisse pas être forgé (httpOnly)
contenu du cookie se vérifie côté serveur
information associée à une session

ensuite différents moyens d'authentifier (user+password, ou en délégant à un autre service l'identité -- OAuth)

passport, module pour faciliter tout ça sans avoir à tout connaitre
////

[[api]]
=== API REST : l'application web orientée données

pour faire une application orientée données
séparer la présentation de l'accès à la base qui les contient

on construit l'interface par-dessus (une autre appli web, appli front-end)
enjeux sur la robustesse du modèle de données car toutes les applis qui en dépendent
cassent si la manière de les interpréter change

restify/fastify/express font le taf

module express-openapi pour générer le routing à partir de la spec OpenAPI

[[job-queue]]
=== Déléguer le travail aux files d'attente

action qui demande un traitement asynchrone (stocker vidéo, redimensionner, analyser)
au lieu de retenir la réponse pendant le traitement (genre même 1 seconde)
tu prends les données, tu les stockes, ack la demande et rend la main
si ça prend quelques secondes, le temps de charger le reste de la page invisibilise la durée du traitement
sinon c'est

(exemple avec l'upload d'une vidéo sur youtube -- la progression du traitement est indiquée même si la ressource est déjà créée)
cas de figure du statut 202 (au lieu de 201)

[[lambda]]
=== Une application minimaliste avec les Lambda

être allumé quand il y en a besoin
faire un truc et un seul, de temps en temps

créer un truc qui ressemble à une appli avec portail d'API
agréger avec un portail d'API (_API Gateway_), décrit avec schéma OpenAPI
API unifiée avec des services fragmentés, plus proches de leur source de données

https://npmjs.com/micro

[[https]]
=== Et HTTPS dans tout ça ?

utiliser le module https -- pareil que http
j'ai tendance à ce que l'application serve en http et à mettre l'application derrière un serveur Apache ou Nginx configuré pour https
la plupart des hébergeurs sérieux en filent par défaut (ça aide à faire le tri)

[NOTE] mais c'est quoi https ? C'est une organisation qui fait tiers de confiance
tu la paies pour servir de garant sur ton identité que tel certificat c'est tel nom(s) de domaine
tu paies plus ou moins cher pour ajouter d'autres éléments de vérification (physique -- pour avoir le nom de la boîte dans l'URL)
let's encrypt a créé un protocole libre et un service d'attribution de certificats gratuits (financé par des dons+financements), limite la durée à 90 jours pour pousser au renouvellement automatique (preuve suffisante que tu es toi)

si vous avez besoin d'en acheter, il suffit d'indiquer le chemin vers les différentes clés

. générer une clé auto-signé (pour localhost)
. démarrer le serveur

== Conclusion

TBD.

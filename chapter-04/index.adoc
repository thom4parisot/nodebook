:chapterNumber: 4
:chapterId: chapter-04
:sourceDir: ./examples
:sourceSample: script.js
:nodeCurrentVersion: v8
:nodeV: 8.11.1
:npmCurrentVersion: v5
:npmV: 5.8.0
:sectnums:
:revdate: {docdate}
:imagesdir: {indir}
:arrowUp: &#11014;
:arrowDown: &#11015;
:ctrl: ⌃
ifdef::env[]
:imagesdir: .
endif::[]

= Jouer avec Node.js

On peut utiliser Node en parlant directement avec l'interpréteur, en créant un script ou en programmant une application plus complexe.

Ce chapitre explique ce qu'il faut savoir pour interagir avec l'exécutable `node`, le fonctionnement des _modules_ et les variables à disposition.

Nous en profiterons aussi pour passer en revue la variété de modules
disponibles par défaut.

====
.Sommaire
- Interagir avec l'interpréteur Node
- Les modules de base
- Créer ses propres modules
- S'en sortir quand ça ne se passe pas comme prévu
- Les différences de JavaScript entre Node et les navigateurs web
- Options utiles pour démarrer Node
====

[abstract]
--
Le <<../chapter-03/index.adoc#,chapitre 3>> a été l'occasion de pratiquer une
(re)mise en forme côté JavaScript, ECMAScript et tout ça.
On peut désormais mettre à profit nos connaissances pour parler directement
à l'interpréteur Node.
C'est l'occasion de se surprendre à pouvoir faire davantage de choses qu'on
imaginait.
--

include::../resources/tip-versions.adoc[]
include::../resources/tip-examples.adoc[]


== Interagir avec l'interpréteur Node

L'*interpréteur Node* est le programme qui nous permet d'obtenir des résultats
en échange d'instructions ECMAScript.
Le *terminal* est un autre programme qui nous permet de dialoguer avec
un ordinateur et les programmes installés.

Le <<../chapter-02/index.adoc#,chapitre 2>> détaille comment installer
_Node_ et un _terminal_ sur son ordinateur.
Il contient également des conseils pour utiliser Node depuis un
navigateur web.
Cela peut rendre l'accès au terminal plus facile.

La suite de ce chapitre se base sur le principe que vous avez un terminal
sous le nez, prêt·e à saisir des instructions ECMAScript.

.Exemple de _terminal_ sous macOS.
image::images/terminal.png[width="85%"]

[[node-version]]
=== Afficher la version

Nous pourrions commencer par afficher la version de l'interpréteur Node.
Nous nous assurons ainsi que nous pouvons interagir avec
l'interpréteur Node avec succès _et_ que l'interpréteur
est celui que nous attendons, dans la bonne version.
La version de Node conditionne la liste des fonctionnalités du langage
ECMAScript à disposition.

[TIP]
.[RemarquePreTitre]#Compatibilité# Syntaxe ECMAScript
====
Le site web [URL]#https://node.green# liste le niveau de compatibilité
des fonctionnalités ECMAScript.

Cette page vous aidera à comprendre quelles fonctionnalités utiliser en toute
sécurité, version par version de Node.
====

Une fois votre terminal ouvert, saisissez la commande suivante :

[source,bash]
----
$ node --version
----

Le numéro de version de l'interpréteur Node s'affiche alors.
Par exemple : `v{nodeV}`.

Si c'est ce à quoi vous vous attendiez, nous pouvons passer à la suite.
À l'inverse, si une erreur se produit ou que le numéro de version
n'est pas celui que vous attendiez, jetez un œil à la
<<../chapter-02/index.adoc#install,section _Installer Node.js_>> du chapitre 2.


[[script]]
=== Avec un script

L'exécution d'un script Node est très certainement la pratique la plus courante.

L'interpréteur Node lit le contenu d'un fichier et exécute les instructions.
L'interpréteur reste actif jusqu'à ce que toutes les instructions
soient traitées.

[source%interactive,javascript]
.script.js
----
include::{sourceDir}/script.js[]
----

Dans cet exemple, le fichier `script.js` contient _deux instructions_.
Node les interprète lorsqu'on lui passe le chemin du fichier en paramètre
dans une invite de commande :

[source,bash]
----
$ node script.js
4
ABC
----

Node interprète le contenu du fichier `script.js`.
Il nous rend ensuite la main pour exécuter d'autres commandes.

On apprendra à passer des <<process.argv,arguments d'exécution>>
dans la section <<process,module `process`>>.

[TIP]
.[RemarquePreTitre]#Performances# Ressources machine
====
Démarrer un processus Node a un coût incompressible en ressources machine :
environ *30Mo de RAM* et *environ 40 millisecondes de CPU* avant d'exécuter nos
instructions.
====

[[repl]]
=== Avec l'invite de commande interactive (_REPL_)

L'invite de commande interactive est une manière de parler
à l'interpréteur Node sans écrire de fichier.

J'utilise l'invite de commande pour tester des idées et des éléments de syntaxe
quand je ne m'en rappelle plus.

Le mode interactif s'active en exécutant Node sans aucun autre argument :

[source,bash,subs="attributes"]
----
$ node
> {empty}
----

On notera au passage que l'invite est préfixée par le caractère `>`
afin de marquer notre présence dans un environnement différent.
On retrouve un comportement similaire dans les invites de commande
des langages Ruby (`irb`), Python (`python`) et PHP (`php -a`)

Lorsque nous sommes dans l'interpréteur interactif,
toutes les expressions sont interprétées par Node :

[source,bash,subs="attributes"]
----
$ node
> 2 + 2
4
> "abc".toLocaleUpperCase()
'ABC'
> {empty}
----

Des expressions sont réservées pour obtenir de l'aide, sortir de l'interpréteur
ou simplement pour nettoyer ce que l'on voit à l'écran.
Pour cela on fait appel à l'instruction `.help` :

[source,bash]
----
$ node
> .help
.break    Sometimes you get stuck, this gets you out
.clear    Alias for .break
.editor   Enter editor mode
.exit     Exit the repl
.help     Print this help message
.load     Load JS from a file into the REPL session
.save     Save all evaluated commands in this REPL session to a file
----

Ces touches ou combinaisons de touches sont utiles pour naviguer dans
l'invite de commande :

- la combinaison de touches kbd:[Ctrl+C] annule
la saisie de la ligne en cours — c'est kbd:[{ctrl}+C] sous macOS ;
- les touches _flèche haut_ (kbd:[{arrowUp}]) et _flèche bas_
(kbd:[{arrowDown}]) aident à naviguer dans l'historique des commandes ;
- la touche _tabulation_ (kbd:[TAB]) tente de compléter la saisie avec une
expression ou variable connue.

La touche kbd:[TAB] complètera automatiquement la saisie,
offrira une liste de choix de complétion :

[source,bash,subs="attributes,macros"]
----
$ node
> conso{empty}kbd:[TAB]
> console
> console.{empty}kbd:[TAB]
...
console.assert                console.clear                 console.count
...
----

On notera que l'utilisation de kbd:[TAB] après un caractère _point_ (`.`)
listera l'intégralité des propriétés de cet objet.

[TIP]
.[RemarquePreTitre]#Raccourci# Afficher tous les variables connues
====
L'utilisation de la touche kbd:[TAB] affichera _toutes_ les variables connues
de la session interactive en cours.
Il suffit d'appuyer une ou deux fois sur la touche kbd:[TAB]
dans une invite vide :

[source,bash,subs="macros"]
----
$ node
> kbd:[TAB]kbd:[TAB]
Array                         Boolean                       Date
Error                         EvalError                     Function
Infinity                      JSON                          Math
NaN                           Number                        Object
...
----

C'est un excellent moyen de *découvrir des éléments du langage* qui nous
étaient inconnus jusque-là.
====

La sortie de l'invite de commande se fait à l'aide de
l'utilisation répétée de la combinaison de touches kbd:[Ctrl+C]
(ou kbd:[{ctrl}+C] sous macOS).
On revient ainsi à l'état initial où l'on était avant de
saisir la commande `node` :

[source,bash,subs="attributes"]
----
$ node
> {empty}
(To exit, press ^C again or type .exit)
> {empty}
$ {empty}
----

Ce même résultat s'obtient en saisissant `.exit`
ou en utilisant la combinaison de touches kbd:[Ctrl+D] (ou kbd:[{ctrl}+D] sous macOS).

[TIP]
.[RemarquePreTitre]#Raccourci# Variable magique `_`
====
La variable `\_` est spécifique à l'invite de commande Node.
Elle contient systématiquement le _résultat retourné_ par
la dernière évaluation de code :

[source,bash]
----
$ node
> 2 + 2
4
> _ + 2
6
----

Cette variable magique est équivalente à la variable `$_` dans la console
des outils de développement des navigateurs web.
====

[[modules-builtin]]
== Les modules de base

Les modules de base *étendent le champ d'action de Node*.
Ils servent d'interface pour communiquer avec le système d'exploitation,
le système de fichier, des ressources HTTP et des connexions réseau, entre autres. +
Ces modules sont inclus avec chaque installation de Node.
On peut donc en bénéficier sans effort supplémentaire.

Le chargement d'un module de base s'effectue en passant son identifiant
à la fonction `require()`.
Cette fonction retourne alors un objet avec un certain nombre de _propriétés_ et
de _fonctions_.

Ainsi, on chargera le <<fs,module `fs`>> (pour _file system_ — _système de fichiers_)
afin d'interagir avec les fichiers et les répertoires présents sur l'ordinateur :

[source%interactive,javascript]
.fs/read-dir.js
----
include::{sourceDir}/fs/read-dir.js[]
----
<1> On assigne les fonctions et attributs du module `fs` dans la variable `fs`
(on pourrait l'appeler autrement si on en avait envie)
<2> L'appel à la fonction `fs.readdir` passe un objet d'erreur
ainsi que la liste des fichiers et répertoires
contenus dans le chemin indiqué
<3> Affiche un tableau contenant les noms de fichiers et de répertoires présents
dans le dossier courant

Ces modules de base représentent la pierre angulaire de nos applications Node.
Ils fournissent le nécessaire pour… tout faire !
On apprendra à étendre encore plus le champ des possibles dans
le <<../chapter-05/index.adoc#,chapitre 5>>
grâce aux <<../chapter-05/index.adoc#modules,modules npm>>.

Les modules de base changent au fil du temps :
les nouvelles versions de Node ajoutent, corrigent et complètent les modules et
fonctions existantes.
La documentation officielle de Node reflète ces changements et
affiche un indice de stabilité pour savoir à quoi s'en tenir.

.Documentation du module `fs` et son indice de stabilité.
image::images/api-fs.png[width="85%"]

Exceptionnellement, un module de base (ou une de ses fonctions) peut être supprimé.
L'équipe de Node annonce ces changements en *dépréciant* le module en question :
le code reste en place et sera supprimé dans une version ultérieure.
En général, c'est une question de mois voire d'années. +
On verra plus loin comment <<deprecation,afficher les alertes de dépréciation>>.

.Documentation de la fonction `fs.exists`, affichée comme dépréciée depuis Node v1.
image::images/api-deprecation-fs-exists.png[width="85%"]

[NOTE]
.[RemarquePreTitre]#Documentation# Lecture des indices de stabilité
====
Node communique un indice de stabilité pour les modules de base.
Cette échelle se décompose en trois niveaux :

[horizontal]
*déprécié*::
  Le module sera supprimé dans une prochaine version majeure.
  À l'avenir, il vaut mieux ne pas se compter dessus.
*expérimental*::
  Le module est en cours de développement.
  Une fonctionnalité expérimentale peut changer radicalement entre deux
  versions de Node.
*stable*::
  On peut faire confiance à ce module.
  Des choses peuvent changer exceptionnellement mais l'intention est d'offrir
  une stabilité.

L'indice est parfois appliqué à des fonctions dont les attentes
changeraient d'une version à l'autre de Node.
====

Les sections suivantes illustrent des usages courants des modules de base
pour mieux comprendre quoi en attendre et comment les utiliser.

[[console]]
=== `console` : déboguer rapidement des variables

L'objet `console` est une boîte à outils pour afficher
ce qu'il se passe à un moment donné dans un de nos scripts.

[source%interactive,javascript]
.console/log.js
----
include::{sourceDir}/console/log.js[]
----

La fonction écrit les messages et la valeur des variables dans la
<<process.std,sortie standard>> du terminal :

[source,bash]
----
$ node console/log.js
Valeur de count : 3
----

[TIP]
.[RemarquePreTitre]#Raccourci# Variable globale `console`
====
Node charge automatiquement le module pour nous et
le rend utilisable à tout moment à travers la variable globale `console`.

Nul besoin de charger le module manuellement avec `require('console')`.
====

`console.log` sait interpoler les valeurs passées en argument avec le marqueur `%s`.
C'est utile pour structurer un message complexe en gardant les variables à part :

[source,javascript]
.console/interpolate.js
----
include::{sourceDir}/console/interpolate.js[]
----
<1> Affiche `Soupe lentilles et carottes`

`%s` ne sait afficher que des chaînes de caractères.
D'autres marqueurs savent afficher d'autres types de données :

[horizontal]
`%d`::
  Affiche la valeur en tant que <<../chapter-03/index.adoc#number,nombre>>.
`%j`::
  Affiche la valeur en tant que <<../chapter-03/index.adoc#json,structure JSON>>.
`%O`::
  Affiche l'objet avec une profondeur maximum de 4 éléments.
`%o`::
  Idem que `%O` mais sur une profondeur maximum de 2 éléments.

[horizontal]
.Propriétés notables
`console.log()`::
  Affichage de messages et de variables dans le terminal.
`console.error()`::
  Comportement identique à `console.log()` mais à réserver aux erreurs.
  La fonction écrit dans la <<process.std,sortie erreur>>.
`console.dir()`::
  Affichage dédié aux objets et tableaux.
  On peut paramétrer la profondeur d'affichage
  (par défaut, jusqu'à 2 niveaux).
`console.group()`::
  Regroupe des utilisations successives de `console.log` ou de `console.error`
  pour identifier visuellement leur appartenance logique. +
  Un groupe se clôt avec `console.groupEnd()`.
`console.time()`::
  Démarre un chronomètre en lui attribuant un nom. +
  Le chronomètre s'arrête et sa durée s'affiche avec `console.timeEnd()`.
classe `Console`::
  Crée un objet similaire à `console` mais en dirigeant l'affichage ailleurs
  que vers les <<process.std,flux standards>>.
  Pratique pour créer

[TIP]
.[RemarquePreTitre]#Web# Console et navigateurs web
====
L'objet `console` est originaire du monde des navigateurs web.
C'est un onglet de la boîte à outils de développement.
On peut y lire des messages placés dans le code JavaScript de la page web.
On l'utilise aussi pour inspecter et interagir la page avec du code.

.Console web dans le navigateur web Firefox.
image::images/web-console.png[]

====

[NOTE]
.[RemarquePreTitre]#Documentation# `console`
====
La documentation du module `console` est disponible sur le site officiel de Node :
[URL]#https://nodejs.org/docs/latest-{nodeCurrentVersion}.x/api/console.html#
====

[[path]]
=== `path` : manipuler des chemins de fichier

Le module `path` offre un ensemble de fonctions et de propriétés pour
manipuler et construire des chemins vers des fichiers et répertoires.

Ces opérations permettent à notre code de fonctionner de manière identique
sur des systèmes d'exploitation exprimant les chemins de manière différente —
comme Linux et Windows par exemple.

[source%interactive,javascript]
.path/intro.js
----
include::{sourceDir}/path/intro.js[]
----
<1> Affiche `/tmp`
<2> Affiche `package.json`
<3> Affiche `.json`

Certaines fonctions comme `path.join` tiennent compte de la nature du système
d'exploitation.
Le résultat d'un même appel de fonction sera différent _mais_ correspondra
à la même intention :

[source%interactive,javascript]
.path/platform.js
----
include::{sourceDir}/path/platform.js[]
----
<1> Affiche `/` — `\` sous Windows
<2> Affiche `tmp/package.json` — `tmp\package.json` sous Windows

On constate que `path.join` assemble les chemins en utilisant la valeur de
`path.sep`.
Ce qui est bien pour nous, c'est qu'on n'a pas besoin d'y penser :
*Node se charge de la compatibilité* avec le système d'exploitation.

La différence de résultats se précise un peu plus lorsque l'on tente de calculer
des chemins complets, _relatifs à notre emplacement_ actuel :

[source%interactive,javascript]
.path/relative.js
----
include::{sourceDir}/path/relative.js[]
----
<1> Affiche `../source` — `..\source` sous Windows —
c'est le chemin à parcourir pour aller du premier chemin au second chemin
<2> Affiche `/tmp/source` — `C:\tmp\source` sous Windows —
on constate que le chemin _résolu_ est absolu, et intègre la lettre du lecteur
sous Windows

Les résultats produits par les fonctions du module `path`
se combinent particulièrement bien avec celles <<fs,du module `fs`>>, pour
accéder aux fichiers en question.

[horizontal]
.Propriétés notables
`path.basename()`::
  Retourne le nom de fichier.
`path.dirname()`::
  Retourne le nom de répertoire.
`path.extname()`::
  Retourne l'extension d'un fichier.
`path.isAbsolute()`::
  Indique si le chemin est _absolu_ ou non.
`path.join()`::
  Assemble des bouts de chemin.
`path.parse()`::
  Retourne des informations liées à la compréhension d'un chemin
  (extension, nom de fichier, nom de répertoire).
`path.relative()`::
  Indique si le chemin est _relatif_ ou non.
`path.resolve()`::
  Calcule un chemin absolu à partir de plusieurs bouts de chemin.
attribut `path.sep`::
  Retourne le caractère servant de séparateur de répertoires
  pour le système d'exploitation sur lequel est exécuté le script.
  Par exemple `/` pour Linux et macOS ; `\` pour Windows.

[TIP]
.[RemarquePreTitre]#Compatibilité# Manipuler des chemins Windows sous Linux et vice-versa
====
On pourrait avoir besoin de manipuler des chemins _pour_ Windows alors qu'on est
sur un autre système d'exploitation.
Le module `path` expose `path.win32` pour cette raison-là. +
*Les propriétés retournées sont les mêmes* que celles décrites précédemment…
mais retournent systématiquement des chemins Windows.

[source%interactive,javascript]
.path/win32.js
----
include::{sourceDir}/path/win32.js[]
----
<1> On déstructure les fonctions depuis la variante `win32` du module `path`
<2> Affiche `tmp\package.json`
<3> Affiche `C:\etc`

L'inverse est possible en utilisant les propriétés de l'objet `path.posix`.

====

[NOTE]
.[RemarquePreTitre]#Documentation# `path`
====
La documentation du module `path` est disponible sur le site officiel de Node :
[URL]#https://nodejs.org/docs/latest-{nodeCurrentVersion}.x/api/path.html#
====

[[url]]
=== `url` : manipuler des URL

Le module `url` offre des outils pour interpréter des URL, les transformer
et les assembler à nouveau sous forme de chaîne de caractères.

[source%interactive,javascript]
.url/intro.js
----
include::{sourceDir}/url/intro.js[]
----
<1> Affiche `oncletom.io`
<2> Affiche `/node.js/`

[TIP]
.[RemarquePreTitre]#Web# Compatibilité avec les navigateurs
====
Le fonctionnement de la classe `URL` dans Node est la même que dans les
navigateurs web modernes.

Ces deux mondes suivent le standard [URL]#https://url.spec.whatwg.org#
afin de partager les mêmes concepts et définitions de ce qu'est une URL.
====

Les propriétés de l'objet retourné par le constructeur de `URL` sont modifiables.
Il est ainsi possible de modifier les parties de l'URL qui nous intéressent
et de récupérer une URL exploitable sous forme de chaîne de caractères :

[source%interactive,javascript]
.url/to-string.js
----
include::{sourceDir}/url/to-string.js[]
----
<1> Affiche `https://oncletom.io/#top` — le chemin et le fragment ont été modifiées
<2> Idem

Si la fonction `format()` semble avoir le même comportement que `toString`,
on peut en réalité lui passer des options pour conserver ou ôter des
éléments contextuels d'une URL :

[source%interactive,javascript]
.url/format.js
----
include::{sourceDir}/url/format.js[]
----
<1> Affiche `https://oncletom.io/`

Le constructeur `URL` accepte une URL de référence en second argument.
Cette adresse aide résoudre un chemin absolu à partir du premier argument :

[source%interactive,javascript]
.url/resolve.js
----
include::{sourceDir}/url/resolve.js[]
----
<1> Affiche `https://oncletom.io/node.js/`
<2> Affiche `https://oncletom.io/`

[horizontal]
.Propriétés notables
`url.parse()`::
  Transforme une chaîne de caractères en un objet utilisable avec la fonction
  <<http.request,`http.request()`>>.
classe `URL`::
  Représentation de la structure d'une URL.
  Voir ci-après.
classe `URLSearchParams`::
  Représentation des paramètres d'URL.
  Voir ci-après.

[horizontal]
.Propriétés notables de la classe `URL`
`url.format()`::
Transforme un objet `URL` en chaîne de caractères grâce à des contrôles fins.
`url.toString()`::
Transforme l'objet `URL` en chaîne de caractères.
attribut `url.hash`::
  Fragment de l'URL.
attribut `url.hostname`::
  Nom de l'hôte.
attribut `url.pathname`::
  Chemin d'accès à la ressource.
attribut `url.protocol`::
  Protocole spécifié.
attribut `url.search`::
  Paramètres de l'URL, caractère `?` inclus.
attribut `url.searchParams`::
  Objet permettant de manipuler les paramètres.
  Voir ci-après.

Manipuler une URL est plus aisé lorsqu'elle est structurée sous forme d'objet.
Les paramètres ne sont pas en reste avec l'attribut `searchParams` :

[source%interactive,javascript]
.url/search-params.js
----
include::{sourceDir}/url/search-params.js[]
----
<1> Affiche `https://oncletom.io/?search=node.js`
— représentation de l'URL complète
<2> Affiche `search=node.js` — représentation des paramètres seulement
<3> Affiche `https://oncletom.io/`
— le paramètre `search` et sa valeur ont été supprimés de l'URL

[horizontal]
.Propriétés notables de la classe `URLSearchParams`
`searchParams.append()`::
  Ajoute un paramètre à la suite de l'URL.
  Cette fonction permet d'ajouter plusieurs fois une même clé, peu importe sa valeur.
`searchParams.delete()`::
  Supprime un paramètre d'URL.
`searchParams.get()`::
  Retoure la valeur d'un paramètre donné.
`searchParams.getAll()`::
  Retourne toutes les valeurs d'un paramètre donné.
`searchParams.has()`::
  Retourne `true` si les paramètres contiennent une clé donnée.
`searchParams.set()`::
  Assigne une valeur à un paramètre d'URL.
`searchParams.toString()`::
  Retourne une représentation de l'objet sous forme d'une chaîne
  de caractères exploitable dans une URL.

[NOTE]
.[RemarquePreTitre]#Documentation# `url`
====
La documentation du module `url` est disponible sur le site officiel de Node :
[URL]#https://nodejs.org/docs/latest-{nodeCurrentVersion}.x/api/url.html#
====

[[fs]]
=== `fs` : manipuler le système de fichiers

Le module `fs` est un incontournable.
On y a recours dès que l'on a besoin de lire ou d'écrire dans un fichier.
On s'en sert également pour créer, déplacer ou supprimer des fichiers
et des répertoires.

[source%interactive,javascript]
.fs/intro.js
----
include::{sourceDir}/fs/intro.js[]
----
<1> Lorsque la lecture du fichier aboutit, la <<callbacks,fonction de callback>>
est appelée avec 2 paramètres : un objet d'erreur et le contenu
<2> Affiche… le contenu de ce fichier d'exemple !

[TIP]
.[RemarquePreTitre]#Raccourci# Variables `+__filename+` et `+__dirname+`
====
`+__filename+` est une chaîne de caractères faisant référence au fichier courant. +
`+__dirname+` fait référence au répertoire du fichier courant.

[source,javascript]
.dirname-filename.js
----
include::{sourceDir}/dirname-filename.js[]
----
<1> Affiche `/.../chapter-04/examples/dirname-filename.js`
<2> Affiche `true` (ça ne serait pas un _raccourci_ sinon ;-))
<3> Affiche `/.../chapter-04/examples`

Ces variables sont utiles pour opérer sur
des _chemins relatifs au fichier courant_.

====

Dans l'exemple précédent, nous avons utilisé la variable `+__filename+`.
Elle retourne un *chemin absolu* vers le répertoire.
Qu'en est-il lorsqu'on utilise un *chemin relatif* ?

Pour en avoir le cœur net, listons les fichiers et dossiers
du _répertoire courant_ (`.`) :

[source%interactive,javascript]
.fs/ls.js
----
include::{sourceDir}/fs/ls.js[]
----

En l'exécutant, on obtient ces résultats :

[source,bash]
----
$ node fs/ls.js
[ '.eslintrc.yaml',
  'console',
  'debug.txt',
  'deprecation-warning.js',
  'process/env.js',
  ...
  'util' ]
----

On pourrait penser que le _répertoire courant_ (`.`) et `+__dirname+`
(répertoire du _module courant_) sont équivalents.
Et si on se change de répertoire pour voir ?

[source,bash]
----
$ cd ../..
$ node chapter-04/examples/fs/ls.js
[ '.eslintignore',
  'JOURNAL.md',
  'README.md',
  'chapter-01'
  'chapter-02'
  ...
  'tests' ]
----

Bref, les _chemins relatifs_ sont
*relatifs à l'emplacement depuis lequel on exécute la commande `node`*.
La valeur de `+__dirname+` et de `+__filename+` est déterminée par rapport
à l'emplacement du <<module,module>> y faisant appel.

Puisque les opérations liées au système de fichier ne sont pas immédiates
alors la majorité des fonctions de ce module est *asynchrone*.
Leur rapidité d'exécution varie en fonction du support de stockage utilisé
(à disque, à mémoire), de son âge et de la capacité de traitement du CPU
de l'ordinateur.

Cela veut aussi dire que les erreurs sont obtenues de manière asynchrone :

[source%interactive,javascript]
.fs/rmdir.js
----
include::{sourceDir}/fs/rmdir.js[]
----
<1> Indique que la suppression n'a pas abouti car le répertoire en question
n'est pas vide — et pour cause, c'est celui qui contient notre fichier d'exemple

On peut bien entendu articuler plusieurs opérations entre elles.
Et utiliser le <<path,module `path`>> pour construire des chemins robustes
qui fonctionnent avec tous les systèmes d'exploitation, sans effort.

L'exemple suivant crée un répertoire dans un <<os,dossier temporaire>>,
effectue une copie de fichier sous un autre nom et liste le contenu du répertoire
une fois la copie effectuée :

[source%interactive,javascript]
.fs/copy-tmp.js
----
include::{sourceDir}/fs/copy-tmp.js[]
----
<1> On assemble un chemin composé à partir du <<os,répertoire temporaire>> fourni
par le système d'exploitation
<2> Crée le répertoire en question
<3> Copie le contenu de ce script d'exemple vers le répertoire en question
en lui attribuant un nouveau nom

[WARNING]
.[RemarquePreTitre]#Sécurité# Utilisateur et permissions
====
Le script Node exécuté a le droit d'accéder, d'altérer et de supprimer
au même titre que l'utilisateur système qui lance le script.

Ce n'est pas grave si on exécute du code écrit soi-même.
Il faut être vigilant·e et pouvoir faire confiance si le code exécuté provient
de quelqu'un·e d'autre.
====

Si l'exemple précédent semble agréable à lire, il révèle *deux points de vigilance*.

J'ai écrit le code de manière _optimiste_, pour des questions de lisibilité.
Pourtant à chaque opération, il y a une *possibilité d'erreur* à gérer :
de la création du répertoire jusqu'à la lecture des fichiers de ce répertoire. +
Il faudrait vérifier l'argument `error` à chaque fois et décider quoi faire
en fonction de la <<errors,nature du problème>>.

Je vous invite à modifier le code de l'exemple précédent.
Tentez d'afficher les erreurs avec à l'aide des
<<console,fonctions du module `console`>>.
Vous vous apercevrez qu'il y en a justement une, d'erreur.
Qui n'apparait peut-être qu'à partir du moment où on appelle le script
une deuxième fois.

L'imbrication des <<callbacks,fonctions de callback>> fait qu'il est
*difficile d'interrompre une suite de _callbacks_*.
Une bonne piste serait d'appliquer l'<<util,utilitaire `promisify`>>
sur les fonctions du module `fs` créer une
<<../chapter-03/index.adoc#promise,chaine de promesses>>. +
Nous apprendrons à faire ça dans la section du <<util,module `util`>>.


[horizontal]
.Propriétés notables
`fs.appendFile()`::
  Ajoute un contenu à la suite d'un fichier existant.
  Le fichier sera créé le cas échéant.
`fs.copyFile()`::
  Copie un fichier depuis un emplacement vers un autre.
`fs.mkdir()`::
  Crée un nouveau répertoire.
  Le répertoire parent doit déjà exister.
`fs.readdir()`::
  Obtient la liste des fichiers et dossiers contenus dans un répertoire donné.
`fs.readFile()`::
  Lit le contenu d'un fichier.
`fs.rename()`::
  Renomme un fichier — et le déplace vers un nouvel emplacement si nécessaire.
`fs.rmdir()`::
  Supprime un répertoire.
  Le répertoire doit être _vide_ pour que l'opération puisse réussir.
`fs.stat()`::
  Obtient des réponses à des questions à propos d'un chemin d'accès :
  est-ce que c'est un fichier, un répertoire, un lecteur, un lien symbolique etc.
  Des attributs clarifient la taille du fichier (en octets), l'identifiant
  système de son propriétaire, la date de création/modification/dernier accès etc.
`fs.symlink()`::
  Crée un lien symbolique d'un chemin donné vers un emplacement.
`fs.truncate()`::
  Raccourcit le contenu d'un fichier à une longueur donnée (en nombre d'octets).
  Si aucun argument n'est donné, le contenu du fichier est remis à zéro.
`fs.createReadStream()`::
  Crée un <<stream,flux de lecture>>, pour lire un fichier en continu.
`fs.createWriteStream()`::
  Crée un <<stream,flux d'écriture>>, pour écrire en continu dans un fichier.

[NOTE]
.[RemarquePreTitre]#Documentation# `fs`
====
La documentation du module `fs` est disponible sur le site officiel de Node :
[URL]#https://nodejs.org/docs/latest-{nodeCurrentVersion}.x/api/fs.html#
====

[[events]]
=== `events` : programmer des événements

Le module `events` contient le nécessaire pour créer du code communiquant
à l'aide de fonctions d'écoute et d'émission de messages.
C'est comme un _centre de tri postal_… mais pour Node avec des variables
en guise de courriers.

[source%interactive,javascript]
.events/intro.js
----
include::{sourceDir}/events/intro.js[]
----
<1> Création d'un gestionnaire d'événements
<2> Enregistrement d'une fonction d'écoute
— elle sera exécutée à chaque émission de l'événement `date`
<3> Émission d'un événement `date` avec comme argument, un
<<../chapter-03/index.adoc#date,objet `Date`>>

Un événement se décompose en 3 parties : les *fonctions d'écoute*,
les *émissions de message* et un *objet `EventEmitter`*
qui fait le lien entre les deux.

[NOTE]
.[RemarquePreTitre]#Langage# ECMAScript n'est pas événementiel
====
Contrairement à ce que l'on pourrait penser, le langage ECMAScript ne possède
aucune structure de gestion d'événements.

S'il est possible de réagir à des événements dans les navigateurs web,
c'est grâce à la spécification DOM — l'API JavaScript pour manipuler
une structure de document HTML.

Pour en savoir plus : [URL]#https://developer.mozilla.org/fr/docs/Web/Events#.
====

On peut décider d'écouter un événement une seule fois avec `emitter.once()` :

[source%interactive,javascript]
.events/once.js
----
include::{sourceDir}/events/once.js[]
----
<1> Bien que l'événement `date` soit appelé deux fois, la fonction d'écoute
ne réagira qu'une seule fois

La fonction `emitter.remove` débranche une fonction d'écoute selon
les critères de notre choix :

[source%interactive,javascript]
.events/remove.js
----
include::{sourceDir}/events/remove.js[]
----
<1> On émet un événement `date` toutes les secondes,
en incrémentant un compteur à chaque fois
<2> Au bout de 3 incréments, on débranche la fonction d'écoute `log`
de l'événement `date`

On remarquera qu'il faut pouvoir faire référence à la fonction d'écoute
afin de la débrancher.

Une utilisation alternative des événements consiste à étendre la classe `EventEmitter`.
Une fois étendue, notre nouvelle classe bénéficiera des méthodes `.on()` etc.

[source%interactive,javascript]
.events/class.js
----
include::{sourceDir}/events/class.js[]
----
<1> Extension de la classe `EventEmitter`
<2> L'utilisation de la fonction spéciale `super()` est indispensable ;
elle revient à invoquer `new EventEmitter()` par mécanisme de cascade
<3> La méthode `.start()` encapsule un appel à la méthode `.emit()`
<4> La fonction réagira à l'émission de l'événement `action` ;
quand la méthode `.start()` sera appelée

Ce *mécanisme est utile* pour cacher de la complexité applicative,
pour exécuter une fonction plusieurs fois lors d'un événement donné,
pour exposer une surface d'action compréhensible,
tout en rendant notre code communiquant vers l'extérieur.

Plusieurs modules Node utilisent les événements pour nous permettre d'y
réagir de manière totalement optionnelle.
Tout ce que l'on vient d'expliquer s'applique à l'identique
au <<process,module `process`>>, au <<child_process,module `child_process`>>
ainsi qu'au <<http,module `http`>>.

[horizontal]
.Propriétés notables de la classe `EventEmitter`
`on()`::
  Enregistre une nouvelle fonction réagissant à un événement donné.
`once()`::
  Enregistre une nouvelle fonction réagissant _une seule fois_ à un événement donné.
`emit()`::
  Émet un événement.
  Si un ou plusieurs arguments additonnels sont présents,
  ils sont transmis aux fonctions écoutant cet événement.
`eventNames()`::
  Liste les événements pour lesquels on a enregistré au moins une fonction d'écoute.
`listeners()`::
  Liste les fonctions écoutant les événements.
`removeListener()`::
  Supprime une fonction d'écoute d'un événement donné.
`removeAllListeners()`::
  Supprime toutes les fonctions d'écoute d'un événement donné.
`setMaxListeners()::
  Change le nombre maximum de fonctions d'écoute possibles. +
  Par défaut cette limite est de _10 fonctions maximum_.
  Ça paraît peu.

[NOTE]
.[RemarquePreTitre]#Documentation# `events`
====
La documentation du module `events` est disponible sur le site officiel de Node :
[URL]#https://nodejs.org/docs/latest-{nodeCurrentVersion}.x/api/events.html#
====

[[util]]
=== `util` : transformer des _callbacks_ en promesses

Le module `util` est un petit module contenant des fonctions utilitaires
qui ne rentreraient pas dans le périmètre d'autres modules.

On y trouve `util.format()`, une fonction qui fait beaucoup penser à
<<console,`console.log`>> mais sans afficher le message :

[source%interactive,javascript]
.util/format.js
----
include::{sourceDir}/util/format.js[]
----
<1> Assigne le message formaté dans une variable sans l'afficher

Pour afficher la valeur de la variable `message` de l'exemple précédent,
il suffirait de décommenter la dernière ligne et de (re)lancer le script.

La fonction `util.debuglog()` formate aussi des messages.
Son affichage est toutefois conditionnel.
Ce qui est pratique quand on veut déboguer des variables sans toucher au code
entre deux exécutions :

[source%interactive,javascript]
.util/debuglog.js
----
include::{sourceDir}/util/debuglog.js[]
----
<1> Création d'un débogueur nommé `nodebook`
<2> Ce message s'affiche systématiquement quand on exécute le script
<3> Le modèle de CPU sera affiché en invoquant Node d'une certaine manière

En lançant la commande suivante, seul le message de `console.log` s'affiche :

[source,bash]
----
$ node util/debuglog.js
Cet ordinateur a 4 CPU.
----

Il nous faut alors utiliser la <<process.env,variable d'environnement>> `NODE_DEBUG`.
En lui attribuant la même valeur que notre débogueur, celui-ci affichera alors
le contenu attendu :

[source,bash]
----
$ NODE_DEBUG=nodebook node util/debuglog.js
Cet ordinateur a 4 CPU.
NODEBOOK 32486: Le modèle de CPU est Intel(R) Core(TM) i5-6267U CPU @ 2.90GHz.
----

Si l'on souhaite avoir plusieurs débogueurs, dans un ou plusieurs scripts,
il suffit de séparer leur nom par une virgule.
Par exemple `NODE_DEBUG=nodebook,test,fromage`.

Une de mes fonctions préférées est `util.promisify()`.
Elle convertit une fonction acceptant un <<callback,callback>> en une fonction
retournant une <<../chapter-03/index.adoc#promise,promesse>>.
C'est d'autant plus pratique quand on n'a pas la maitrise du
code source original :

[source%interactive,javascript]
.util/fs-readdir-promisified.js
----
include::{sourceDir}/util/fs-readdir-promisified.js[]
----
<1> Assigne une version transformée de `fs.readdir` grâce à `util.promisify`
<2> On ne passe pas de <<callbacks,callback>> contrairement à `fs.readdir`
<3> Le résultat de l'opération est passé à la résolution de promesse

Ça paraît rien mais ça ouvre un potentiel de simplification énorme pour nous.
Fini l'argument `error` qui nous embête : on peut le collecter quand ça
nous arrange grâce à `.catch()`.

Ça nous évite aussi d'avoir à écrire toutes ces lignes de code
pour arriver au même résultat :

[source%interactive,javascript]
.util/fs-readdir-promise.js
----
include::{sourceDir}/util/fs-readdir-promise.js[]
----

[horizontal]
.Propriétés notables
`util.debuglog()`::
  Crée une fonction de débogage similaire à <<console,`console.error`>>.
  Les messages ne s'afficheront que si la <<process.env,variable d'environnement>>
  `NODE_DEBUG` mentionne l'identifiant du débogueur.
`util.deprecate()`::
  Affiche un message d'avertissement lorsque vous souhaitez retirer une fonction
  partagée dans une version ultérieure de votre code.
`util.format()`::
  Retourne une chaîne de caractères formatée, comme <<console,`console.log`>>
  mais sans l'envoyer dans un <<process.std,flux de sortie>>.
`util.promisify()`::
  Transforme une <<callbacks,fonction de callback>> en
  <<../chapter-03/index.adoc#promise,promesse>>.

[NOTE]
.[RemarquePreTitre]#Documentation# `util`
====
La documentation du module `util` est disponible sur le site officiel de Node :
[URL]#https://nodejs.org/docs/latest-{nodeCurrentVersion}.x/api/util.html#
====

[[http]]
=== `http` : créer et interroger des ressources via le protocole HTTP

Le module `http` est un module incontournable de Node.
Il a _2 facettes_ : la création de *requêtes HTTP* et la création
de *serveurs HTTP*.
Dans un cas on utilise le protocole HTTP pour *accéder à une ressource distante*
et recevoir une _réponse_.
Dans l'autre cas on utilise le protocole HTTP pour
*mettre à disposition des ressources* et les envoyer en _réponse_.

Le module `https` offre exactement les mêmes propriétés.
Il est à privilégier pour établir des connections sécurisées
vers des adresses commençant par `https://`.


[source%interactive,javascript]
.http/intro.js
----
include::{sourceDir}/http/intro.js[]
----
<1> Initialisation de la requête — un objet représentant
la <<http.response,réponse du serveur distant>> nous est transmis.
À ce stade là, le serveur n'a pas encore commencé à renvoyer des données
<2> On en est à l'étape où on reçoit des données.
Le contenu du fichier `package.json` est affiché sous forme
de chaînes de caractères

Ce premier exemple met en lumière *la nature asynchrone et non-bloquante par défaut de Node*.
La création d'une requête et l'obtention de la réponse sont séparées d'un délai
variable pendant lequel Node ne bloque pas le reste du code de s'exécuter.
Les <<callbacks,callbacks>> sont appelés lorqu'il n'y a plus besoin d'attendre.

En regardant le code de l'exemple précédent, on en apprend un peu plus sur
le fonctionnement d'une requête HTTP :

. envoi de la requête au serveur distant (`get()`)
. obtention d'une réponse (objet `response` dans le callback)
. transmission d'informations (événement `data`)
. clôture de la transmission (événement `end` — cf. exemple suivant)

Pour rester rapide, Node fait aussi le choix de transmettre les données
au fur et à mesure.
L'<<events,événement>> `data` renvoie en réalité environ `10Ko` de données.
L'exemple précédent a tout renvoyé d'un coup par chance : le fichier
`package.json` récupéré pèse beaucoup moins de 10Ko.

Voyons maintenant ce qu'il se passe lorsqu'on fait appel à un fichier
plus volumineux :

[source%interactive,javascript]
.http/get.js
----
include::{sourceDir}/http/get.js[]
----
<1> Affiche ce message à chaque morceau/paquet reçu
<2> L'événement `end` se déclenche lorsque la requête n'a plus de données
à recevoir
<3> Affiche le nombre de morceaux reçus pour obtenir une _réponse complète_

[TIP]
.[RemarquePreTitre]#Pratique# Paramètre URL
====
Les fonctions `http.get()` et `http.request()` accepte une chaîne de caractères
comme premier argument.

Il est aussi possible de lui passer un <<url,objet URL>>.
Pratique si vous manipulez des URL complexes ou si vous paginez.
====

En clair, on peut recevoir une réponse en plusieurs fois, petit bout par petit bout.
Les données reçues ne sont pas forcément complètes.
Ça pose problème à des fonctions comme
<<../chapter-03/index.adoc#json,`JSON.parse`>>.
Elle nécessite un document JSON complet pour produire un résultat.

Une solution consiste accumuler les morceaux de réponse et à les assembler.
Cela veut aussi dire que l'on consomme autant de mémoire que l'on reçoit de données.

Une autre solution repose sur l'utilisation des <<stream,flux de données>>.
Ils pompent et brassent les données comme du liquide, en consommant peu de mémoire.
On en parle plus loin, dans la section sur le <<stream,module `streams`>>.

[horizontal]
.Propriétés notables
`http.createServer()`::
  Initialise un serveur HTTP et fournit une boîte à outil pour
  gérer les connexions entrantes via <<http.Server,`http.Server`>>
`http.get()`::
  Crée une connexion HTTP de type `GET`.
  Il s'agit d'une version simplifiée de `http.request()`.
`http.request()`::
  Crée une connexion HTTP du type de son choix (`GET`, `POST`, `OPTION`, `PUT`,
  etc.).

[[http.request]]
La fonction `http.request()` gère une requête plus finement.
On peut aisément régler les entêtes, le verbe HTTP et les modalités de
transmission des données.

L'exemple suivant illustre l'envoi d'une requête `HEAD`.
Ce verbe HTTP indique au serveur distant de répondre avec les métadonnées
de la ressource mais _sans son contenu_ :

[source%interactive,javascript]
.http/request.js
----
include::{sourceDir}/http/request.js[]
----
<1> Destructure l'URL sous forme d'objet en ajoutant le verbe HTTP
<2> Explicite la valeur d'une entête HTTP à transmettre au serveur distant
<3> Déclenche l'envoi de la requête sur le réseau
<4> Réception de la réponse
<5> Affiche la date de modification de la ressource distante
<6> Et… n'affiche pas les données. La réponse n'en renvoie pas suite à
l'utilisation du verbe HTTP `HEAD`. Les données seront transmises si vous
remplacez le verbe `HEAD` par `GET`.

[NOTE]
.[RemarquePreTitre]#Apparté# Pourquoi passer une URL sous forme d'objet ?
====
Ça peut sembler bizarre de passer une URL sous forme d'objet plutôt qu'une
chaîne de caractères.

C'est pourtant logique d'un point de vue du protocole HTTP et de Node :
la connexion s'établit auprès d'un hôte (`hostname`) sur un port précis (`port`).
L'étape d'après consiste à signifier l'intention de la requête en fournissant
un verbe (`method`) et des métadonnées (`headers`) pour un chemin donné (`path`).
====

Ça fait un peu de travail pour bien envoyer une requête, gérer le flot de données
ainsi que les erreurs qui peuvent survenir.
On verra dans le <<../chapter-05/index.adoc#,chapitre 5>> comment arriver au
même résultat avec moins de code grâce aux
<<../chapter-05/index.adoc#modules,modules npm>>.

[horizontal, id="http.ClientRequest"]
.Propriétés notables de `http.ClientRequest`
`request.on('response')`::
  Déclenché lorsque la ressource distante a accepté la requête et s'apprête
  à nous transmettre les données.
`request.on('end')`::
  Délenché lorsque la ressource distante a signalé ne plus avoir de données
  à nous transmettre.
`request.end()`::
  Termine l'initialisation et entame la connexion vers la ressource distante. +
  Dans le cas d'une requête `POST`, `PUT` ou `DELETE`, le premier paramètre
  sert à passer une donnée au serveur distant.
`request.getHeader()`::
  Retourne la valeur d'une entête de requête.
`request.setHeader()`::
  Change la valeur d'une entête de requête.
  C'est une pratique courante pour préciser nos intentions auprès du serveur
  distant : format de fichier à réponse attendu (`Accept`), agent utilisateur
  (`User-Agent`), nature des données envoyées (`Content-Type`), etc.
`request.setTimeout()`::
  Définit un chronomètre pour déclarer la requête en erreur si aucune réponse
  n'a été obtenue dans ce délai imparti.
`request.write()`::
  Transmets un morceau de contenu vers la ressource distante.
  Cette méthode s'utilise lorsque l'on effectue un téléversement progressif.


[horizontal, id="http.IncomingMessage"]
.Propriétés notables de `http.IncomingMessage`
`message.on('data')`::
  Déclenché quand un morceau de données est obtenu par le client.
`message.on('end')`::
  Déclenché quand nous avons obtenu toutes les données émises par le serveur.
`message.on('readable')`::
  Déclenché quand nous pouvons commencer à lire les données.
`message.read()`::
  Obtient un morceau de données manuellement — au lieu d'utiliser
  l'événement `data`, automatique.
  On apprendra mieux comment manipuler cette fonction dans la section
  <<stream,module `streams`>>.
`message.destroy()`::
  Termine la transmission des données sans que le serveur distant
  nous aie tout transmis.
attribut `message.headers`::
  Objet contenant les entêtes de réponse émises par le serveur distant.
attribut `message.statusCode`::
  Code qui reflète l'état de compréhension de notre requête par le serveur distant.
  `200` correspond à _tout va bien_, `404` à _ressource introuvable_,
  `301` à _la ressource a été déplacée_.

Il est temps de nous pencher sur l'autre versant du module : la création
d'un serveur HTTP.

[source%interactive%endpoint,javascript]
.http/server.js
----
include::{sourceDir}/http/server.js[]
----
<1> Ouverture de l'acceptation des connexions réseaux sur le port `8000`,
uniquement sur la boucle locale (`localhost`)
— une erreur sera affichée si ce port réseau est déjà pris par un autre processus
<2> Affiche `Serveur démarré !` quand Node a fini de négocier l'accès aux ressources
réseau avec le système d'exploitation
— à ce stade, le serveur est prêt à recevoir des _connexions entrantes_
<3> Lorsqu'une requête arrive, affiche l'URL demandée par le client
<4> Termine la connexion avec le client
— ce dernier considère sa _requête_ comme terminée

[NOTE]
.[RemarquePreTitre]#Apparté# Pourquoi démarrer un serveur HTTP ?
====
Ce concept peut sembler étrange lorsqu'on vient d'un autre langage de programmation.
Après tout, Apache ou nginx s'en chargent très bien pour nous.

Un serveur HTTP embarqué avec Node, c'est avant tout
*une question d'autonomie et d'interopérabilité*.
Pas besoin de module spécial pour Apache.
Pas besoin de module spécial pour nginx.

On peut développer un site web et le faire fonctionner instantément sans
installer autre chose.
L'intégration avec un serveur Apache, nginx ou autre nécessite ensuite
très peu d'efforts.
====

Le serveur se démarre de la même manière qu'un script ordinaire :

[source,bash]
----
$ node http/server.js
Serveur démarré !
----

Le serveur continuera d'accepter les requêtes entrantes jusqu'à ce que le
<<process,processus>> soit interrompu par une erreur ou par un
<<signals,signal d'arrêt>>
— en utilisant la combinaison de touches kbd:[Ctrl+C] par exemple.

Accédez au serveur HTTP en ouvrant un navigateur web comme Firefox ou Chrome
puis en inscrivant `http://localhost:4000` dans la barre d'adresses.
Dirigez ensuite le navigateur vers `http://localhost:4000/test` et observez les
changements.

[TIP]
.[RemarquePreTitre]#Pratique# Parler au serveur depuis le terminal
====
La commande Unix `curl` sait envoyer des requêtes HTTP.
On peut l'utiliser pour _lire_ les réponses de notre serveur :

[source,bash]
----
$ curl -i http://localhost:4000/test
$ curl -i -XHEAD http://localhost:4000/test
----

L'option `-i` affiche les entêtes de réponse.
C'est l'équivalent de `response.headers`.
====

On a posé les bases d'un serveur HTTP minimaliste sur lequel on va
pouvoir construire pas à pas tout type d'applications web.
Et qu'est-ce qu'il manque pour en faire un serveur web ?
De pouvoir _typer_ les ressources renvoyées afin qu'elles soient comprises
par un navigateur web.
C'est à dire de pouvoir signaler que nos réponses contiennent du HTML, du CSS,
des images etc.

Modifions notre exemple précédent pour renvoyer du HTML :

[source%interactive%endpoint,javascript]
.http/web-server.js
----
include::{sourceDir}/http/web-server.js[]
----

[WARNING]
.[RemarquePreTitre]#Important# La fonction `response.end()`
====
L'appel de la fonction `response.end()` est impératif.
Sans ça, le client — ici, le navigateur web — pense que des données peuvent
encore arriver.

Si on supprime l'appel à `response.end()` dans l'exemple précédent,
l'indicateur de chargement du navigateur sera actif pendant 2 minutes,
suite à quoi Node interrompra la connexion, considérant qu'elle met trop
de temps pour aboutir.
====

Dirigeons notre navigateur web vers `http://localhost:4000` pour observer
le résultat.

.Rendu navigateur de l'exemple `http/web-server.js`.
image::images/web-server.png[width="65%"]

La balise HTML `<h1>` a bien été prise en compte mais qu'en est-il du
caractère `Ã{nbsp}` ? +
L'informatique ayant débutée aux États-Unis, les caractères compris par les
outils informatiques se limitent souvent à 128 caractères par défaut.
C'est à dire l'alphabet anglais, les signes de ponctuations et des
caractères non-imprimables.
On parle alors de standard d'encodage ASCII.

Ce qui nous intéresse, c'est le standard d'encodage Unicode UTF-8.
Ce standard englobe les alphabets du monde entier, dont les accents et
caractères diacritique de la langue française.

Cela revient à dire que que _nous_, côté serveur, nous puissions
indiquer au client que notre contenu est en UTF-8.
Ça tombe bien, HTTP dispose d'une entête pour spécifier le type du contenu
et son encodage : `Content-Type`.

[source,javascript]
.http/web-server-ok.js
----
include::{sourceDir}/http/web-server-ok.js[]
----
<1> L'entête HTTP `Content-Type` indique explicitement que le contenu transféré
est du HTML, encodé en UTF-8

Cette indication suffit au navigateur pour décoder les caractères
et les afficher comme on l'espérait.

.Rendu navigateur de l'exemple `http/web-server-ok.js`.
image::images/web-server-ok.png[width="65%"]

L'étape suivante consisterait à transmettre deux contenus différents selon
l'URL demandée.
Par exemple, une page HTML et un fichier CSS habillant la page HTML.

[source%interactive%endpoint,javascript]
.http/web-server-routes.js
----
include::{sourceDir}/http/web-server-routes.js[]
----
<1> Si la requête entrante indique `/main.css` comme chemin, alors on lui
renvoie du contenu interprétable comme du CSS
<2> On indique au client que ce contenu est du texte contenant une feuille
de style CSS

Si tout se passe bien, le chargement de la page HTML devrait déclencher
une requête vers `http://localhost:4000/main.css`.
La confirmation est visuelle en visitant notre serveur avec un navigateur web :

.Rendu navigateur de l'exemple `http/web-server-routes.js`.
image::images/web-server-routes.png[width="65%"]

On est en situation de contrôle : on décide de ce qu'on répond.
C'est une manière d'apprendre petit à petit comment fonctionne
le protocole HTTP sur lequel repose une majorité de notre activité sur Internet.

On a couvert les principes du module `http` mais il reste beaucoup de choses
à apprendre pour développer une application web maintenable.
C'est justement le sujet du <<../chapter-07/index.adoc,chapitre 7>>,
aidé par les <<../chapter-05/index.adoc#modules,modules npm>> que l'on apprendra
à manipuler dans le <<../chapter-05/index.adoc#,chapitre 5>>.

[horizontal, id="http.Server"]
.Propriétés notables de `http.Server`
`server.close()`::
  Arrête l'écoute de nouvelles connexions.
  Les connexions existantes sont maintenues jusqu'à ce qu'elles soient honorées.
`server.listen()`::
  Démarre l'acceptation des connexions sur un port et une adresse donnée.
  Combinée avec <<os,`os.networkInterfaces()`>>, vous pourriez choisir
  sur quelle carte/adresse réseau écouter les requêtes entrantes.
`server.on('close')`::
  Déclenché lorsque le serveur s'arrête et a terminé d'honoré toutes les
  connexions déjà ouvertes.
`server.on('connection')`::
  Déclenché lorsqu'une nouvelle connexion réseau est établie.
`server.on('request')`::
  Déclenché lorsqu'une nouvelle requête entrante est adressée au serveur.
`server.on('upgrade')`::
  Déclenché lorsqu'une requête entrante demande un changement de protocole.
  Utilisé pour basculer vers HTTP/2 et
  <<../chapter-09/index.adoc#io-websocket,WebSocket>>.

[horizontal, id="http.ServerResponse"]
.Propriétés notables de `http.ServerResponse`
`response.on('close')`::
  Déclenché lorsque la requête a été terminée par le client,
  avant qu'on aie pu transmettre l'intégralité des données.
`response.on('finish')`::
  Déclenché lorsqu'on a envoyé le dernier morceau de données au client
  ayant initié la requête.
`response.end()`::
  Signale au client que nous n'avons plus de données à transmettre.
`response.getHeader()`::
  Retourne la valeur d'une entête de la réponse.
`response.removeHeader()`::
  Supprime une entête de la réponse.
`response.setHeader()`::
  Assigne une valeur à une entête de la réponse.
`response.write()`::
  Transmet un morceau de données au client.
`response.writeHead()`::
  Transmet le code de réponse et un ensemble d'entêtes au client.
attribut `response.statusCode`::
  Contient le code de réponse qui sera transmis au client.

[NOTE]
.[RemarquePreTitre]#Documentation# `http`
====
La documentation du module `http` est disponible sur le site officiel de Node :
[URL]#https://nodejs.org/docs/latest-{nodeCurrentVersion}.x/api/http.html#
====


[[os]]
=== `os` : en savoir plus sur les capacités de l'ordinateur

Le module `os` permet d'en savoir plus sur l'environnement système dans lequel
le script est exécuté.
Ça permet de *prendre des décisions par rapport aux ressources disponibles*
(mémoire, CPU, réseau, etc.).
Idem par rapport au type de système d'exploitation (Windows, Linux, etc.).

[source%interactive,javascript]
.os/intro.js
----
include::{sourceDir}/os/intro.js[]
----
<1> Affiche un message du genre
`L'ordinateur a 4 CPU et une session ouverte par anonymous.`

Node a pour vocation de nous abstraire du système d'exploitation
en faisant en sorte que notre code fonctionne partout pareil.
Pourtant des situations nous obligent à prendre en compte certains critères
pour déterminer un choix.

Par exemple, lister les applications installées sur l'ordinateur.
Leur emplacement d'installation est différent sous Linux, Windows et macOS.

[source%interactive,javascript]
.os/apps.js
----
include::{sourceDir}/os/apps.js[]
----

L'exemple précédent se base sur la valeur retournée par la fonction `os.type()`
afin de choisir quel est le bon répertoire à lister.

On pourrait combiner ce mécanisme avec le <<child_process,module `child_process`>>,
pour appeler une application système différent pour parvenir
à un résultat similaire.

À l'inverse, on peut *accéder à une ressource de manière uniforme*, peu importe
le nom du compteur utilisateur ou du type de système d'exploitation.
Nous allons maintenant lire le contenu du fichier `.npmrc`,
le fichier de configuration du <<../chapter-05/index.adoc#cli,programme npm>> :

[source%interactive,javascript]
.os/npmrc.js
----
include::{sourceDir}/os/npmrc.js[]
----
<1> Construit un chemin agnostique du système d'exploitation. Par exemple
`C:\Users\anonymous\.npmrc` pour Windows, `/Users/anonymous/.npmrc` pour macOS
et `/home/anonymous/.npmrc` pour Linux
<2> `ENOENT` est un <<fs.errors,code d'erreur>> indiquant que le fichier
n'existe pas ; on se permet de l'ignorer et de considérer que le fichier est vide

[horizontal]
.Propriétés notables
`os.arch()`::
  Retourne l'architecture du CPU.
  Les valeurs les plus courantes sont généralement `x64`, `arm` et `arm64`.
`os.cpus()`::
  Retourne un tableau contenant des informations à propos du ou des CPU. +
  Parmi ces informations, on retrouve leur modèle, leur fréquence et
  le temps passé en attente ou en action depuis le démarrage de l'ordinateur.
`os.homedir()`::
  Retourne le chemin vers le répertoire utilisateur. +
  Équivalent à la variable `$HOME` sous Unix et `%USERPROFILE%` ou `%AppData%`
  sous Windows.
`os.hostname()`::
  Retourne l'identifiant réseau de la machine.
`os.networkInterfaces()`::
  Retourne un tableau contenant des informations à propos de la ou des
  cartes réseaux de l'ordinateur. +
  Parmi ces informations, on retrouve l'adresse IP (IPv4, IPv6), l'adresse MAC
  et le masque réseau.
`os.platform()`::
  Retourne la nature du système d'exploitation. +
  Les valeurs les plus courantes sont généralement `win32`, `linux`, `darwin`
  et `freebsd`.
`os.tmpdir()`::
  Retourne l'emplacement du _répertoire temporaire_ fourni par
  le système d'exploitation.
`os.type()`::
  Retourne une forme normalisée de nature de système d'exploitation.
  La valeur est équivalente à ce que retournerait la commande Unix `uname -s`. +
  Les valeurs les plus courantes sont généralement
  `Windows_NT`, `Linux`, `Darwin` et `FreeBSD`.
attribut `os.constants`::
  Objet contenant la liste des <<signals,signaux système>> et des codes d'erreur.
attribut `os.EOL`::
  Caractère utilisé pour marquer les fins de ligne. +
  En général le caractère `\n` sous Unix et `\r\n` sous Windows.

[NOTE]
.[RemarquePreTitre]#Documentation# `os`
====
La documentation du module `os` est disponible sur le site officiel de Node :
[URL]#https://nodejs.org/docs/latest-{nodeCurrentVersion}.x/api/os.html#
====

[[child_process]]
=== `child_process` : appeler un exécutable système

Le module `child_process` *exécute des programmes externes*,
leur transmet des données et consulte leurs résultats via
les <<process.std,flux standards>>.

[source%interactive,javascript]
.child_process/intro.js
----
include::{sourceDir}/child_process/intro.js[]
----
<1> L'exécution de la commande renvoie une erreur Node ainsi que
la <<process.std,sortie standard>> et la <<process.std,sortie erreur>>
du processus enfant
<2> Affiche `version installée de npm : {npmV}`

L'utilisation du module `child_process` se justifie quand un programme
externe fournit une fonctionnalité _mais_ ne s'interface pas avec Node.
Ou encore quand on veut sortir l'exécution d'un script Node du processus courant
pour tirer parti des autres CPU de l'ordinateur sans ralentir l'application principale.

La fonction `child_process.exec` accepte un deuxième argument optionnel. +
`cwd` (_current working directory_) est une des options utiles de cet argument.

[source%interactive,javascript]
.child_process/ls.js
----
include::{sourceDir}/child_process/ls.js[]
----
<1> On lance la commande système `ls` dans le répertoire courant,
sans spécifier de valeur pour le répertoire de travail

Exécutons le script pour observer le résultat :

[source,bash]
----
$ node child_process/ls.js
----

Le constat est similaire à celui produit avec le <<fs,module `fs`>> :
les fichiers listés sont ceux du _répertoire courant_,
notre emplacement dans le terminal.

Modifions maintenant la valeur de l'option `cwd` :

[source%interactive,javascript]
.child_process/ls-root.js
----
include::{sourceDir}/child_process/ls-root.js[]
----
<1> La valeur de `cwd` est réglée sur `/`, c'est à dire le répertoire racine
du système de fichiers

[source,bash]
----
$ node child_process/ls-root.js
----

La liste des fichiers et répertoires affichée est désormais différente,
même si la commande passée à `child_process.exec` est la même. +
`cwd` a changé le _répertoire courant_ l'espace d'une commande.

[NOTE]
.[RemarquePreTitre]#Performance# commande `ls` vs. `fs.readdir`
====
Si on arrive au même résultat en utilisant `exec('ls')`, pourquoi utiliser
la fonction `fs.readdir` du <<fs,module `fs`>> ?
`fs.readdir` a au moins 3 avantages :

. elle est *plus rapide* — à écrire, à éxécuter, à diagnostiquer
. on *économise* la création d'un processus système
. *compatibilité* avec _tous_ les systèmes d'exploitation
====

`env` est une deuxième option à passer à `child_process.exec`.
Elle redéfinit les <<process.env,variables d'environnement>> utilisables
par le processus enfant :

[source%interactive,javascript]
.child_process/ping.js
----
include::{sourceDir}/child_process/ping.js[]
----
<1> On transmet les variables d'environnement existantes au processus enfant
<2> Utilisation de la variable d'environnement `PING_COUNT` comme
valeur d'option du programme `ping`

Si on ne transmet pas les valeurs de `process.env` au processus enfant,
la variable d'environnement `PATH` ne serait plus définie.
Le processus enfant ne saurait plus où chercher l'exécutable `ping`. +
On aurait pu appeler le programme `ping` en utilisant un chemin absolu comme
`/sbin/ping`… mais son emplacement varie selon les systèmes d'exploitation.

[source,bash]
----
$ node child_process/ping.js
PING oncletom.io (185.31.40.11): 56 data bytes
64 bytes from 185.31.40.11: icmp_seq=0 ttl=56 time=23.763 ms

--- oncletom.io ping statistics ---
1 packets transmitted, 1 packets received, 0.0% packet loss
round-trip min/avg/max/stddev = 23.763/23.763/23.763/0.000 ms
----

[WARNING]
.[RemarquePreTitre]#Compatibilité# Mon programme ne fonctionne pas sous Windows/Linux/macOS
====
Le programme externe peut ne pas exister sur tous les systèmes d'exploitation,
voire il ne s'appelle pas avec les mêmes arguments, ni avec le même nom.

Une des solutions pourrait consister à se reposer sur le <<os,module `os`>>
et adapter la commande en fonction du système d'exploitation.
====

`child_process.spawn` est une _autre approche_ de démarrage
et de communication avec un processus externe.

[source%interactive,javascript]
.child_process/spawn.js
----
include::{sourceDir}/child_process/spawn.js[]
----
<1> `cat` est un programme qui affiche le contenu d'un fichier
<2> Les données retournées par la commande externe se lisent depuis
les <<process.std,flux de sorties>>
<3> Affiche le code source de ce script

Avec `spawn`, les arguments et options sont passées dans un tableau.
C'est comme si nourrissait <<process.argv,`process.argv`>>. +
Si les données sont lues depuis les <<process.std,flux de sortie>>,
cela veut aussi dire qu'on peut écrire des choses dans le
flux d'entrée :

[source%interactive,javascript]
.child_process/spawn-stdin.js
----
include::{sourceDir}/child_process/spawn-stdin.js[]
----
<1> Écrit `0123 abcd` dans le flux d'entrée
<2> Signale au processus externe qu'il n'aura plus de donnée
— le programme `tr` rendra la main dès qu'il nous aura tout transmis
<3> Affiche `abcd klmn`

L'exécutable `tr` substitue des plages de caractères.
On lui a transmis des caractères en entrée et spécifié les plages de traduction
en arguments.
Nous avons utilisé la <<process.std,sortie standard>> pour lire les résultats.

L'exemple précédent revient au même que cette commande :

[source,bash]
----
$ echo -n '0123 abcd' | tr 0-9a-f a-p
abcd klmn
----

Une conclusion parallèle que l'on peut établir est que le _scripting shell_
est plus concis que notre code.
On pourrait leur déléguer du travail et transmettre les données nécessaires
à nos scripts Node via les <<process.std,flux standards>>.

[horizontal]
.Propriétés notables
`child_process.exec()`::
  Exécute une commande et retourne son _résultat_.
`child_process.spawn()`::
  Exécute une commande et retourne un objet <<process,processus>>.
  Le script Node et le nouveau processus peuvent communiquer entre eux.

[horizontal]
.Propriétés notables de la classe `ChildProcess`
`process.on('message')`::
  Déclenché lorsque le processus enfant reçoit un message envoyé par l'autre script.
`process.kill()`::
  Envoie un <<signals,signal d'arrêt>> au processus enfant.
`process.send()`::
  Envoie un message au processus enfant.
`process.stdin`::
`process.stdout`::
`process.stderr`::
  <<process.std,Flux standards>> du processus enfant.
  Idéal pour envoyer et récupérer des données en continu.

[NOTE]
.[RemarquePreTitre]#Documentation# `child_process`
====
La documentation du module `child_process` est disponible sur le site officiel de Node :
[URL]#https://nodejs.org/docs/latest-{nodeCurrentVersion}.x/api/child_process.html#
====


[[process]]
=== `process` : en savoir plus sur le processus en cours

La module `process` retourne des informations
sur l'environnement dans lequel le script est exécuté.
À l'instar du <<console,module `console`>>, la variable `process`
est globale.

[source%interactive,javascript]
.process/intro.js
----
include::{sourceDir}/process/intro.js[]
----
<1> Affiche quelque chose comme `['LANG', 'SHELL', 'PATH', 'HOME', 'USER', ...]`
(cf.{nbsp}<<process.env,variables d'environnement>>)
<2> Affiche
`[ '.../v{nodeV}/bin/node', '.../chapter-04/examples/process/intro.js' ]`
(cf.{nbsp}<<process.argv,arguments d'exécution>>)

Notre code peut être interprété par Node
sur plusieurs types de machines
(ordinateur récent ou fatigué, Raspberry Pi, etc.),
sur différents systèmes d'exploitation (Windows, Linux, macOS, etc.). +
Nous avons ainsi tout le loisir d'adapter notre code
à ces différents environnements.


[[process.env]]
Les variables d'environnement sont des
*variables définies au niveau du système d'exploitation*.
Elles contiennent des informations comme le _répertoire courant_, langue du système d'exploitation, l'utilisateur système courant, le type de terminal, les emplacements d'installation des exécutables, etc.

On retrouve ces variables sous la forme d'un
<<../chapter-03/index.adoc#object,objet ECMAScript>> nommé `process.env` :

[source,bash]
----
$ node -p 'process.env'
{ ITERM_PROFILE: 'Default',
  LANG: 'en_GB.UTF-8',
  PWD: '/Users/oncletom/workspace/nodebook',
  SHELL: '/bin/zsh',
  TERM_PROGRAM_VERSION: '3.1.5',
  TERM_PROGRAM: 'iTerm.app',
  ...
}
----

Nous pouvons créer des variables d'environnement pour
*transmettre des informations contextuelles* à nos programmes :
des chemins d'accès à une base de données, si on est en situation de test
ou de production, l'emplacement de fichiers nécessaires au fonctionnement
de notre programme, etc.

Par exemple et par convention, la variable `NODE_ENV` est utilisée pour indiquer au programme
s'il est lancé dans le cadre du développement, de l'exécution des tests
ou s'il tourne sur le serveur de production.

Variable d'environnement éphémère::
La variable n'existe que pendant la durée de vie du programme.
La définition `CLÉ=valeur` est placée sur la même ligne que le programme
en question.
[source,bash]
----
$ NODE_ENV=production node process/env.js
mode : production
----
Variable d'environnement permanente::
La variable existe pendant la durée de la session
grâce à l'opérateur `export` sous Linux et macOS et
avec l'opérateur `set` sous Windows. +
La définition `export CLÉ=valeur` est placée sur sa propre ligne.
Elle restera accessible à _tout programme_ jusqu'à la fin de la session
ou jusqu'à ce qu'on efface la variable.
[source,bash]
----
$ export NODE_ENV=production
$ node process/env.js
mode : production
----

[TIP]
.[RemarquePreTitre]#Revenir en arrière# Effacer une variable d'environnement
====
L'utilisation de l'opérateur `unset` dans un terminal efface le contenu
d'une variable d'environnement.
Pratique pour ne pas laisser de traces !

[source,bash]
----
$ export NODE_ENV=dev
$ echo $NODE_ENV
$ unset NODE_ENV
$ echo $NODE_ENV
----
====

Voici le contenu du fichier `process/env.js` utilisé dans les exemples précédents :

[source%interactive,javascript]
.process/env.js
----
include::{sourceDir}/process/env.js[]
----

On notera que son comportement s'adapte à la _présence_ et à la _valeur_
de la variable d'environnement `NODE_ENV`.
Elle est accessible dans Node en tant que `process.env.NODE_ENV`.

[source,bash]
----
$ NODE_ENV=dev node process/env.js
On est en mode développement.
mode : dev
----

Nous verrons d'autres mises en situation des variables d'environnement pour
<<../chapter-06/index.adoc#app-configuration,configurer une application web>>
dans le <<../chapter-06/index.adoc#,chapitre 6>> et pour
<<../chapter-08/index.adoc#debug,déboguer une application en ligne de commande>>
dans le <<../chapter-08/index.adoc#,chapitre 8>>.

[[process.argv]]
Les arguments d'exécution sont des morceaux d'information transmis
à un script Node.
On les place à la droite du nom du fichier, comme illustré dans cet exemple :

----
$ node print-first.js salut
"salut"
----

On utilise les _arguments_ pour affiner le comportement d'un programme.
Je pense par exemple au numéro du port sur lequel lancer un serveur web,
une liste de fichiers à traiter ou
encore de fonctionnalités à activer ou à désactiver.

Il faut imaginer les arguments comme des *paramètres de fonction*,
accessibles dans un programme Node dans
le <<../chapter-03/index.adoc#array,tableau>> `process.argv` :

[source,javascript]
.print-first.js
----
include::{sourceDir}/print-first.js[]
----

Les deux premiers éléments de `process.argv` sont rarement utilisés.
Ils correspondent respectivement à l'emplacement de l'exécutable Node
et à l'emplacement du script.

Tous les autres arguments sont accessibles à partir de l'index 2 de
`process.argv`, dans l'ordre où ils sont placés :

----
$ node print-first.js salut ça va ?
"salut"
----

Le script `print-first.js` affiche le premier argument.
On peut en conclure que les arguments sont séparés par le caractère "espace".

Dans le cas où un argument doit contenir un espace, on l'encadre alors
entre guillemets :

----
$ node print-first.js "salut ça va ?" "oui et toi ?"
"salut ça va ?"
----

L'inconvénient des arguments est que leur ordre compte
et qu'il devient difficile de connaitre leur rôle sans se référer
au manuel d'utilisation.

C'est là qu'interviennent les *options*.
Comme le nom l'indique, ce sont des _arguments optionnels_.
Elles sont préfixées de deux _traits d'union_ (`--`).
On peut choisir de leur associer ou non une valeur.

----
$ node print-text.js "salut ça va ?" --uppercase
SALUT ÇA VA ?
----

Quand on n'associe pas de valeur à une option,
on considère qu'elle équivaut à un <<../chapter-03/index.adoc#boolean,booléen>>
de valeur `true`.

[source,javascript]
.print-text.js
----
include::{sourceDir}/print-text.js[]
----
<1> La condition est positive si l'on détecte `--uppercase` dans
la liste des arguments

Les _options_ se combinent très bien avec les _arguments_.
Il faut les imaginer comme des interrupteurs.

Dans d'autres situations, on a besoin de *passer une valeur à une option* :

----
$ node print-text-limit.js "salut ça va ?" --limit 2
salut ça
----

L'exemple précédent illustre la césure d'une phrase à 2 mots
lorsque l'option `--limit` est associée à la valeur `2`.


[source,javascript]
.print-text-limit.js
----
include::{sourceDir}/print-text-limit.js[]
----
<1> On récupère l'index de l'option `--limit` dans le tableau `process.argv`
<2> On récupère la valeur de l'élément suivant `--limit` dans `process.argv`
<3> La troncature est paramétrée en fonction de la valeur associée à `--limit`

Au fond, *les options sont des repères pour les utilisateurs* de nos programmes.
Elles leur permettent de s'interfacer avec leurs fonctionnalités.
Un peu à la manière des différents boutons qu'on retrouve
en façade d'une machine à laver.

L'exemple suivant est totalement fictif mais il illustre comment
on s'interfacerait avec une machine à laver
si elle mettait à disposition en ligne de commande :

----
$ machine-a-laver P-ECO 40 --fast --no-dry --room kitchen
----

Ce qu'il faut en comprendre, c'est qu'on démarrerait la machine située
dans la cuisine avec un programme économique _et_ à 40°C,
en activant l'option rapide et _en désactivant_ l'option séchage.

Nous verrons d'autres mises en situation pour
<<../chapter-08/index.adoc#argv,passer des paramètres à une application en ligne de commande>>
dans le <<../chapter-08/index.adoc#,chapitre 8>>.

[[process.std]]
Chaque processus système est doté de 3 flux de données :
le flux d'*entrée* (`stdin`), le flux de *sortie* (`stdout`)
et le flux d'*erreur* (`stderr`).

Les flux standards peuvent être alimentés pendant la durée de vie du processus
en utilisant peu de mémoire.
On les utilisera pour *passer le résultat d'un autre programme*
à notre script Node, pour *informer l'utilisateur* de notre programme
mais aussi pour *consigner les erreurs*.

Node expose ces flux standards via les variables `process.stdin` (entrée),
`process.stdout` (sortie) et `process.stderr` (erreur).
Chacune de ces variables possède des méthodes pour _écouter_ ce qu'il s'y passe,
pour y _écrire_ du contenu et pour le _rediriger_ vers d'autres endroits.

Commençons par l'utilisation de `process.stdout` pour écrire un message
dans notre terminal :

[source,bash]
----
$ node process/stdout.js
un deuxtrois
quatre
----

Le code source de `process/stdout.js` fait appel à la fonction
`process.stdout.write` par deux fois. +
On notera que le caractère `\n` symbolise un retour à la ligne
(`\r\n` sous Windows) :

[source,javascript]
.process/stdout.js
----
include::{sourceDir}/process/stdout.js[]
----

Ça ne vous rappelle pas nos précédentes utilisations de la fonction
`console.log` ?
Pas étonnant puisque `console.log` se repose sur `process.stdout`
(voir encadré ci-contre).


[TIP]
.[RemarquePreTitre]#Raccourci# Les fonctions `console.log` et `console.error`
====
La fonction d'affichage `console.log` écrit dans le flux de sortie
`process.stdout`.
Sans surprise, `console.error` écrit dans le flux d'erreur
`process.stderr`.

Elles ajoutent un _retour à la ligne_ et des options de formatage pour
notre confort.

On en parlera davantage dans la section <<console,console>>.
====

Quand on vers le flux de _sortie_ ou le flux d'_erreur_,
on s'ouvre à l'analyse en continu de ce flux.
Comment ?
À l'aide d'utilitaires systèmes existants (`grep`, `awk` etc.)
ou des programmes spécifiques (analyse de _logs_, etc.).

On peut ainsi se concentrer sur un programme qui
fait *juste ce dont on a besoin* sans être tenté·e de tout faire.
On laisse le travail de spécialisation à d'autres programmes.
Ils pourraient être écrits en Node d'ailleurs…

Essayons d'ailleurs de _filtrer_ la sortie de l'exemple précédent
sans écrire une ligne de code de plus.
Le programme _grep_ ([URL]#https://fr.wikipedia.org/wiki/Grep#)
est fourni par défaut sur les systèmes UNIX (dont Linux et macOS) font partie.
Il ne retourne que les ligne contenant un motif
donné en <<process.arv,argument>> :

[source,bash]
----
$ node process/stdout.js | grep 'tre'
qua<i>tre</i>
----

La _sortie standard_ de `process/stdout.js` est devenue l'_entrée standard_
de `grep` grâce à l'utilisation du _pipe_ (`|`).

C'est le moment idéal de regarder du côté de l'_entrée standard_ de Node.
Implémentons quelque chose qui passe le message d'entrée en majuscules :

[source,bash]
----
$ echo "un deuxtrois\nquatre" | node process/stdin-uppercase.js
UN DEUXTROIS
QUATRE
----

On aurait aussi pu réutiliser la _sortie_ de l'exemple `process/stdout.js` :

[source,bash]
----
$ node process/stdout.js | node process/stdin-uppercase.js
UN DEUXTROIS
QUATRE
----

Voyons comment ça fonctionne sous le capot :

[source,javascript]
.process/stdin-uppercase.js
----
include::{sourceDir}/process/stdin-uppercase.js[]
----
<1> Chaque afflux de donnée appelle notre fonction en lui fournissant un seul
paramètre contenant les données en question
<2> Le paramètre est de <<buffer,type Buffer>> — on souhaite le transformer en
<<../chapter-03/index.adoc#string,chaîne de caractères>>
<3> La _chaîne de caractères_ est transformable en majuscules, que l'on écrit
dans le flux de sortie

Terminons avec la _sortie erreur_ (`process.stderr`).
Elle fonctionne de manière identique à la _sortie standard_ (`process.stdout`).
S'il n'y a visuellement aucune différence, la _sortie erreur_ écrit son contenu
dans un canal différent — un _descripteur_ différent. +
On l'utilise pour *déboguer des programmes*, pour *lister des erreurs* ou des
contenus que l'on souhaite dissocier de la sortie standard.

L'exemple suivant affiche un nombre toutes les demi-secondes et l'état
du compteur de nombres tous les 10 affichages :

[source,bash]
----
$ node process/stdout-long.js
7
24
3
19
25
Compteur = 5
22
...
----

[NOTE]
.[RemarquePreTitre]#Souvenez-vous# Interrompre un programme avec kbd:[Ctrl+C]
====
Un programme peut être interrompu à tout moment en utilisant la combinaison
de touches kbd:[Ctrl+C].
====

[source,javascript]
.process/stdout-long.js
----
include::{sourceDir}/process/stdout-long.js[]
----
<1> Écrit un nombre entre 0 et 30 dans la _sortie standard_
<2> On incrémente un compteur en plus de vérifier s'il est bien divisible par 5
<3> Écrit l'état du compteur dans la _sortie erreur_

On pourrait décider de n'afficher que le flux d'erreur.
Pour cela on _redirige_ la sortie standard avec l'opérateur `>`
vers un fichier :

[source,bash]
----
$ node process/stdout-long.js > stdout.txt
Compteur = 5
Compteur = 10
...
----

Si on ouvrait le fichier `stdout.txt`, on verrait
la liste de nombre générée par notre programme. +
La *redirection a écrit le contenu dans ce fichier* au lieu de notre terminal.

En maitrisant les flux standards, on peut *créer des programmes modulaires*
qui consomment du contenu sans avoir à connaître leur provenance.
*Les données peuvent aller et venir* _depuis_ et _vers_ des programmes externes,
des fichiers ou des sites web distants.

Pour mieux comprendre la logique de _flux continu_ que l'on vient de découvrir,
je vous invite à lire la section liée au <<stream,module `stream`>>
de ce même chapitre.
On y détaillera la liste des événements à écouter ainsi que les différentes
méthodes d'écriture, de pause et de lecture.

[[process.on]]
Un processus système reçoit et émet des données mais il peut aussi
*écouter des événements* grâce à la fonction `process.on`.

[source,javascript]
.process/exit.js
----
include::{sourceDir}/process/exit.js[]
----

L'exemple ci-dessus illustre l'événement `exit`.
Cet événement est déclenché quand le processus se termine.
À ce titre, un *code de sortie* est fourni pour signaler l'état dans
lequel le programme se termine — bien, ou pas très bien, et pourquoi.
On parlera davantage du code de sortie et de leur signification
dans la section ci-après, <<process.exit,Mettre fin au processus>>.

Essayons de lancer l'exemple précédent pour voir :

[source,bash]
----
$ node process/exit.js
Le processus démarre
Le processus termine avec le code 0
----

Tout s'est passé correctement.
Le _code de sortie_ équivaut à `0` donc.

Si le programme venait à se terminer de manière imprévue, nous pouvons
supposer que le code serait différent. +
L'exemple suivant provoque volontairement une erreur en faisant
référence à une variable qui n'existe pas :

[source,javascript]
.process/exit-error.js
----
include::{sourceDir}/process/exit-error.js[]
----

Que verrions-nous si on lançait le script ?

[source,bash]
----
$ node process/exit-error.js
Le processus termine avec le code 1

ReferenceError: jenexistepas is not defined
    at Object.<anonymous> (/.../nodebook/chapter-04/examples/process/exit-error.js:5:13)
----

Cette fois-ci le code de sortie est `1`.
Cela correspond à une _erreur qui n'a pas été capturée_.
Le reste du message décrit _pourquoi_ l'erreur s'est manifestée.

[TIP]
.[RemarquePreTitre]#Terminal# Code de sortie
====
Dans un terminal, la variable `$?` contient le code de sortie
de la dernière commande exécutée.
Sa valeur devrait être équivalente à celle passée en argument
de l'événement `process.on('exit')`.

[source,bash]
----
$ echo $?
----
====

On est maintenant capable de déterminer si un programme s'arrête
normalement ou à cause d'une erreur qu'on aurait laissé
passer sans faire exprès.

On peut écouter d'autres événements liés au cycle de vie de nos applications :


[cols="1,1,2",options="header"]
.Événements liés au cycle de vie du processus Node
|===
| Événement
| Paramètres
| Raison du déclenchement

| `exit`
| `(exitCode)`
| Le programme se termine et va rendre la main au système d'exploitation.

| `unhandledRejection`
| `(reason, promise)`
| Une <<../chapter-03/index.adoc#promise,promesse>> a échoué
et n'a pas été capturée à l'aide de la méthode `.catch()`.

| `uncaughtException`
| `(error)`
| Une erreur s'est produite et n'a pas été capturée.
Si rien n'est fait, le processus va s'arrêter avec un code erreur. +
*Note* : il vaut mieux qu'un programme s'arrête en cas de problème.

| `message`
| `(message, sourceSocket)`
| Un <<child_process,processus parent>> nous envoie un message.
|===

[[signals]]
La méthode `process.on` est à l'écoute des *signaux système*.
Vous vous souvenez de la combinaison de touches kbd:[Ctrl+C]
utilisée précédemment ?
Cette combinaison émet en réalité un _signal d'interruption_.
Un signal d'interruption répond à l'identifiant `SIGINT`.

Node gère ces signaux pour nous.
Mais on peut aussi se mettre à les écouter et décider de faire autrement
que son comportement par défaut.

On pourrait par exemple afficher l'heure de l'arrêt
du processus avant de rendre la main :

[source,javascript]
.process/interrupt.js
----
include::{sourceDir}/process/interrupt.js[]
----
<1> Un premier message s'affichera au démarrage du script
<2> Cette <<../chapter-03/index.adoc#function,fonction>> se déclenche lors de
la réception du _signal d'interruption_ (`SIGINT`), lorsque le système
d'exploitation lui relaie notre combinaison de touches kbd:[Ctrl+C]
<3> La fonction <<process.exit,`process.exit`>> nous permet de mettre fin
manuellement au processus (voir section ci-après)
<4> Sinon ce _timer_ mettra fin au processus au bout de 5 secondes

En pratique le résultat ressemblerait à ceci :

[source,bash,subs="macros"]
----
$ node process/interrupt.js
2018-03-16T10:58:32.855Z - Processus démarré
kbd:[Ctrl+C]
2018-03-16T10:58:40.000Z - Processus terminé (manuellement)
----

En plus du signal `SIGINT`, Node nous relaie les signaux suivants :

[cols="1,2",options="header"]
.Événements liés aux _signaux_ systèmes
|===
| Événement   | Raison du déclenchement
| `SIGINT`    | Interruption de la commande en cours
| `SIGTERM`   | Demande au processus de s'arrêter
| `SIGUSR1`   | Node reçoit le signal d'attacher l'<<inspect,inspecteur>>
| `SIGHUP`    | Le terminal est en train d'être fermé
| `SIGWINCH`  | Le terminal a été redimensionné
|===

`SIGKILL` est un autre événement important mais on ne peut _pas_ l'écouter.
Quand il est émis, le processus doit être arrêté quoiqu'il arrive.
On l'utilise justement en cas de dernier recours, quand `SIGINT`
et `SIGTERM` ne font pas effet (à cause d'un bug dans notre code,
une ressource qui ne rend pas la main etc.).

[[process.exit]]
*Un processus Node se termine quand il n'a plus d'instructions à exécuter*.
Un processus Node peut être terminé via
l'<<signals,émission d'un signal extérieur>>.
Mais on peut aussi y mettre fin _de l'intérieur_ par l'intermédiaire
de la fonction `process.exit`.

On utilise cette fonction car le *programme a atteint son but*.
On le fait aussi lorsqu'on intercepte une erreur en souhaitant
effectuer un *traitement spécial avant de mettre fin au processus*.
Il se peut aussi qu'il vaille mieux terminer l'application en cas de perte
d'accès à des ressources distantes (base de données, stockage de fichiers, etc)
et ce, *au lieu de présenter une application web instable*.

L'exemple suivant illustre que l'on souhaite clôturer notre script
si on trouve le bon nombre (un peu comme au jeu _MindMaster_) :

[source,bash,subs="macros"]
----
$ node process/exit-devinette.js
JEU ! Trouve le nombre auquel je pense :
10kbd:[ENTER]
Hm hm, essaie encore.
3kbd:[ENTER]
Tu as trouvé, bravo !
----

Dans cet exemple, on écoute l'utilisateur de manière indéfinie, jusqu'à ce qu'il
ou elle trouve le bon nombre.
Lorsque c'est le cas, on peut interrompre le programme en transmettant
un code de sortie _de réussite_ : le code `0` (zéro).

[source,javascript]
.process/exit-devinette.js
----
include::{sourceDir}/process/exit-devinette.js[]
----
<1> Le nombre secret est `3` par défaut, sauf s'il est passé
<<process.argv,en argument>> du script
<2> Cette fonction est invoquée à chaque saisie suivie de l'utilisation
de la touche kbd:[ENTER]
<3> Cette ligne met fin immédiatement au script, après avoir affiché un
message de félicitations
<4> Ce message s'affichera à chaque saisie erronée, jusqu'à ce que le nombre
secret soit trouvé

On pourrait tout à fait imaginer une variante de ce script dans laquelle
on limiterait le nombre de mauvaises réponses.
Lorsqu'on attendrait cette limite, le programme utiliserait un code de sortie
différent de zéro.
Le code `9` ferait l'affaire puisqu'il indique qu'un _argument invalide_ a été
passé.

[NOTE]
.[RemarquePreTitre]#Avancé# `process.abort`
====
À la manière de `process.exit`, le programme est terminé immédiatement.
On l'utilise quand quelque chose d'inopiné et nécessitant un débogage
avancé se produit.

La fonction génère un fichier de débogage qui contient tout le contenu
de la mémoire utilisée par Node (_core file_).
Un truc assez compliqué à analyser pour le commun des mortels.
Suffisamment pour qu'on passe notre chemin à ce stade.
====


[NOTE]
.[RemarquePreTitre]#Documentation# `process`
====
La documentation du module `process` est disponible sur le site officiel de Node :
[URL]#https://nodejs.org/docs/latest-{nodeCurrentVersion}.x/api/process.html#
====


[[stream]]
=== `stream` : manipuler des flux de données

Le module `stream` contient les éléments de base pour lire, écrire et
transformer des flux de données rapidement et avec peu de mémoire.

Créer ses propres flux est une chose assez compliquée à réaliser.
Dans cette section nous allons nous focaliser sur l'utilisation des modules
Node qui génèrent de tels flux.

[source%interactive,javascript]
.stream/intro.js
----
include::{sourceDir}/stream/intro.js[]
----
<1> On crée un _flux de lecture_ qui ouvre le fichier courant (`+__filename+`)
<2> Invoque cette fonction à chaque morceau de données lu
<3> Affiche le nombre d'octets lus dans ce morceau

[source,bash]
----
$ node stream/intro.js
214 octets lus
----

*Un _flux_ de lecture consomme les données en _morceaux_*.
Il correspond à une instance de l'objet <<stream.Readable,`stream.Readable`>>.
L'exemple précédent n'a affiché qu'un seul morceau car la taille maximale
par défaut est d'environ `16Ko`.

[source%interactive,javascript]
.stream/read.js
----
include::{sourceDir}/stream/read.js[]
----
<1> On spécifie cette fois qu'on lit `100 octets` à la fois
<2> Affiche `Lecture terminée` lorsque tous les morceaux ont été lus

L'option `highWaterMark` adapte le débit de lecture.
Cette valeur est exprimé en _octets_.
Plus ce nombre est petit, moins Node utilise de mémoire :

[source,bash]
----
$ node stream/read.js
100 octets lus
100 octets lus
78 octets lus
Lecture terminée
----

Le mécanisme de flux s'applique également à l'écriture.
*Un flux d'écriture nous permet d'écrire des données par morceaux*.
Il correspond à une instance de l'objet <<stream.Writeable,`stream.Writeable`>>.

L'exemple suivant illustre une succession d'écriture dans un même flux :

[source%interactive,javascript]
.stream/write.js
----
include::{sourceDir}/stream/write.js[]
----
<1> On crée un _flux d'écriture_ vers le fichier `stream/debug.txt`
<2> Écrit `Hell` dans le flux
<3> Écrit `d!` dans le flux et signale que nous n'avons plus de données à
transmettre
<4> Lit le contenu du fichier en une seule fois et affiche `Hello World!`

Cette écriture par morceaux a pour effet de réduire la pression mémoire
exercée par Node sur le système d'exploitation _et_ pour le reste du programme.
Ce mécanisme est particulièrement adapté lorsque l'écriture prendra du temps
ou implique un certain volume de données.

*Les flux de lecture et d'écriture peuvent être combinés*.
Les données lues depuis une source (`Readable`) sont redirigées vers
une destination (`Writeable`) à l'aide de la fonction `pipe()` :

[source%interactive,javascript]
.stream/pipe.js
----
include::{sourceDir}/stream/pipe.js[]
----
<1> On crée un flux de lecture
<2> On crée un flux d'écriture
<3> On _redirige_ le flux de lecture _vers_ le flux d'écriture
<4> La redirection retourne le flux d'écriture, que l'on écoute pour savoir
quand il a terminé d'écrire sur le disque

Dans cet exemple, nous avons pris deux fichiers comme source de lecture
et destination d'écriture.
Nous avons assemblé les deux flux avec `pipe()` puis détecté la fin de la copie.

[NOTE]
.[RemarquePreTitre]#Unix# Opérateur _pipe_ (`|`)
====
La fonction `stream.pipe()` correspond littéralement à l'opérateur Unix `|`.

Les morceaux de données d'un premier programme sont transmis en entrée à un
second programme.
Ici, le mécanisme s'applique à des fonctions Node.
====

L'utilisation de `pipe()` peut paraitre superflue pour copier des fichiers.
À vrai dire, la fonction <fs,`fs.copyFile`>> fait exactement la même chose. +
Le mécanisme de redirection proposé par `pipe()` est modulaire et composable.

On peut par exemple diriger une source de données vers *plusieurs flux d'écriture*.
En même temps :

[source%interactive,javascript]
.stream/pipe-multi.js
----
include::{sourceDir}/stream/pipe-multi.js[]
----
<1> Écrit une copie du fichier comme dans l'exemple `stream/pipe.js`
<2> Redirige le contenu de lecture vers la <<process.std,sortie standard>> de notre terminal

Cette technique agit comme une _gare de triage_ : nous avons la liberté
d'agir sur les données avant de les envoyer vers leur flux d'écriture distinct.

On peut aussi *transformer les contenus à la volée* en utilisant plusieurs
fois la fonction `pipe()`.
Les données sont passées à des objets capable de lire _et_ d'écrire des flux.
C'est le cas du <<extras,module `zlib`>>, responsable de compresser et de
décompresser des données :

[source%interactive,javascript]
.stream/pipe-transform.js
----
include::{sourceDir}/stream/pipe-transform.js[]
----
<1> Compresse les données à la volée
<2> Les données compressées sont transmises à la <<process.std,sortie standard>>

Cet exemple devrait afficher le contenu de notre fichier source avec une taille
réduite grâce à la compression _gzip_ :

[source,bash]
----
$ node stream/pipe-transform.js
----

L'affichage semble bizarre et c'est normal : ce sont des données compressées
au format gzip ; un format de compression libre et populaire.

Le programme Unix `gzip` sait décoder des données compressées dans ce format.
Il sait aussi les décoder à la volée… avec un `pipe()` :

[source,bash]
----
$ node stream/pipe-transform.js | gzip
----

On a bouclé la boucle en _décompressant_ un flux de données à la volée
en utilisant un programme extérieur à Node.


[horizontal, id="stream.Readable"]
.Principaux attributs d'un flux _Readable_
`stream.pipe()`::
  Redirige un flux de lecture vers un flux d'écriture.
`stream.on('data')`::
  Déclenché lorsqu'un morceau de données a été lu.
`stream.on('error')`::
  Déclenché lorqu'une erreur se produit.
`stream.on('end')`::
  Déclenché lorsqu'il n'y a plus de données à lire.
`stream.on('readable')`::
  Déclenché lorsque la lecture de données est prête à démarrer.

[horizontal, id="stream.Writeable"]
.Principaux attributs d'un flux _Writeable_
`stream.write()`::
  Écrit des données dans le flux.
`stream.end()`::
  Signale que nous n'avons plus de données à transmettre.
`stream.on('drain')`::
  Déclenché lorque la mémoire d'écriture est vide et prête à accepter
  de nouvelles données.
`stream.on('error')`::
  Déclenché lorqu'une erreur se produit.
`stream.on('finish')`::
  Déclenché lorsqu'on a clôturé le flux d'écriture.

[NOTE]
.[RemarquePreTitre]#Documentation# `stream`
====
La documentation du module `stream` est disponible sur le site officiel de Node :
[URL]#https://nodejs.org/docs/latest-{nodeCurrentVersion}.x/api/stream.html#
====

=== D'autres modules pour aller plus loin

Node embarque d'autres modules que ceux listés précédemment.
Ils nécessitent des connaissances sur des sujets bas niveau,
plus proches du matériel et des protocoles réseaux.

[[cluster]]module `cluster`::
  Gère la distribution d'une application sur plusieurs CPU d'un même ordinateur.
[[crypto]]module `crypto`::
  Fonctions cryptographiques pour chiffrer, signer et vérifier des données.
[[dgram]]module `dgram`::
  Création et consommation de ressources UDP.
[[dns]]module `dns`::
  Fonctions de résolution et de lecture d'enregistrements DNS.
[[net]]module `net`::
  Création et consommation de ressources TCP. +
  Les modules `http`, `https` et `http2` se basent dessus.
[[readline]]module `readline`::
  Manipulation du curseur dans un terminal.
[[tty]]module `tty`::
  Gestion d'interface de terminal en mode texte.
  Le module `readline` se base dessus.
[[v8]]module `v8`::
  Fonctions de lecture et d'écriture d'instructions de la machine virtuelle V8
  dans le processus actuel.
[[vm]]module `vm`::
  Fonctions de création de nouveaux contextes d'interprétation de la machine virtuelle V8.
[[zlib]]module `zlib`::
  Fonctions de compression et de décompression de données (Gzip, Inflate/Deflate). +
  Ces formats sont utilisés pour la compression de requêtes HTTP.


[[modules]]
== Créer ses propres modules Node

Le chargement des <<modules-builtin,modules de base>> nous a aidé à utiliser
des fonctionnalités fournies directement par Node.
Nous pouvons exploiter ce mécanisme pour
*organiser son code dans plusieurs fichiers*.
C'est un mécanisme comparable à ce que l'on retrouve en Python (`import`),
PHP (`require`) et Ruby (`require` et `require_relative`).

=== Importer et exporter des valeurs

[source,javascript]
.modules/enfant.js
----
include::{sourceDir}/modules/enfant.js[]
----

Le fichier d'exemple `modules/enfant.js` contient une variable, `number`.
Essayons de la réutiliser dans le fichier `modules/parent.js`
à l'aide de la fonction `require()` :

[source,javascript]
.modules/parent.js
----
include::{sourceDir}/modules/parent.js[]
----
<1> Contrairement aux <<modules-builtin,modules de base>>,
on passe un *chemin relatif au fichier courant*
<2> Est-ce que cela affichera la valeur de la variable `number` ?
<3> Mais au fond, que contient notre variable `enfant` ?

Exécutons le fichier `modules/parent.js` avec Node pour en avoir le cœur net :

[source,bash]
----
$ node modules/parent.js
undefined
{}
----

De là nous pouvons en tirer un apprentissage important :
*on ne peut pas voir ce qu'il y a _dans_ un module depuis _l'extérieur_*.

Choisissons maintenant ce que l'on souhaite exporter en assignant
la valeur de notre choix à `module.exports` :

[source,javascript]
.modules/enfant-export.js
----
include::{sourceDir}/modules/enfant-export.js[]
----

Comment est-ce que ça se traduit lorsqu'on l'appelle avec `require()` ?

[source,javascript]
.modules/parent-export.js
----
include::{sourceDir}/modules/parent-export.js[]
----
<1> Affiche `undefined`
<2> Affiche `42`

*`module.exports` rend visible ce qui est exporté par un module*.
Les éléments exportés sont visibles depuis l'extérieur.
Par défaut, `module.exports` est un objet.

Essayons maintenant d'exporter plusieurs valeurs en une seule fois :

[source,javascript]
.modules/enfant-export-multiple.js
----
include::{sourceDir}/modules/enfant-export-multiple.js[]
----

Nous avons créé deux nouvelles valeurs : `number` (un nombre) et
`random` (une fonction).

[source,javascript]
.modules/parent-export-multiple.js
----
include::{sourceDir}/modules/parent-export-multiple.js[]
----
<1> Affiche `42`
<2> Affiche un nombre aléatoire entre 0 et 100
<3> Réexporte la fonction `enfant.number`


[TIP]
.[RemarquePreTitre]#Raccourci# Exporter un objet
====
L'utilisation de la syntaxe d'objet raccourcie évite la répétition
du nom des variables lors de l'export.

[source,javascript]
----
include::{sourceDir}/modules/enfant-export-shorthand.js[]
----
<1> Liste des valeurs retournée par l'objet `module.exports`

====

En résumé, *pour Node tout fichier `.js` est un module*.
Le mécanisme d'import et d'export est basé sur des chemins de fichiers.
Si on n'utilise pas de chemin de fichiers, Node pense que l'on fait
référence à un <<modules-builtin,module de base>> ou à un
<<../chapter-05/index.adoc#modules,module npm>>
(cf. <<../chapter-05/index.adoc#,chapitre 5>>).

[NOTE]
.[RemarquePreTitre]#Histoire# Modules _CommonJS_
====
Le mécanisme de modules implémenté dans Node est _basé sur_ la
spécification _CommonJS_, à peu de choses près.

[URL]#http://www.commonjs.org/specs/modules/1.0/#
====

=== Aller plus loin avec `require()`

Lorsqu'on fait appel à la fonction `require()`, Node effectue la *liste d'actions* suivantes :

. résolution du chemin vers le module en question
. lecture du fichier
. interprétation du code
. exécution du code
. retourne la valeur de `module.exports`

L'utilisation de `require()` est *synchrone* et *bloquante*.
Si l'exécution du code dans le module chargé prend du temps
— code _lent_, accès à une ressource distante — le chargement
du module en prendra un coup. +
Il vaut mieux ranger les appels _asynchrones_ dans des fonctions
et appeler ces fonctions de manière explicite, _après_ avoir chargé le module.

`require()` permet de *charger 3 types de modules* :

. des *fichiers relatifs au module actuel* +
  `require('./module.js')` cherchera le fichier `module.js` dans le _répertoire courant_.
  `require('../module.js')` cherchera `module.js` dans le _répertoire parent_.
  C'est le cas que l'on a vu jusqu'à présent.
. des *modules Node* +
  Ils sont disponibles avec chaque installation de Node.
  On en parle plus en détail dans la section <<modules-builtin,modules Node>>
  de ce même chapitre.
. des *modules npm* +
  Ils sont disponibles avec une étape d'installation supplémentaire.
  On en parle plus en détails dans le <<../chapter-05/index.adoc#,chapitre 5>>
  consacré à _npm_.

*Node met les modules en cache*.
Si on inclut deux fois le même module, le deuxième import ira directement
à la dernière étape de la _liste d'actions_.
Ça implique aussi que si le module modifie une de ses variables privée,
cette modification impactera le deuxième import.

Voici un module illustrant une variable privée et une variable exportée :

[source,javascript]
.modules/increment.js
----
include::{sourceDir}/modules/increment.js[]
----
<1> Variable privée
<2> `increment` est rendue publique à cet endroit
— la fonction incrémente la variable privée `counter`

Nous allons importer ce module par deux fois, dans deux variables différentes :

[source,javascript]
.modules/double-import.js
----
include::{sourceDir}/modules/double-import.js[]
----
<1> Affiche `1`
<2> Affiche `2`
<3> Affiche… `1` ou `3` ?

Quel est le verdict à votre avis ?
Rien ne vaut une vérification, quitte à remettre en question
notre avis initial :

[source,bash]
----
$ node modules/double-import.js
1
2
3
----

Il faut garder cette information en tête lorsqu'on importe un module.
Sans oublier que ce mécanisme se transforme en atout afin de partager
une variable entre plusieurs modules.
Pratique dans le cas d'un _cache de données_ ou d'une _configuration partagée_.

Enfin, plusieurs *problèmes* peuvent apparaitre lors du chargement d'un module :

- le chemin vers le module est erroné ;
- le module contient une erreur de syntaxe.

Node lancera une <<errors,exception>> et
le programme s'arrêtera aussitôt.

[NOTE,subs="attributes"]
.[RemarquePreTitre]#Documentation# Module _modules_
====
L'intégralité des variables, fonctions et classes du module `modules`
est documentée sur le site web du projet Node.
La documentation contient des informations à jour et qui ne sont pas
forcément listées dans cet ouvrage.

[URL]#https://nodejs.org/docs/latest-{nodeCurrentVersion}.x/api/modules.html#
====

[[esm]]
=== Le futur : les modules ECMAScript

Pendant que Node et de son mécanisme de module montaient en puissance,
les navigateurs web étaient en attente d'une solution native.
Enfin… la spécification des modules ECMAScript a été validée en 2013
mais les navigateurs ont tardé à implémenter le mécanisme.

La plupart d'entre eux ont implémenté les modules ECMAScript en 2017.
C'est le cas du navigateur web Chrome et de
sa <<../chapter-01/index.adoc#v8,machine virtuelle V8>>.

[WARNING]
.[RemarquePreTitre]#Attention# Fonctionnalité expérimentale
====
Si la syntaxe des modules ECMAScript est standardisée,
ce n'est pas encore aussi stable du côté de Node.

Les modules ECMAScript sont suffixés de l'extension `.mjs`
et nécessitent l'utilisation de l'<<options,option de démarrage>>
`--experimental-modules`.
====

Reprenons l'exemple `modules/increment.js` pour le
transformer en module ECMAScript :

[source,javascript]
.modules/increment.mjs
----
include::{sourceDir}/modules/increment.mjs[]
----
<1> Export _par défaut_
<2> Export _nommé_

La syntaxe `export` sert à… exporter des variables.
Cette syntaxe se combine avec `import` :

[source,javascript]
.modules/ecmascript.mjs
----
include::{sourceDir}/modules/ecmascript.mjs[]
----
<1> On n'importe ici que la _valeur par défaut_

Il ne nous reste maintenant plus qu'à exécuter notre script `.mjs`
pour observer le résultat.
On notera l'utilisation de `--experimental-modules` :

[source,bash]
----
$ node --experimental-modules modules/ecmascript.mjs
(node:35074) ExperimentalWarning: The ESM module loader is experimental.
1
----

Reprenons cet exemple pour _importer plusieurs exports d'un coup_ :

[source,javascript]
.modules/ecmascript-multiple.mjs
----
include::{sourceDir}/modules/ecmascript-multiple.mjs[]
----
<1> On importe la _valeur par défaut_ ainsi qu'une _valeur nommée_ —
c'est particulièrement pratique pour sélectionner avec finesse
ce que l'on veut utiliser d'un module
<2> La fonction `reset` remet le compteur à zéro

On notera au passage qu'on utilise la
<<../chapter-03/index.adoc#object-destructuring,destructuration d'objet>>
pour extraire un _export nommé_ depuis un module ECMAScript.

[source,bash]
----
$ node --experimental-modules modules/ecmascript-multiple.mjs
(node:35074) ExperimentalWarning: The ESM module loader is experimental.
2
1
----

La fonction `reset` a bien remis à zéro le compteur entre temps.
Objectif accompli !

Résumons les différences notables avec le mécanisme de modules Node :

- tous les appels à `import` doivent se faire en début de fichier
- on ne peut pas utiliser `import` de manière dynamique
(dans un `if/else` par exemple)
- on peut exporter une _variable par défaut_ *et* plusieurs _variables nommées_
- on peut importer des modules Node depuis un module ECMAScript —
l'inverse n'est pas vrai
- les fichiers doivent être suffixés par `.mjs`

Ce dernier point est le plus embêtant car il ralentit l'interopérabilité
avec les modules destinés au développement web frontend.
Ces derniers contiennent les déclarations `import` et `export` mais…
dans des fichiers `.js`.

L'histoire nous dira si les modalités s'assoupliront avec le temps.

[TIP]
.[RemarquePreTitre]#npm# Module `esm`
====
Le <<../chapter-05/index.adoc#modules,module npm>> `esm`
([URL]#https://npmjs.com/esm#) a pris le parti de déblayer le chemin
de l'interopérabilité.
Il suffit de charger le module `esm` avant de démarrer un script Node,
peu importe son mécanisme de chargement de modules :
`esm` rendra le chargement des modules totalement transparent.

[source,bash]
----
$ node -r esm modules/ecmascript.js
1
$ node -r esm modules/ecmascript.mjs
1
----

Pour en savoir plus sur l'option `-r`, rendez-vous
dans la section <<require,précharger un module>>

====


[NOTE,subs="attributes"]
.[RemarquePreTitre]#Documentation# Modules ECMAScript
====
L'intégralité des fonctionnalités des modules ECMAScript
est documentée sur le site web du projet Node.
La documentation contient des informations à jour et qui ne sont pas
forcément listées dans cet ouvrage.

[URL]#https://nodejs.org/docs/latest-{nodeCurrentVersion}.x/api/esm.html#
====


[[errors]]
== S'en sortir quand ça ne se passe pas comme prévu

On fait toutes et tous des erreurs.
Du coup forcément, notre code va mener à des plantages applicatifs.
La nature des causes varie et impactent notre lecture des messages d'erreur.

Cette section a pour intention de nous aider à prendre confiance dans ce qu'on
voit et de piocher l'information qui va nous aider à résoudre le problème.

=== Une erreur est nichée dans notre code

Il y a 2 familles d'erreurs dans du code ECMAScript : les *erreurs de syntaxe*
et les *erreurs d'exécution*.

Dans tous les cas, Node *lance une exception* complétée d'une *trace d'erreurs*.
Le but est de comprendre où l'interpréteur se prend les pieds dans le tapis
et quel est le chemin parcouru au sein du code pour y parvenir.

Commençons avec une _erreur de syntaxe_ :

[source,bash]
----
$ node syntax-error.js
console.log('oups j'ai fait une erreur de guillemets);
            ^^^^^^^^

SyntaxError: missing ) after argument list
    at new Script (vm.js:74:7)
    at createScript (vm.js:246:10)
    at Object.runInThisContext (vm.js:298:10)
----

*Une erreur de syntaxe est immédiate*.
Node la détecte lorsqu'il _parse_ notre code.

Dans l'exemple précédent, Node indique qu'il manque une parenthèse après le
deuxième guillemet, car c'est le symbole que l'interpréteur attend. +
Pourquoi Node attend-il une parenthèse ?
Car le guillemet indique une intention incorrecte : on ne veut pas qu'il
signifie la fin de la chaîne mais qu'il représente un caractère apostrophe dans
la chaîne.

La correction à entreprendre ne sera pas d'ajouter une parenthèse après le
guillemet mais bien de l'_échapper_ en le préfixant d'un caractère `\`.
Node l'interprétera alors comme un caractère.

Penchons-nous à présent sur les _erreurs d'exécution_ :

[source,bash]
----
$ node process/exit-error.js
console.log(jenexistepas);
            ^
ReferenceError: jenexistepas is not defined
    at Object.<anonymous> (/.../chapter-04/examples/process/exit-error.js:5:13)
    at Module._compile (module.js:643:30)
----

*Une erreur d'exécution est provoquée lorsque le code est exécuté*.
Le marqueur `+^+` indique l'emplacement où le problème est rencontré.
La ligne en-dessous documente le _type d'erreur_ (ici, une _erreur de référence_)
et une indication (_la variable n'existe pas_). +
La notation `exit-error.js:5:13` indique que l'origine de l'erreur
se trouve à la _ligne 5_ du fichier `exit-error.js`, _colonne 13_.

Comment y remédier ?
En vérifiant si on appelle bien la bonne variable ou en la créant
avec la valeur attendue le cas échéant.

Les erreurs d'exécution sont pernicieuses elles sont parfois
provoquées après le démarrage de l'application :

[source,bash]
----
$ node runtime-error.js
setTimeout(() => console.log(secret.toLocaleUperCase()), 2000);
                                    ^
TypeError: secret.toLocaleUperCase is not a function
    at Timeout.setTimeout [as _onTimeout] (/.../chapter-04/examples/runtime-error.js:4:37)
----

Ici, l'erreur est délenchée deux secondes après le démarrage du script,
quand Node entre dans le _callback_ de la fonction `setTimeout`.

Le type d'erreur indique que l'on fait appel à un élément inexistant
(la fonction `toLocaleUperCase`) rattaché à un élément existant (`secret`). +
La notation `runtime-error.js:4:37` indique que l'origine de l'erreur
se trouve à la _ligne 4_ du fichier `runtime-error.js`, _colonne 37_.

Pourquoi `toLocaleUperCase` n'est pas une fonction ?
Car une typo s'est introduite dans notre code :
c'était à la <<../chapter-03/index.adoc#string,fonction de chaînes>>
`toLocaleUpperCase` (avec 2 _p_) qu'on pensait faire appel.

[TIP]
.[RemarquePreTitre]#npm# Module `eslint`
====
Le module npm `eslint` ([URL]#https://npmjs.com/eslint#)
est un vérificateur syntaxique.
Ses réglages l'emmènent à chercher des conditions défavorables dans le code
comme des oublis de vérification d'erreur ou des usages exotiques du langage
qui entrainent des problèmes difficiles à déceler.

On apprendra à le configurer dans l'<<../appendix-a/index.adoc#eslint,annexe A>>.
====

Les erreurs affichées affichent des informations importantes.
Si elles n'indiquent pas forcément le chemin de résolution évident,
elles demandent à ce qu'on cherche à *comprendre la nature de l'erreur*.

[TIP]
.[RemarquePreTitre]#npm# Module `pretty-error`
====
Le module npm `pretty-error` ([URL]#https://npmjs.com/pretty-error#) enjolive
l'affichage des erreurs.
Il suffit de l'installer, de le <<require,précharger>> et
d'exécuter un script pour en bénéficier.

[source,bash]
----
$ node -r pretty-error/start process/exit-error.js
----

On apprendra au <<../chapter-05/index.adoc#,chapitre 5>> comment installer
des modules npm.
====

== Les différences de JavaScript entre Node et les navigateurs web

Puisqu'on utilise du code JavaScript avec Node et avec les navigateurs web,
qu'est-ce qui les distingue vraiment ?
Après tout, on pourrait rêver d'écrire un JavaScript universel qui fonctionne
partout mais il semblerait que ça ne soit pas le cas.

Cette section détricotte les derniers doutes que l'on pourrait avoir dans notre tête.

=== L'absence du DOM et des variables `window` et `document`

Dans Node, il n'est pas possible de faire appel aux variables `window`
et `document` (raccourci pour `window.document`).

Ces variables représentent respectivement la fenêtre/onglet et le document
HTML interprété par le navigateur web.
L'appel aux fonctions `document.querySelector()` et `document.createElement()`
relèvent du DOM (_Document Object Model_), une représentation JavaScript interactive
du document HTML.

L'équivalent de `window` pour Node serait la variable <<process,`process`>> :
elle décrit le processus exécutant notre code.

[NOTE]
.[RemarquePreTitre]#Documentation# Variables globales
====
La documentation des variables globales est disponible sur le site officiel de Node :
[URL]#https://nodejs.org/docs/latest-{nodeCurrentVersion}.x/api/globals.html#
====

=== Il n'y a pas d'interface graphique

Suite logique du point précédent : Node n'a pas d'interface graphique.
Le code exécuté n'affiche rien en tant que tel, à part les messages dirigés
vers la <<console,console>>.

Un moyen d'en savoir plus sur ce qui se passe dans les entrailles d'un script
est d'utiliser l'<<inspect,inspecteur Node>>.

On peut toutefois construire des applications graphiques en ligne de commande.
Nous verrons comment faire dans le <<../chapter-08/index.adoc#,chapitre 8>>.

=== Le mécanisme de modules

Node utilise un <<modules,mécanisme de modules>> (_CommonJS_) différent
des _modules ECMAScript_ des navigateurs web.

La convergence vers les _modules ECMAScript_ est en cours.
Il y a fort à parier qu'ils soient supportés nativement par Node dans une
version ultérieure.

Nous verrons comment utiliser les modules Node dans les navigateurs web
dans le <<../chapter-08/index.adoc#,chapitre 9>>.


=== L'interfaçage avec le système d'exploitation

Les fonctions JavaScript spécifiques aux navigateurs web sont liées
à la récupération d'informations (`AJAX`, `fetch()`),
à l'affichage (Canvas, WebGL, WebVR) ainsi qu'à la manipulation de documents HTML.

Les fonctions JavaScript fournies par les <<modules-builtin,modules Node>>
sont liées à la gestion des ressources dont le système d'exploitation
se fait l'interface : fichiers (<<fs,module `fs`>>),
réseau (<<http,module `http`>>, <<net,module `net`>>, <<dns,module `dns`>>,
<<dgram, module `dgram`>>), terminal (<<tty,module `tty`>>,
<<readline,module `readline`>>) et processus
(<<process,module `process`>>, <<child_process,module `child_process`>>).

=== Node est un processus système

Le système d'exploitation crée un nouveau processus dès
qu'on exécute le programme `node`.
Ce processus peut être de _courte durée_ ou de _longue durée_,
selon qu'il dure quelques secondes ou plusieurs heures… voire
plusieurs jours ou un temps indéfini.

Le processus s'arrête en cas d'erreur, lorsqu'il n'y a plus d'opération
à effectuer ou en cas d'interruption volontaire.

Le code JavaScript exécuté dans un navigateur web dépasse rarement la durée
d'une session utilisateur, de quelques secondes à quelques heures.
En cas de problème, un rafraîchissement de la page

[NOTE]
.[RemarquePreTitre]#Performances# Utilisation des CPU
====
Un *processus Node est _mono_ CPU*.
Tous les autres processus système assignés à ce même CPU
se partageront une quantité finie de puissance.

Par exemple, si un processus Node partage le même CPU qu'une base de données
et qu'une requête gourmande s'exécute, la rapidité de notre application
en sera affectée.
====

[[options]]
== Options utiles pour démarrer Node


Cf. https://nodejs.org/api/cli.html
Compatible aussi avec `NODE_OPTIONS`

[[print-eval]]
=== Afficher le résultat d'une expression

L'interpréteur Node sait interpréter du code qu'on lui donnerait
via l'option `-p` (pour _print_, c'est-à-dire _afficher_).
L'interpréteur affichera le résultat de l'expression ou
détaillera la <<errors,raison de l'erreur>>.

J'utilise cette forme d'interaction pour obtenir un résultat rapide,
sans créer de nouveau fichier.
Par exemple, le résultat d'une opération mathématique :

[source,bash]
----
$ node -p '2 + 2'
4
----

Toute expression ECMAScript valide est acceptée :

[source,bash]
----
$ node -p '"abc".toLocaleUpperCase()'
ABC
----

Ce dernier exemple illustre la transformation de
<<../chapter-03/index.adoc#string,chaîne de caractères>> documentée
dans le <<../chapter-03/index.adoc#,chapitre 3>>.

[[require]]
=== Précharger un module

L'option de démarrage `--require` charge le module indiqué _avant_ le script Node.

[source,bash]
----
$ node --require ./print-exit.js url/intro.js
----

Dans cet exemple, le <<modules,module `print-exit.js`>> sera chargé
avant `url/intro.js`.

[source%interactive,javascript]
.print-exit.js
----
include::{sourceDir}/print-exit.js[]
----

Le chargement de ce module aura pour effet d'afficher un message
avec le chemin du fichier chargé et le <<process.exit,code de sortie>>.

On peut appeler l'option `--require` plusieurs fois.
On peut aussi utiliser l'option raccourcie `-r`.

Ce mécanisme fonctionne très bien avec des
<<../chapter-05/index.adoc#,modules npm>> conçus pour
rendre nos scripts <<esm,compatibles avec les modules ECMAScript>>
ou pour <<pretty-error,simplifier les erreurs>> affichées
lors d'un plantage applicatif, entre autres.

[[inspect]]
=== Inspecter notre code avec Google Chrome

Node accepte deux options `--inspect` et `--inspect-brk`.
Elles exposent toutes deux un protocole de débogage
auquel on peut se connecter avec le navigateur _Google Chrome_.

[source,bash]
----
$ node --inspect-brk print-text.js texte --uppercase
Debugger listening on ws://127.0.0.1:9229/ddd9bbfd-09ac-4426-a53e-c8abe4fc36da
For help see https://nodejs.org/en/docs/inspector
----

Cette commande lance un de nos exemples de la section
<<process.argv,arguments d'exécution>> du <<process,module `process`>>.
L'option `--inspect-brk` démarre l'inspecteur
et met son *exécution en pause aussitôt*.

Le logo de Node s'affiche dans les outils de développement de _Google Chrome_ :

.Outils de développement _Google Chrome_ avec l'icône de l'inspecteur Node.
image::images/chrome-devtools.png[width="85%"]

Un clic sur le logo Node ouvre une nouvelle fenêtre.
Cette fenêtre est outillée pour inspecter ce qu'il se passe dans notre script Node.

.Inspecteur en pause sur la première ligne de notre script Node.
image::images/inspector-paused.png[width="85%"]


[TIP]
.[RemarquePreTitre]#Outils de développement# Point d'arrêt
====
Un point d'arrêt se crée en cliquant sur le numéro de ligne souhaité.

Le débogueur se mettra en pause dès à chaque fois que le chemin d'exécution
de l'interpréteur atteindra cette ligne.

La valeur des variables ECMAScript courantes s'affichent au survol de la souris
ou en interagissant avant la console.
====

.Inspecteur en pause, avec un point d'arrêt marqué sur une des lignes du script.
image::images/inspector-breakpoint.png[width="85%"]

C'est le moment idéal pour placer un ou plusieurs points d'arrêt.

Un clic sur le bouton btn:[&#9654;] met alors fin à la pause.
Le script s'exécutera jusqu'à l'épuisement des instructions
ou jusqu'au _prochain point d'arrêt_.

.Inspecteur en pause, suite à la rencontre d'un point d'arrêt.
image::images/inspector-breakpoint-in.png[width="85%"]

L'option d'invocation `--inspect` est adaptée à des processus de longue durée,
comme un serveur HTTP.
L'option `--inspect-brk` est adaptée à des processus de courte durée et qui
se termineraient avant qu'on aie eu le temps de jeter un œil au contenu.


[[deprecation]]
=== Afficher les alertes de dépréciation

Un des objectifs de l'équipe de développement de Node est de maintenir
la stabilité de la plate-forme.
Il arrive que certains choix de conception soient revisités en changeant
leur comportement ou en les retirant des modules de base.

Dans ce dernier cas, le retrait n'est pas immédiat.
*Le retrait est précédé par une dépréciation*.

L'exemple suivant illustre une utilisation dépréciée par Node :

[source,javascript]
.deprecation-warning.js
----
include::{sourceDir}/deprecation-warning.js[]
----

[source,bash]
----
$ node deprecation-warning.js
----

Les dépréciations sont masquées par défaut et affichées lorsqu'on utilise
l'option `----pending-deprecation` :

[source,bash]
----
$ node --pending-deprecation deprecation-warning.js
(node:8130) [DEP0005] DeprecationWarning: The Buffer() and new Buffer() constructors are not recommended for use due to security and usability concerns. Please use the new Buffer.alloc(), Buffer.allocUnsafe(), or Buffer.from() construction methods instead.
----

Cette option Node est à utiliser après avoir migré vers une nouvelle version
majeure de Node.
Ça nous laissera le temps de corriger les erreurs avant une prochaine
grosse mise à jour.

=== Ajuster les options de compatibilité et de traçabilité de V8

Node repose sur la <<../chapter-01/index.adoc#v8,machine virtuelle V8>>
pour interpréter nos instructions ECMAScript.
Node expose différentes options de V8 pour affiner son comportement en fonction
de notre environnement.

L'intégralité des options de configuration de V8 s'affiche
avec l'option `--v8-options` :

[source,bash]
----
$ node --v8-options
----

Il n'y a pas de _meilleure configuration_ qui conviendrait à chacun de nos usages.
Le mieux reste encore d'explorer les options possibles, les différents concepts
et d'ajuster les valeurs offrant le meilleur rapport stabilité/performances.

.Options notables de V8
`--optimize_for_size`::
  Optimise le fonctionnement interne pour utiliser moins de mémoire,
  au détriment de la vitesse. +
  Idéal pour l'exécution de scripts Node sur des environnement à faible mémoire,
  comme les Raspberry Pi.
`--mem_old_space_limit`::
  Détermine la quantité de mémoire maximale qu'un processus Node pourra utiliser. +
  Idéal pour confiner Node sur des environnements à faible mémoire.
`--gc_inverval`::
  Détermine le nombre de cycles entre chaque déclenchement du ramasse-miettes mémoire.
`--expose_gc`::
  Expose les fonctions de manipulation du ramasse-miettes mémoire. +
  Idéal si vous souhaitez contrôler finement l'optimisation de la mémoire.
`--stack_trace_limit`::
  Change la limite du nombre de lignes affichées dans une trace d'erreurs. +
  Par défaut : 10 lignes.
`--trace-deopt`::
  Signale les optimisations invalidées par V8.
  Les portions de code indiquées gagneraient à être retravaillées, pour rendre
  uniforme le type de variables passées en arguments par exemple.
`--trace-gc`::
  Signale les moments où le ramasse-miettes se déclenche.
  On peut ainsi mieux comprendre les raisons qui le pousse à se déclencher.

Les options préfixées par `harmony` activent la prise en charge
de fonctionnalités ECMAScript qui ne font pas encore partie du standard.
Elles sont encore au stade expérimental.

== Conclusion

TBD.

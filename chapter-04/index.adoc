:chapterNumber: 4
:sourceDir: ./examples
:sourceSample: modules/node-timer.js
:httpRoot: http://localhost:4000/examples
:nodeCurrentVersion: v6
:npmCurrentVersion: v4
:sectnums:
:revdate: {docdate}
:imagesdir: {indir}
ifdef::env[]
:imagesdir: .
endif::[]

= Développer pour les navigateurs web

La popularité de Node s'est établie également pour la profusion d'outillage apportée au développement web _frontend_.

Ce chapitre nous apprendra le rôle de Node en tant qu'extension au développement _frontend_.

====
.Sommaire
- Gérer les dépendances externes
- Créer des interfaces réactives
- Partager du code entre Node et le navigateur
- Automatiser des tâches pénibles et répétitives
- Automatiser les tests navigateurs
====

Avant l'apparition de Node, rare était l'outillage n'imposant pas une ou plusieurs plates-formes de développement : _YUICompressor_ demandait Java, _Google Closure Compiler_ demandait Java, _sprockets_ Ruby et _pngquant_ quelques dépendances système comme _libpng_.

Leur installation n'était pas triviale.
Leur coordination encore moins.
Les adapter aux différents systèmes d'exploitation et au système d'intégration continue n'était pas non plus aisé. +
Bref c'était lourd, complexe et compliqué à moins de disposer d'une infrastructure industrialisée.

L'existence de Node et du registre _npm_ a favorisé le développement d'un écosystème orienté _frontend_.
Cela s'étend de la découverte au téléchargement des bibliothèques tierces ainsi qu'à la compilation, l'optimisation et l'exécution des tests des applications web côté client.

include::../resources/tip-versions.adoc[]
include::../resources/tip-examples.adoc[]

toc::[]

== Éxécuter Node dans les navigateurs web ?

Ce chapitre peut sembler confus au premier abord.
Si Node s'exécute au niveau du système d'exploitation — "côté serveur" — en quoi est-il lié au développement _frontend_ — "côté client" ?
Est-ce parce que du code écrit pour Node peut aussi fonctionner dans un navigateur web ?
_Quid_ de l'utilisation de `require('fs')` pour accéder au système de fichiers ?

La réponse _courte_ est : *nous n'exécutons pas Node dans un navigateur web*.

Et la réponse _longue_ : *Node est utilisé pour assembler du code*, le _transformer_ et le rendre fonctionnel dans une paire de balises `<script></script>`. +
Ce code peut être aussi bien fourni par des *librairies tierces* installées via _npm_ (_jQuery_, _React_ ou _d3_ par exemple) que par de l'*outillage* (optimiseurs, suite de tests, orchestration de tâches etc.) ou encore par le *code réutilisable* de notre propre application web.

Il faut également bien comprendre qu'il y a plusieurs "problèmes" cachés sous une même question :

- Les navigateurs web et Node utilisent différentes machines virtuelles JavaScript, avec différents niveaux de complétion dans l'implémentation d'_ECMAScript_ ;
- Les navigateurs web et Node n'ont pas accès aux mêmes APIs – Node accède à `fs` et `http` tandis que les navigateurs ont `File` et `fetch`/`XmlHttpRequest` ;
- Les navigateurs web et Node ne gèrent pas le chargement de modules de la même manière – voir la section <<managing-dependencies,gestion des dépendances>> ;
- L'implémentation même d'_ECMAScript_ va différer selon les versions de Node employées – un navigateur moderne et Node 6 comprendraient l'objet natif `Promise` mais pas Node 0.12.

Ce processus n'est _pas magique_ et nous verrons graduellement au cours des prochaines sections comment tout ceci fonctionne.


== Écrire dès à présent le code du futur

Transformer du code ECMAScript a pendant longtemps été chose pénible.
Je pense par exemple à de la minification de code (pour réduire les temps de transfert sur les antiques lignes ADSL 128K) ou à de la conversion automatique de code _ECMAScript 3_ en _ECMAScript 5_.
Cela nécessitait systématiquement l'utilisation d'un autre environnement qu'ECMAScript lui-même: Rhino nécessitait Java, Spidermonkey nécessitait C++ et Trident nécessitait un environnement Windows en plus de C++.

*esprima* chamboule les règles du jeu en décembre 2011 : ce parseur _ECMAScript_ — lui-même écrit en _ECMAScript_ – exporte une compréhension de code sous forme d'arbre syntaxique abstrait (_abstract syntax tree_, _AST_).
Cet arbre est lui-même analysable par de *nouveaux outils émergents* :

- les _source maps_ pour associer le code transformé au code d'origine, notamment dans les outils de développement des navigateurs web ;
- des _minifieurs_ plus efficaces et ayant connaissance des portions de code exécutées ;
- des _analyseurs de code_ pour informer le développeur d'erreurs de syntaxe, de non-respect de styles de développement etc. ;
- des _convertisseurs de code_ pour passer d'_ECMAScript_ vers _CoffeeScript_, de modules _CommonJS_ vers des modules _ECMAScript 2015_ etc.

[TIP]
.[RemarquePreTitre]#Lien# Annonce d'_esprima_
====
_Aryia Hidayat_ introduit esprima dans un billet de blog.
Il y présente notamment des comparatifs de performances d'exécution sur différentes VM ECMAScript et face à d'autres parseurs.

- [URL]#https://ariya.io/2011/12/introducing-esprima#
====

Le champ d'action de Node augmente, la versatilité d'_ECMAScript_ aussi. +
Toutefois si on ne devait retenir qu'une chose de tout ceci c'est qu'il est désormais normal d'*écrire du code moderne en anticipation des futurs standards et de le faire fonctionner sur les navigateurs actuels et anciens*.

=== La fin de l'approche par le dénominateur commun

Qui n'a pas déjà entamé un projet en posant la question à un client, en regardant les statistiques de traffic ou en se posant une question à soi-même : quelle est la liste des versions de navigateurs avec lequel notre site ou application web doit être compatible ?

La version de navigateur la plus ancienne ou la moins conforme aux standards était celle qui donnait le _la_ (qui a prononcé _Internet Explorer 7_ dans la salle ?). +
Cela voulait dire se priver de techniques modernes, standardisées ou en cours en de standardisation.
Cela voulait dire des _hacks_ dans ses CSS, dans son code _ECMAScript_ et dans ses ressources graphiques.

Alors que dire si on inclut une librairie tierce qui fait l'affaire mais n'offre pas une compatibilité aussi antique que désirée ?

[[transpilation]]
=== Écrire au plus proche des standards

Fort heureusement l'arrivée d'_esprima_ a changé la donne et permet d'écrire un code proche des standards, qui résiste au temps et d'automatiser les transformations de code pour satisfaire nos besoins spécifiques.

Il y a plusieurs éléments à prendre en compte concernant la standardisation de nouvelles versions d'_ECMAScript_ et les évolutions de sa syntaxe :

. la *cadence de standardisation* a été revue pour devenir prédictible – une volonté d'une fois par an ;
. les *fonctionnalités et éléments de syntaxe sont implémentés un par un*, à des vitesses différentes par les différents concepteurs de navigateurs web ;
. les navigateurs majoritaires fonctionnent sur des *rythmes de mises à jour en cycle court* – on parle de six à neuf semaines pour la plupart.

Il vaut mieux *parier sur les standards comme stratégie à long terme* si on tient compte du _temps de développement_ et du _temps de maintenance_ d'une base de code.

[TIP]
.[RemarquePreTitre]#Question# Standards, quels standards ?
====
Il y a plusieurs organismes prenant part à la standardisation de langages et d'APIs lorsque l'on touche aux navigateurs web :

- Pour le _langage HTML_ : WHATWG ([URL]#https://html.spec.whatwg.org/#) ;
- Pour l'_API DOM_ : WHATWG ([URL]#https://dom.spec.whatwg.org/#) ;
- Pour le _langage CSS_ : W3C ([URL]#https://www.w3.org/standards/techs/css#) ;
- Pour le _langage ECMAScript_ : TC39 ([URL]#https://github.com/tc39#) ;
====

Lorsque nous écrivons du code, nous pouvons rencontrer quatre cas de figure :

- *élément de syntaxe non-implémenté* : transformer le code pour l'adapter aux navigateurs cibles ;
- *élément de syntaxe partiellement implémenté* : utiliser l'implémentation native des navigateurs et à défaut, transformer le code pour l'adapter aux autres navigateurs ;
- *élément de syntaxe totalement implémenté* : utiliser l'implémentation native des navigateurs.

Il arrive que certains éléments de syntaxe soient *abandonnés* pendant le processus de standardisation – ou que leur implémentation change beaucoup (on pensera à `Object.observe`).

La question qui nous taraude est : *comment transformer le code* pour satisfaire à la fois les navigateurs compatibles et les autres ? +
*Babel* est un outil de choix  pour parvenir à ces fins d'écriture de code résistant au(x standards du) temps.

Ce module convertit de manière sélective toute syntaxe _ECMAScript 2015_ – ainsi que _ECMAScript 2016_, etc. – vers de l'_ECMAScript 5_, compréhensible par les _navigateurs web modernes_.
L'intérêt de sa _sélectivité_ fait que l'on peut progressivement arrêter de convertir les éléments de syntaxe couverts par 100% des navigateurs web modernes.

[TIP]
.[RemarquePreTitre]#Histoire# Traceur
====

_Traceur_ est un des premiers transpilateurs _ECMAScript 2015_ vers _ECMAScript 5_ à avoir émergé dans l'écosystème Node.

Il a permis de commencer à *écrire des modules en _ECMAScript 2015_ bien avant que la spécification ne soit entièrement terminée*.
Et donc de pouvoir anticiper son apprentissage tout en mettant le langage à l'épreuve avant sa finalisation.
====

L'exemple suivant illustre un code utilisant des éléments de syntaxe d'_ECMAScript 2015_.

[source,javascript]
.babel-es2015.js
----
include::{sourceDir}/babel-es2015.js[]
----
<1> Nous destructurons l'_agent utilisateur_ du navigateur – à noter que ce même code exécuté par Node lancerait une exception car `window` n'existe pas dans cet environnement ;
<2> Affiche un objet content le _nom_ de votre système d'exploitation ainsi que sa _version_.

Ce code représente l'*idéal de ce que l'on souhaite écrire*.
Le seul obstacle consiste à _traduire_ ce code pour l'ensemble des navigateurs web compatibles avec _ECMAScript 5_.

Exécutons cette commande :

----
$ npm run babel -- --no-babelrc examples/babel-es2015.js
----

La sortie affichée correspond _exactement_ à notre code d'origine.
C'est parce que sans configuration, _babel_ ne transforme rien. +
L'ouvrage contient un fichier de configuration `.babelrc`.
Nous expliquerons son contenu après en avoir observé son impact :

----
$ npm run babel -- examples/babel-es2015.js
----

La sortie a changé et renvoie un code totalement fonctionnel sur des navigateurs web ne supportant pas _ECMAScript 2015_ :

[source,javascript]
.babel-es2015ified.js
----
include::{sourceDir}/babel-es2015ified.js[]
----

Il existe de nombreuses règles de transformation mais heureusement pour nous, des modules _npm_ nous permettent de *choisir quels éléments de syntaxe transformer*.
Ce sont les _presets_.

Voici quelques _presets_ qui nous seront utiles :

- `preset-env` ([URL]#https://github.com/babel/babel-preset-env#) ;
- `preset-es2015` ([URL]#https://babeljs.io/docs/plugins/preset-es2015/#) ;
- `preset-es2016` ([URL]#https://babeljs.io/docs/plugins/preset-es2016/#) ;
- `preset-es2017` ([URL]#https://babeljs.io/docs/plugins/preset-es2017/#) ;
- `preset-latest` ([URL]#https://babeljs.io/docs/plugins/preset-latest/#).

Ils sont à placer dans un fichier de configuration nommé `.babelrc` :

.{empty}.babelrc
----
{
  "presets": [
    "es2015",
    "es2016"
  ]
}
----

[TIP]
.[RemarquePreTitre]#Lien# Documentation de _babel_
====
Une liste d'options ainsi qu'une aide à la configuration sont disponibles sur le site officiel de _babel_ :

- [URL]#https://babeljs.io/docs/usage/api/#options#
- [URL]#https://babeljs.io/docs/usage/babelrc/#
====

[[polyfills]]
=== Combler les manques avec des _polyfills_

Des outils comme _babel_ nous permettent d'écrire avec une *syntaxe moderne*.
Les *polyfills* nous permettent de *combler les fonctionnalités manquantes*, leur implémentation.

La déstructuration, les constantes et les classes sont des _éléments de syntaxe_ d'_ECMAScript 2015_.
L'objet `Promise` et la méthode `Array.from` sont des _fonctionnalités_ d'_ECMAScript 2015_.
La fonction `fetch`, l'objet `File` et l'API `WebSocket` sont des _fonctionnalités_ d'_HTML5_.

Un *polyfill nous garantit la présence d'une fonctionnalité*, peu importe l'ancienneté du code et du navigateur l'exécutant.

[TIP]
.[RemarquePreTitre]#Guide# Bonnes pratiques constatées
====
Un guide édité par le W3C explique les bons usages et risques d'utilisation des _polyfills_ et de leur utilisation constatée sur le web.

- [URL]#https://w3ctag.github.io/polyfills/#
====

Prenons le bloc de code suivant :

[source,javascript]
----
'use strict';

Promise.resolve('ok');
----

Comprenons que :

- cette syntaxe est *valide dans toutes les versions* d'_ECMAScript_ (_babel_ ne changera rien à ce code) ;
- l'objet global `Promise` existe dans un navigateur moderne ;
- l'objet global `Promise` n'existe pas dans _Internet Explorer 9_, entre autres.

Ce code fonctionnerait sur un navigateur moderne mais pas dans _IE9_.
L'inclusion d'un _polyfill `Promise`_ résoudrait le problème.

Parlons maintenant des méthodes d'inclusion des _polyfills_ pour mieux comprendre comment procéder.

Le *service polyfill.io* est de loin la méthode la plus simple à utiliser.
Il suffit d'inclure un script dans toutes vos pages web.
_polyfill.io_ déterminera les _polyfills_ à charger en fonction de la compatibilité du navigateur chargeant la page :

[source,html]
.polyfill.io.html
----
include::{sourceDir}/polyfill.io.html[]
----

[TIP]
.[RemarquePreTitre]#Documentation# polyfill.io
====
_polyfill.io_ possède une documentation très complète et illustrative de son fonctionnement.
Elle vous aidera à configurer finement le service en fonction de vos besoins.

- [URL]#https://qa.polyfill.io/v2/docs/#
====

Nous pouvons déduire *deux règles* de l'exemple précédent :

. inclure les _polyfills_ en *tout premier* ;
. inclure les _polyfills_ *en dehors* de notre code.

La deuxième méthode est d'*embarquer les polyfills* dans notre base de code.
L'avantage est de maitriser notre base de code et de ne pas dépendre d'un service externe.
L'inconvénient est que nous chargeons du code qui sera inutile les navigateurs et environnements disposant déjà de ces fonctionnalités :

[source,html]
.polyfill-import.html
----
include::{sourceDir}/polyfill-import.html[]
----
<1> Nous verrons <<modules,comment importer des modules>> ci-après ;
<2> On importe un deuxième _polyfill_, celui de la méthode `Number.isNaN`.

Le module _npm_ `core-js` est une librairie exhaustive de _polyfills_ pouvant être inclus un à un ou par versions d'_ECMAScript_.

[TIP]
.[RemarquePreTitre]#Documentation# `core-js`
====
La documentation en ligne de `core-js` liste l'ensemble des _polyfills_ supportés par ainsi que des exemples d'utilisation.

- [URL]#https://npmjs.com/core-js#
====

_babel_ et son _preset_ `babel-preset-env` nous facilitent l'inclusion de _polyfills_ selon la compatibilité navigateurs que l'on souhaite maintenir au sein de notre application. Le fichier `.babelrc` suivant configure l'inclusion des _polyfills_ à l'aide des clés `useBuiltIns` et `targets` :

[source,javascript]
.{empty}.babelrc
----
include::{sourceDir}/.babelrc[]
----

Cette configuration illustre un souhait de compatibilité avec _Internet Explorer 9_ et les navigateurs web disposant d'une part de marché supérieure à 5%.

[CAUTION]
.[RemarquePreTitre]#Attention# Performance et duplication
====
Il faut veiller à ne pas alourdir inutilement une application.

Laissons la responsabilité de _polyfiller_ aux utilisateurs de notre code ; particulièrement si celui-ci est *redistribué* en tant que module _npm_ public.

Si plusieurs scripts nécessitent des polyfills, mieux vaut inclure ces derniers _en une fois fois_ et _en premier_ :

[source,html]
----
<script src="polyfills.js"></script>
<script src="script-a.js"></script>
<script src="script-b.js"></script>
----
====

Enfin, une dernière méthode est l'*appel explicite de _polyfill_*.
Nous faisons une référence _explicite_ au polyfill mais à l'inverse, nous ne modifions pas les objets globaux :

[source,javascript]
.polyfill-require.js
----
include::{sourceDir}/polyfill-require.js[]
----

[[typescript]]
=== Écrire dans un autre langage : l'exemple TypeScript

TBD.

[[modules]]
== Importer des modules

Importer des modules est une pratique courante avec Node.
Ça l'est en revanche beaucoup moins dans l'univers du web puisqu'il n'existait rien de _natif_ avant les <<modules-es2015,modules ECMAScript 2015>>.

Auparavant, on aura vu débarquer les modules _AMD_ (_Asynchronous Module Definition_) pour gérer les dépendances _entre scripts_.
Les librairies _Dojo_, _RequireJS_ et _YUI_ ont popularisé ce motif de conception.
Un désir d'universalité a ensuite émergé avec le gain de popularité croissant de Node avec les modules _UMD_, conciliant modules _AMD_ et _CommonJS_.

Les modules _ECMAScript 2015_ ont émergé de ce bouillonnement.

[[modules-script]]
=== La balise `<script>`

Rappelons-le, la méthode incontournable pour charger du code dans un navigateur web est l'utilisation de la base `<script>`.
Le chargement puis l'évaluation et l'exécution du script bloque le temps nécessaire le rendu d'un document HTML.

[source,html]
.import/script.html
----
include::{sourceDir}/import/script.html[]
----

Les différents _scripts_ partagent le même espace mémoire, permettant ainsi à `script.js` d'avoir accès à la fonction `log` définie dans `global-dom-log.js`.

[source,javascript]
.import/global-dom-log.js
----
include::{sourceDir}/import/global-dom-log.js[]
----

[source,javascript]
.import/script.js
----
include::{sourceDir}/import/script.js[]
----
<1> Affiche une erreur car `<div id="logs">` n'existe pas encore dans le document à ce stade de l'exécution ;
<2> Cette ligne est exécutée une fois le document chargé – `<div id="logs">` contient désormais le texte `OK`.

S'il est facile d'ajouter du code dans le navigateur, on constate plusieurs problèmes :

- partager du code entre scripts repose sur une *attente explicite* ;
- le partage de variables entre scripts peut entrainer des *collisions* (par exemple, deux variables du même nom définies dans des scripts différents) ;
- il n'y a pas de moyen évident de rendre des bouts de code _privé_ au sein de chaque script.

Le développement frontend basé sur de l'outillage Node va justement nous aider à *solidifier et renforcer la réutilisabilité de notre code*.

[[modules-es2015]]
=== Les modules _ECMAScript 2015_

Nous avons évoqué les <<../chapter-02/index.adoc#primitives,primitives _ECMAScript 2015_>> dans le Chapitre 2.
Les modules font partie des fonctionnalités tant attendues.

.Utilisation des modules _ECMAScript 2015_ dans un navigateur web (ici, Safari pour macOS).
image::images/module-import.png[align="center",width="85%"]

L'attribut `type="module"` a été introduit pour maintenir une compatibilité entre scripts classiques et les modules _ECMAScript 2015_.
Ce mécanisme de modules introduit plusieurs concepts importants :

- *toute variable est privée* sauf si elle est _exportée_ avec l'opérateur `export` ;
- les *modules sont explicitement inclus* avec l'opérateur `import` ;
- les *variables globales* définies par l'utilisateur ne sont pas accessibles depuis un module.

Retravaillons le document HTML de la section précédente :

[source,html]
.import/import.html
----
include::{sourceDir}/import/import.html[]
----

Nous voulons maintenant (sa)voir si la variable `pro` définie avant l'inclusion du module `script-import.js` est constatée.
Nous voulons également savoir si la syntaxe d'import de la fonction `log` fonctionne :

[source,javascript]
.import/script-import.js
----
include::{sourceDir}/import/script-import.js[]
----
<1> Affiche `undefined` ;
<2> Affiche `function` ;
<2> Affiche `object`.

De même que nous avons utilisé `import` pour sélectivement importer une fonction du module `dom-log.js`, l'opérateur `export` nous aide à sélectivement exposer des objets, fonctions et variables :

[source,javascript]
.import/dom-log.js
----
include::{sourceDir}/import/dom-log.js[]
----

[[browserify]]
=== Importer des modules _npm_ pour le web

Qu'en est-il alors des modules _npm_ ?
Nous pouvons transpiler et importer du code, ce serait très utile si nous pouvions également importer du _code tiers_.
Cela nous éviterait de réinventer la roue, d'avoir accès à du code bien testé et trop coûteux à écrire nous-même.

Nous avons vu comment <<../chapter-02/index.adoc#api-require,charger des modules _npm_>> dans le Chapitre 2.
Si seulement nous pouvions faire la même chose côté client… +
Continuons sur la lancée de nos exemples précédents pour tenter d'inclure la librairie _jQuery_ afin de manipuler notre document HTML :

[source,javascript]
.import/script-import-jquery.js
----
include::{sourceDir}/import/script-import-jquery.js[]
----
<1> `$.fn.jquery` contient le numéro de version de jQuery ;
<2> Substitut jQuery pour remplacer le texte dans `<div id="logs">`.

Le document HTML chargeant ce module est en tout point similaire au précédent exemple :

[source,html]
.import/import-jquery.html
----
include::{sourceDir}/import/import-jquery.html[]
----

Le seul _hic_, c'est que *cela ne fonctionne pas* :

- le navigateur _ne peut pas savoir_ où se trouve la dépendance demandée ;
- rien ne garantit que `jquery` expose son code en tant que module _ECMAScript 2015_ ;
- on n'a certainement pas envie d'exposer publiquement le répertoire `node_modules`.

C'est alors qu'entre en jeu *browserify*.
_browserify_ est un outil générique de transformation de code.
Il peut être utilisé en ligne de commande, via son API Node mais aussi par le biais de plugins pour d'autres outils (comme Gulp, Grunt etc.).

_browserify_ a été initialement créé pour transformer du code écrit pour Node en code fonctionnel dans les navigateurs web.
Il expose notamment un concept d'intégrations (les _transforms_) afin d'effectuer des remplacements ligne à ligne.

Là où _babel_ cherche uniquement à traduire un langage vers un autre, _browserify_ est le couteau suisse pour effectuer des remplacements majeurs dans le code :

- portage de la fonction `require()` et inclusion du code des modules sous-jacents ;
- suppression de code conditionnel ;
- remplacement d'API spécifiques à Node par des polyfills pour le web ;
- extraction de CSS ;
- etc.

_browserify_ est intéressant au sens où il nous apprend à nous constituer nous-même notre outillage, pour nos propres besoins.

[TIP]
.[RemarquePreTitre]#Guide# Utiliser browserify
====
_browserify_ est un outil extrêmement versatile, modulaire et puissant.
Son apprentissage progressif peut faire de lui un allié de choix dans tous vos projets Node et web.

- [URL]#https://npmjs.com/browserify#
- [URL]#https://github.com/substack/browserify-handbook#
====

Revenons maintenant à notre code auquel il manque la compréhension des modules _npm_.
Nous allons maintenant chercher à transformer le fichier `script-import-jquery.js` pour à la fois rendre la syntaxe `import` intelligible par les navigateurs web (c'est le rôle de _babel_) mais aussi pour faire le lien avec les modules _npm_ :

----
$ npm run browserify -- \
  -t babelify \
  -e examples/import/script-import-jquery.js \
  -o examples/import/script-import-jquery-browserify.js
----

Cette commande exécute trois choses :

. `-t babelify` indique d'utiliser une intégration _babel_ (un _transform_) pour transformer la syntaxe _ECMAScript 2015_ ;
. `-e …` indique le script d'entrée à transformer ;
. `-o …` indique où stocker le script transformé.

Il en résultera un fichier nommé `script-import-jquery-browserify.js` compatible _ECMAScript 5_ et qui inclut désormais le code source de jQuery. +
Il ne nous reste plus qu'à charger le fichier transformé dans notre page web pour voir le résultat :

[source,html]
.import/import-jquery-browserify.html
----
include::{sourceDir}/import/import-jquery-browserify.html[]
----

=== Récapitulatif

En résumé, nous avons besoin de nous baser sur _deux ou trois outils_ pour écrire un code modulaire et compatible avec n'importe quel type de syntaxe :

- *babel* pour transformer la syntaxe ;
- des *polyfills* pour harmoniser les fonctionnalités ;
- *browserify* pour l'intégration avec les modules _npm_.

Ceux-ci ont l'avantage d'être _faciles_ à prendre en main, _modulaires_ et _évolutifs_.
Nous pourrons aussi nous tourner vers d'autres outils de transformation de code pour explorer d'autres horizons – et il en existe énormément : _webpack_, _rollup_, _broccoli_ etc.

== Conception modulaire

Un autre paradigme change avec la mise à disposition des modules et de l'outillage à disposition : le code que l'on écrit dépend surtout d'_ECMAScript_ et de l'environnement dans lequel on l'exécute, à savoir Node ou un navigateur web.

La section suivante s'intéresse à l'*évolution de d'écriture du code*, autrefois dirigée par la *structure du document* HTML vers un monde de *fonctions consommant des données*, transformées pour un type d'affichage, que ce soit HTML ou autre.

Nous illustrerons cette évolution au travers d'un exemple relativement simple : une balise HTML affichant l'heure dont nous actualisons le contenu toutes les secondes.

.Résultat de l'exemple développé dans les sections suivantes.
image::images/modules-time.png[align="center",width="85%"]

[TIP]
.[RemarquePreTitre]#Documentation# _jQuery_
====
Les exemples suivants se basent sur l'utilisation de la librairie _jQuery_.
Elle facilite la manipulation du _DOM_ tout en gérant les incompatibilités des différents navigateurs web.
Son utilisation est devenue moins dominante du fait d'une nette amélioration de la qualité de ces derniers.

- [URL]#https://api.jquery.com/#
- [URL]#http://learn.jquery.com/using-jquery-core/#
====

=== Le syndrome du plugin _jQuery_

Ce que j'appelle le "syndrome du plugin _jQuery_", c'est une combinaison des éléments suivants :

- création de *code métier inutilisable* en dehors de _jQuery_ ;
- *mélange de la présentation* des données et de l'organisation du code métier ;
- un code _aveugle_ car *éloigné de la structure HTML* nécessaire à son fonctionnement ;
- *fragilité* du code en cas de changement de la structure HTML associée ;
- en général, un code *difficilement testable* – difficile de ne pas aboutir à une interface boguée.

Voici un exemple de document HTML _fragile_ et _mélangeant_ tous les concepts en même temps.
Il est parfaitement valide mais illustre un ensemble de pratiques courantes que nous allons chercher à _désapprendre_.

[source,html]
.modules/jquery-plugin.html
----
include::{sourceDir}/modules/jquery-plugin.html[]
----

Maintenant que la structure HTML est définie, nous devons désormais écrire le code affichant l'heure dans un élément HTML toutes les secondes{nbsp}:

[source,javascript]
.modules/jquery-plugin.js
----
include::{sourceDir}/modules/jquery-plugin.js[]
----
<1> Ce bloc de code est exécuté toutes les secondes ;
<2> La donnée de _temps_ est obtenue chaque seconde par notre _plugin jQuery_ ;
<3> Certaines décisions métier sont mélangées avec l'affichage de la données _temps_ ;
<4> L'intervalle est déterminé par la _valeur de l'attribut "data-interval"_ ;
<5> Ce bloc de code est exécuté dès que le document HTML est prêt — toute sa structure HTML est disponible ;
<6> Le _plugin jQuery_ est appliqué à toutes les occurrences de `<time>` dans lequel le _plugin_ est exécuté.

Certains motifs illustrés dans la section <<modules,Importer des modules>> refont surface :

- variables globales : que faire si `jQuery` n'existe pas ?
- connaissance implicite du document : que faire si une personne tierce remplace la balise `<time>` par une autre balise ?
- code JavaScript piloté par le document : que faire si une personne tierce exprime l'intervalle en secondes et non en millisecondes ?

La faute n'est pas vraiment celle de _jQuery_ mais plutôt la notre — enfin, la _mienne_ icon:smile-o[].
Nous avons *mélangé règles de fonctionnement* (contenu de balise, classe CSS à ajouter/enlever) et données (date courante, parité des secondes, événement de mise à jour `setInterval`).

=== Vers une approche _jQuery_ composite

Nous allons maintenant reprendre les concepts appris précédemment et conserver le même outil, à savoir _jQuery_.
Certains outils encouragent de bons _motifs de conception_ et donnent la sensation de résoudre des problèmes.
Apprendre ces motifs et à capitaliser sur les outils que nous connaissons déjà peuvent nous emmener tout aussi loin.

[source,html]
.modules/jquery-app.html
----
include::{sourceDir}/modules/jquery-app.html[]
----

Le changement majeur réside dans la réorganisation du code applicatif{nbsp}:

[source,javascript]
.modules/jquery-app.js
----
include::{sourceDir}/modules/jquery-app.js[]
----
<1> Nous sélectionnons les éléments de la page à actualiser chaque seconde ;
<2> Nous définissons quoi faire avec les données transmises chaque seconde ;
<3> Nous démarrons un minuteur ;
<4> Le minuteur est une fonction externe, dont le comportement n'est pas régi par _jQuery_ ou autre librairie ;
<5> Cette fonction est responsable de l'affichage de _données_ dans un _élément HTML_ ;
<6> Cette fois-ci, nous nous contentons de seulement mettre à jour attributs et contenus – la logique métier a été déplacée dans le module `timer.js`.

Le code a été divisé en deux sections distinctes :

. celui qui décrit la *réaction à une donnée* ;
. *celui qui intègre* le minuteur avec les éléments du _DOM_.

Nous n'avons pas réellement besoin de savoir comment fonctionne le minuteur à ce niveau – nous avons juste besoin de pouvoir compter sur les données qu'il nous fournit.

[source,javascript]
.modules/timer.js
----
include::{sourceDir}/modules/timer.js[]
----
<1> Cette fonction (privée) est responsable de décrire le _temps présent_ sous forme d'une *structure de données* ;
<2> Cette _structure de données_ pourra retourner de nouvelles clés/valeurs sans remettre en cause le fonctionnement du code y ayant recours ;
<3> Le paramètre `onTick` est une fonction passée en argument qui sera appelée à chaque nouvel intervalle de temps ;
<4> La responsabilité de `timer` est de communiquer une nouvelle _structure de données_ à un intervalle de temps donné ;
<5> On retourne immédiatement une structure de données par commodité et de manière synchrone.

Pour un résultat identique, nous avons désormais séparé notre code en trois *domaines distincts* : le _minuteur_, l'_intégration_ du minuteur, la _représentation_ du minuteur sous forme HTML.
Cerise sur le gâteau, cette _distinction se constate visuellement_, au premier coup d'œil.

Tout n'est pas parfait car nous sommes encore lié à la structure du document HTML.

=== Partager le code métier avec Node

Cette _séparation de principes_ (_separation of concerns_) va au-delà du plaisir de l'esthète.
Nous venons sans le savoir de créer du *code _ECMAScript_ universel*.

Pourquoi _universel_ ?
Parce que nous pouvons tout aussi bien l'inclure et l'exécuter dans Node que dans un navigateur web :

[source,javascript]
.modules/node-timer.js
----
include::{sourceDir}/modules/node-timer.js[]
----

L'exécution du script `node-timer.js` afficherait quelque chose du genre dans votre terminal :

----
$ node examples/modules/node-timer.js
{ now: 2017-02-17T11:07:29.752Z, className: 'impair' }
{ now: 2017-02-17T11:07:30.762Z, className: 'pair' }
{ now: 2017-02-17T11:07:31.768Z, className: 'impair' }
{ now: 2017-02-17T11:07:32.770Z, className: 'pair' }
{ now: 2017-02-17T11:07:33.775Z, className: 'impair' }
{ now: 2017-02-17T11:07:34.779Z, className: 'pair' }
^C
----

Chaque seconde, la fonction `console.log` est appelée et affiche la _structure de données_ de notre minuteur dans la _sortie standard_ du terminal.

Nous pourrions dès à présent utiliser le minuteur dans d'autres applications, côté client, côté serveur et pourquoi pas un jour, le publier sur le _registre npm_.

=== Séparation du fond et de la forme : données, rendu et interactions

Les praticien·ne·s de l'intégration web nous le dirons souvent : il faut *séparer le fond de la forme*.
Il en est de même dans notre code – et pas que pour le développement _frontend_.

Un code maintenable n'a pas besoin d'être complexe.
Un code maintenable a surtout besoin de bien _isoler_ ses périmètres d'intervention.

Les exemples précédents nous ont permis de déceler trois périmètres phares :

- *données* : des structures prédictibles, obtenues ou modifiées ;
- *rendu* : la représentation des données en _contexte_, que ce soit une page HTML, un terminal ou un fichier CSV ;
- *interactions* : des événements déclenchés par les utilisateurs, par des facteurs externes ou des règles métier – ils impactent les _données_ et leur _représentation_.

[[react]]
=== Rapprocher données, rendu et interactions avec _React_

_React_ a atteint un pic de popularité certain en 2015 et 2016.
Pas seulement parce qu'il s'agit d'un outil bien conçu mais justement parce qu'il encourage cette pratique de la *représentation des données*.

[TIP]
.[RemarquePreTitre]#Documentation# API React
====
Les exemples suivants se basent sur la librairie _React_.
Sa documentation offre de bons exemples pour se familiariser avec son utilisation.

- [URL]#https://facebook.github.io/react/#
- [URL]#https://facebook.github.io/react/docs/thinking-in-react.html#
====

Notre code HTML n'est qu'un *résultat* exposant des *surfaces d'interaction*.
Notre code se structure en *composants*.
Un _composant_ est responsable de deux choses : la *représentation de données* et la *réaction à des événements*.

Cela se traduira par un changement de taille : l'exemple que nous avons fait évoluer ne fait plus mention de balise `<time>` mais expose une balise dédiée à contenir notre _composant minuteur_ :

[source,html]
.modules/react-app.html
----
include::{sourceDir}/modules/react-app.html[]
----

Notre code applicatif est réduit à son plus strict minimum :

[source,javascript]
.modules/react-app.js
----
include::{sourceDir}/modules/react-app.js[]
----
<1> Méthode responsable du rendu HTML de notre composant `TimeInterval` dans l'élément `<div id="app">` ;
<2> Création de notre composant minuteur avec un intervalle de mise à jour de 1000 millisecondes ;
<3> Indication que le rendu du composant sera effectué _dans_ l'élément `<div id="app">`.

Cela ressemble fortement au contenu de nos précédentes invocations de `$(document).ready()` mais sans avoir à se soucier du fonctionnement interne du minuteur.

La représentation et le fonctionnement du minuteur sont désormais regroupés dans un seul composant :

[source,jsx]
.modules/date-interval.jsx
----
include::{sourceDir}/modules/date-interval.jsx[]
----
<1> Nous exportons un composant _React_ grâce à l'opérateur _ECMAScript 2015_ `extends` – cf. la <<../chapter-02/index.adoc#primitive-class,section Class du Chapitre 2>> ;
<2> Le `constructor` est exécuté quand le composant est rendu dans le document ;
<3> La propriété `interval` nous est fournie dans `react-app.js` et nous stockons la _structure de donnée_ retournée par le minuteur tout en déclenchant son actualisation toutes les 1000 millisecondes ;
<4> À chaque intervalle, nous mettons à jour la valeur `tickData` de l'état interne du composant (`this.state`) ;
<5> La méthode `render()` est exécutée quand le composant est inséré dans un document pour la première fois et dès que l'état interne (`this.state`) change ;
<6> Nous déstructurons la valeur connue de `tickData` pour effectuer une opération qui nous rappelle les différents appels à `.attr('class')` et `.text()` de _jQuery_.

_React_ introduit quatre concepts au sein des composants :

- un *cycle de vie* basé sur des _propriétés_ (_props_) et un _état interne_ (_state_) ;
- des *propriétés immutables* pour le paramétrage initial ;
- un *état interne mutable* pour contenir les changements et demander une actualisation de leur représentation dans le document.

_React_ détermine les opérations à effectuer dans le document HTML en fonction de la lourdeur des opérations : (re)création complète de `<time>` dans le nœud parent, simple mise à jour d'un ou ou plusieurs attributs ou encore déplacement du composant ailleurs dans le document HTML etc.

L'intelligence d'une librairie comme _React_ est d'encourager à décrire les données et leur rendu pour se charger des opérations d'écriture dans le DOM.
Cela permet de créer des composants faciles à isoler, à réutiliser et à tester.

Cette approche nous a permis de réutiliser notre minuteur simplement en adaptant son utilisation.
_React_ nous permet de *diriger l'affichage* du document plutôt que d'en dépendre.

[TIP]
.[RemarquePreTitre]#Outil# React Developer Tools
====
Cette extension pour le navigateur Chrome détaille l'arborescence des composants montés dans le document HTML ainsi qu'une vue de leurs propriétés respectives.

image::images/react-devtools.png[align="center",width="85%"]

- [URL]#https://chrome.google.com/webstore/detail/fmkadmapgofadopljbjfkapdkoienihi#
====

[[io]]
== Des requêtes AJAX au temps-réel

Les technologies web offrent un panel de fonctionnalités créatives et versatiles.
Le boom du _Web 2.0_ a coïncidé avec la redécouverte de `XMLHttpRequest`, une API initialement créée par Microsoft pour *transférer des données entre client et serveur*, de _manière non-bloquante_.
Cette fonctionnalité a permis de basculer vers un monde de pages dynamiques et rapides à charger.
Des applications web comme Google Maps, Gmail ou la recherche instantanée de Google ont parachevé la popularisation de cette technique.

Toutefois son API est peu intuitive et est unidirectionnelle, dirigée *du client vers le serveur*.
Le terme `XMLHttpRequest` est parfois nommé `AJAX` ou `xhr`.

Un même exemple côté client sera développé et successivement adapté aux technologies `fetch()`, _EventSource_ puis _WebSocket_.
Il nous permettra d'en faire émerger les principes, leurs cas d'usage ainsi que leur possible intégration avec Node. +
L'implémentation côté serveur est basée sur un serveur <<../chapter-03/index.adoc#express,Express.js>> dont l'usage est expliqué au chapitre 3.

.Résultat attendu dans les exemples des sections suivantes.
image::images/io-example.png[align="center", width="85%"]

[TIP]
.[RemarquePreTitre]#Remarque# Node, mais pas que.
====
`fetch()`, _EventSource_ et _WebSocket_ reposent sur le protocole HTTP/1 et ses extensions.
Il est important de comprendre que leur contrepartie "côté serveur" existe aussi dans d'autres langages et environnements comme Ruby, Python et PHP.

Il se trouve que la nature asynchrone même de Node rend cette intégration relativement aisée et triviale, aussi et en grande partie grâce à l'écosystème _npm_.
====

[[io-fetch]]
=== Échange ponctuel de données avec `fetch()`

`fetch()` offre une interface très simple pour appeler une ressource HTTP.
Le résultat est retourné sous forme de _promesse_ (voir la <<../chapter-02/index.adoc#primitive-promise,section _Promise_>> du Chapitre 2).
Cette fonction set aussi bien à obtenir des ressources avec des requêtes de type `GET` et `HEAD` qu'à en créer et modifier avec des requêtes de type `POST`, `PUT`, `DELETE` et `PATCH`.

L'exemple associé est accessible sur [URL]#{httpRoot}/io/fetch.html#.
Nous pouvons vérifier la compatibilité navigateur de `fetch()` sur [URL]#http://caniuse.com#feat=fetch#.

Le déroulé d'exécution d'un appel à `fetch()` est le suivant :

. construction de la *requête* (_URL_ ou objet `Request`, options) ;
. *réception* des entêtes de la _réponse_ (objet `Response`) ;
. *décodage* de la _réponse_.

Plusieurs _décodeurs de réponse_ sont fournis nativement : texte (`response.text()`), JSON (`response.json()`), ArrayBuffer (`response.arrayBuffer()`), Blob (`response.blob()`) et FormData (`response.formData()`).

[source,javascript]
.io/fetch-client.js
----
include::{sourceDir}/io/fetch-client.js[]
----
<1> Exécution de la requête HTTP _GET_ vers `/new-users` depuis le navigateur web courant ;
<2> Décodage progressif de la réponse ;
<3> Une fois le décodage terminé, le résultat de la requête HTTP est mis à disposition – ici, sous forme de chaîne de caractères.

.Traces réseau d'appels successifs à `fetch()` ; chacun résultant en une nouvelle requête HTTP.
image::images/fetch-frames.png[align="center", width="85%"]

L'implémentation d'une ressource HTTP côté serveur s'effectue simplement en retournant une _réponse_ lors d'une _requête_ HTTP :

[source,javascript]
.io/fetch-server.js
----
include::{sourceDir}/io/fetch-server.js[]
----

[TIP]
.[RemarquePreTitre]#Guide# Collection d'exemples
====
Le guide communautaire _MDN_ met à disposition une dizaine d'exemples pour illustrer différents cas d'utilisation de `fetch()`.

- [URL]#https://github.com/mdn/fetch-examples#
====

En _résumé_, `fetch()` est idéal pour des demandes ponctuelles de données, du client vers le serveur.
Le module _npm_ `node-fetch` ([URL]#https://npmjs.com/node-fetch#) est une implémentation de `fetch()` pour Node.

[[io-eventsource]]
=== Approche unidirectionnelle avec _EventSource_

_EventSource_ est un mécanisme moins connu que `fetch()` ou _WebSocket_ mais tire ses origines de la technologie _Comet_.
On peut l'assimiler à une inversion de `fetch()` : le client appelle une ressource serveur, maintient une connexion de longue durée et attend un ou plusieurs _messages_ dudit serveur.

Chaque connexion est ouverte en faisant appel à la construction d'un objet `EventSource`.
Cet objet émet alors plusieurs types d'événements en fonction des actions :

- `open` : lorsque le client a effectué une connexion au serveur ;
- `message` : lorsque le serveur émet des données à destination du client ;
- `close` : lorsque la connexion est fermée par le serveur ;
- `error` : lorsque la connexion est accidentellement interrompue.

Ce modèle de connexion permet tout aussi bien d'avoir un canal de données unique avec chaque utilisateur ou encore d'émettre les mêmes données en temps réel à destination de tous les usagers.

L’exemple associé est accessible sur [URL]#http://localhost:4000/examples/io/eventsource.html#.
Nous pouvons vérifier la compatibilité navigateur de _EventSource_ sur [URL]#http://caniuse.com#feat=eventsource#.

[source,javascript]
.io/eventsource-client.js
----
include::{sourceDir}/io/eventsource-client.js[]
----
<1> Nous ouvrons une nouvelle connexion _Event Source_ de longue durée depuis le navigateur web courant ;
<2> Fonction appelée à chaque fois que le serveur transmet un message au client.

.Plusieurs messages peuvent être transmis par le biais d'une seule connexion HTTP avec _EventSource_.
image::images/eventsource-frames.png[align="center", width="85%"]

L'implémentation d'_EventSource_ demande un peu d'efforts côté serveur mais ne nécessite pas de _framework_ particulier.
La complexité réside dans le maintient d'une transmission de données dédiée à chaque client ainsi qu'à la libération de la connexion lorsque le client se déconnecte.

[source,javascript]
.io/eventsource-server.js
----
include::{sourceDir}/io/eventsource-server.js[]
----
<1> Une connexion _EventSource_ s'effectue (presque) comme une requête HTTP classique – il convient de vérifier qu'elle s'annonce en tant que telle ;
<2> Création d'un canal unique entre le client et le serveur ;
<3> Chaque appel à `es.send` enverra un nouveau message au client.

Le serveur est responsable de la gestion des connexions demandées par les différents clients.

[TIP]
.[RemarquePreTitre]#Guide# Utiliser _EventSource_
====
Les liens suivants détaillent le protocole _EventSource_, documentent son API et décrivent des exemples d'utilisation.

- [URL]#https://html.spec.whatwg.org/#server-sent-events#
- [URL]#https://developer.mozilla.org/fr/docs/Server-sent_events/Using_server-sent_events#
====

En résumé, _EventSource_ est idéal pour maintenir une connexion avec le serveur et souscrire à des mises à jour en continu.
Chaque connexion _EventSource_ devrait concerner qu'un seul et même type d'événement.

[[io-websocket]]
=== Échanges en temps-réel avec _WebSocket_

_WebSocket_ est une technologie web favorisant les échanges bi-directionnels entre client et serveur.

À l'inverse du protocole HTTP/1, tout message envoyé par le client ou par le serveur n'appelle pas à une réponse de la part du receveur.
Cet élément ainsi que le maintient d'une connexion permanente expliquent la rapidité du protocole en comparaison avec le modèle requête/réponse.

L’exemple associé est accessible sur [URL]#http://localhost:4000/examples/io/websocket.html#.
Nous pouvons vérifier la compatibilité navigateur de _WebSocket_ sur [URL]#http://caniuse.com#feat=websocket#.

[source,javascript]
.io/websocket-client.js
----
include::{sourceDir}/io/websocket-client.js[]
----
<1> Nous ouvrons une connexion _WebSocket_ depuis le navigateur web courant ;
<2> Émission d'un message à destination du serveur ;
<3> Réaction à un message émis par le serveur.

.Trame de messages envoyés par le client (sur fond vert) et par le serveur.
image::images/websocket-frames.png[align="center", width="85%"]

L'implémentation côté serveur est légèrement plus compliquée qu'avec _EventSource_ pour la simple et bonne raison que _Websocket_ est une surcouche du protocole `ws`.
HTTP n'est utilisé que comme canal de communication pour établir un lien avec le serveur `ws`.
HTTP sert de tunnel tandis que le dialogue entre client et serveur s'effectue dans un dialecte compréhensible uniquement de clients _WebSocket_.

Il est nécessaire d'utiliser un module _npm_ _WebSocket_ comme _faye_ ([URL]#https://npmjs.com/faye-websocket#) ou _socket.io_ ([URL]#https://npmjs.com/socket.io#) à moins de vouloir réimplémenter le protocole soi-même.
Le motif de conception est similaire à _EventSource_, à la différence près qu'il faut aussi écouter les messages transmis par le client.

[TIP]
.[RemarquePreTitre]#Remarque# HTTP et le statut `101 Switching Protocols`
====
Voici ce qui se passe lorsqu'un client _WebSocket_ se connecte sur `ws://example.com` :

. requête HTTP `http://example.com` standard contenant les entêtes `Upgrade: websocket` et `Connection: Upgrade` ;
. le serveur HTTP répond avec un statut `101 Switching Protocols` ;
. le serveur _WebSocket_ prend le relais dans le dialogue client/serveur ;
. client et serveur communiquent désormais via le protocole `ws` au sein de la connexion HTTP initiale.
====

Par extension et de par la nature même du protocole `ws`, il serait tout à fait possible que _et_ clients _et_ serveur soient des agents Node.
Autrement dit, un client _WebSocket_ n'a pas nécessairement à être un navigateur web.

[source,javascript]
.io/websocket-server.js
----
include::{sourceDir}/io/websocket-server.js[]
----
<1> Le serveur HTTP vient de répondre avec un statut `101 Switching Protocols` et délègue désormais la responsabilité du dialogue client/serveur ;
<2> Nous vérifions que le changement de protocole concerne le protocole `ws` ;
<3> La connexion réseau (`socket`) est transmise au serveur _WebSocket_ pour amorcer le dialogue client/serveur avec le protocole `ws` ;
<4> Réaction à la réception d'un message client ;
<5> Émission d'un message à destination d'un client.

Là aussi, le serveur est responsable de la gestion des connexions demandées par les différents clients.

[TIP]
.[RemarquePreTitre]#Guide# Utiliser _WebSocket_
====
Les liens suivants détaillent le protocole _WebSocket_, documentent son API et décrivent des exemples d'utilisation.

- [URL]#https://html.spec.whatwg.org/#network#
- [URL]#https://developer.mozilla.org/fr/docs/WebSockets/Writing_WebSocket_client_applications#
====

En résumé, _WebSocket_ est idéal pour maintenir une connexion en temps-réel et pour relayer plusieurs messages à l'initiative du serveur serveur et de tout client connecté – qu'il s'agisse d'un navigateur web ou d'un agent Node.
Chaque connexion _WebSocket_ peut encapsuler plusieurs types de messages.

== Développer au quotidien

Nous avons beaucoup parlé de nouvelles techniques et de modularisation.
Cela peut sembler rebutant, notamment par l'introduction d'outils auxquels nous ne sommes pas encore familiers.

L'écosystème Node fournit énormément d'outils qui devraient nous faire du *gagner du temps*, en nous aidant à exécuter des actions *lorsqu'un fichier est modifié*, en nous aidant à *organiser notre travail* mais aussi en *actualisant automatiquement notre application web* au fil du développement (fini les appuis répétés sur la touche kbd:[F5]) ou encore en *optimisant nos fichiers graphiques*.

[[watchify]]
=== Reconstruire en continu avec `watchify`

L'utilisation de <<browserify,browserify>> nous apporte le confort de pouvoir inclure des modules _npm_ dans les navigateurs web.
En revanche, ça nous demande de générer des artéfacts – des _bundles_ – à chaque modification pour consolider ces changements.

C'est à ce moment qu'intervient le module _watchify_ ([URL]#https://npmjs.com/watchify#).
Il fonctionnement *exactement comme _browserify_* mais au lieu de compiler une seule fois, il compilera dès qu'un changement sera détecté – où que ce soit dans l'arbre de dépendance du point d'entrée (paramètre `-e`, `--entrypoint`).

La commande suivante compilerait le fichier `examples/modules/react-app.js` une fois et une seule :

----
$ ./node_modules/.bin/browserify -t babelify -e examples/modules/react-app.js -o examples/modules/react-app-browserify.js
----

Il suffit de remplacer `browserify` par `watchify` – le programme garde la main et indique chaque nouvelle compilation sur une nouvelle ligne :

----
$ ./node_modules/.bin/watchify -dv -t babelify -e examples/modules/react-app.js -o examples/modules/react-app-browserify.js
1840601 bytes written to examples/modules/react-app-browserify.js (2.58 seconds) at 4:44:28 PM
352482 bytes written to examples/modules/react-app-browserify.js (0.10 seconds) at 4:45:09 PM
1840605 bytes written to examples/modules/react-app-browserify.js (0.25 seconds) at 4:45:15 PM
----

_watchify_ utilise un mécanisme dit de *compilation incrémentale* : _watchify_ ne recompile pas tout mais uniquement les différences depuis le dernier changement.
C'est beaucoup plus rapide et tout aussi efficace.

Trois arguments sont utiles à _watchify_ :

- `-v` (`--verbose`) : force la création du fichier compilé au lancement de la commande ;
- `-o` (`--outfile`) : spécifie le chemin d'enregistrement du fichier compilé – il est impossible d'utiliser la <<../chapter-02/index.adoc#stdio,sortie standard>> (cf. Chapitre 2) ;
- `-d` (`--debug`) : (lire <<browserify-sourcemaps,_Source Maps_>> dans ce même chapitre).

[[livereload]]
=== Changements en temps-réel dans le navigateur

Modifier un fichier. Changer de fenêtre. Recharger. Changer de fenêtre. Remodifier un fichier. Changer de fenêtre. Recharger. _Là_ c'est bon. +
La quantité d'outils à disposition et leurs différentes opinions sur notre manière de travailler nous obligent à prendre des postures de travail qui ne vont *pas nécessairement dans le sens de la productivité*.

L'intégration de Node avec le système d'exploitation va nous aider à déclencher des actions lorsqu'un ou plusieurs fichiers sont modifiés.
Ces modifications peuvent être de notre fait, directement ou par le biais d'un autre logiciel (un optimiseur d'images ou la <<node-sass,compilation d'un fichier _Sass_>> par exemple).

Nous allons explorer _deux stratégies_ d'actualisation :

- le *rafraichissement automatique du navigateur* ;
- le *remplacement de modules à chaud* (_Hot Module Replacement_, _HMR_).

_browser-sync_ est un outil formidable de développement pour *rafraichir automatiquement une page web* si son contenu ou une des ressources associées change.
Il offre également la possibilité de *propager les changements sur plusieurs fenêtres et terminaux* – y compris les clics, _scrolls_ et toute interaction avec des formulaires.

ifeval::["{backend}" == "html5"]
.Exemple de synchronisation d'affichage et de contenus entre deux fenêtres avec _browser-sync_.
video::videos/browser-sync.mp4[align="center",width="100%"]
endif::[]

_browser-sync_ maintient la position du scroll lors d'un rechargement de contenu.
L'outil se lance soit de manière autonome, soit en _proxy_ entre l'utilisateur et tout autre serveur web.
Il ne nécessite pas non plus de _plugin_ ou d'extension navigateur pour fonctionner, le rendant idéal pour du prototypage, de la recherche utilisateur ou du développement local.

.Lancement d'un serveur web autonome avec synchronisation sur le port 4000.
----
$ ./node_modules/.bin/browser-sync start --server --port 4000 .
----

L'exemple suivant illustre l'intégration de _browser-sync_ avec le serveur web exposant les exemples de ce chapitre (voir le détail dans le fichier `server.js`) :

[source,javascript]
.livereload/server-sync.js
----
include::{sourceDir}/livereload/server-sync.js[]
----
<1> On passe serveur http en argument (obtenu via `http.createServer()` par exemple) ;
<2> Ce port sera assigné au serveur web mais ne sera pas voué à être public ;
<3> Ce port, lui, est celui qui sera public ;
<4> Démarrage du serveur web sur le port privé ;
<5> Initialisation de _browser-sync_ ;
<6> Interfaçage avec le serveur web créé au point 4.

La synchronisation peut être activée avec tous les exemples du chapitre en suffixant la commande `npm start` :

----
$ nodebook chapter 4
$ npm start -- --with-sync
----

[TIP]
.[RemarquePreTitre]#Documentation# _browser-sync_
====
_browser-sync_ est richement documenté et illustré, y compris ses intégrations avec les outils _gulp_ et _grunt_.

- [URL]#https://browsersync.io/#
- [URL]#https://npmjs.com/browser-sync#
====

_browser-sync_ a beau maintenir la position du _scroll_, il n'en reste pas moins que *chaque changement remet à zéro* l'espace mémoire de la page.
C'est là qu'entre en jeu le *remplacement des modules à chaud*.

Le *remplacement des modules à chaud* (_Hot Module Replacement_ ou _HMR_) est une technique basée sur le remplacement de fonctions ou d'objets tout en assurant le maintient de leurs variables ou états internes.
Cette technique a notamment été popularisée par la combinaison de la librairie _React_ et de l'outil d'assemblage _Webpack_.
Il est bien entendu possible de procéder à du _remplacement à chaud_ sans _React_ et sans _Webpack_.

Quatre actions sont effectuées :

. un *serveur de remplacement à chaud* est démarré localement ;
. l'outil d'assemblage (_browserify_, _Webpack_ etc.) *insère du code client* permettant d'établir un lien entre la page web et le sreveur de remplacement à chaud ;
. l'outil d'assemblage *déclare les fichiers modifiés*, transmis par le serveur de remplacement à chaud vers le navigateur web ;
. le *code client remplace les modules* et maintient leur état interne.

ifeval::["{backend}" == "html5"]
.Exemple de rechargement à chaud avec des composants _React_.
video::videos/react-hmr.mp4[align="center",width="100%"]
endif::[]

Le _plugin browserify_ nommé _livereactload_ est très certainement le plus facile à mettre en place pour remplacer des modules _React_ à la volée.
Il nécessite une ligne de configuration côté _browserify_ et ne nécessite aucun changement de code côté client.

[TIP]
.[RemarquePreTitre]#Documentation# _livereactload_
====
Des aides à l'installation du module _livereactload_ sont disponibles dans son fichier README.

- [URL]#https://npmjs.com/livereactload#
====

Le remplacement à chaud n'est possible que lorsque nous sommes dans un état de reconstruction en continu, par exemple avec <<watchify,watchify>>.

Nous pouvons constater les effets du remplacement à chaud avec un des exemples de ce chapitre accessible sur [URL]#{httpRoot}/livereload/react-app-hmr.html#.
La commande `npm run watch` de ce chapitre démarre un serveur web et reconstruit en continu le fichier `{sourceDir}/livereload/react-app-hmr.js` :

----
$ nodebook chapter 4
$ npm run watch
----

Qui n'est autre qu'un équivalent de :

[subs="attributes"]
----
$ watchify -dv \
  -t babelify \         # <1>
  -p livereactload \    # <2>
  -e {sourceDir}/livereload/react-app-hmr.js \
  -o {sourceDir}/livereload/react-app-hmr-browserify.js
----
<1> Le _transform_ (`-t`) modifie le code à la volée ;
<2> Le _plugin_ (`-p`) encapsule le fonctionnement de _watchify_ pour effectuer des opérations plus complexes et impossibles à effectuer autrement.

Il faudra ensuite modifier l'un des deux fichiers suivants – en décommentant les lignes concernées par exemple – pour constater les changements dans notre navigateur.

[source,javascript]
.livereload/react-app-hmr.js
----
include::{sourceDir}/livereload/react-app-hmr.js[]
----

Chaque instance du composant `livereload/button-count.jsx` gère un état interne indépendant des autres instances de même type.
Nous aurions perdu cet état interne en cas d'utilisation de _browser-sync_, sans _remplacement à chaud_ :

[source,jsx]
.livereload/button-count.jsx
----
include::{sourceDir}/livereload/button-count.jsx[]
----
<1> Initialisation du compteur de clics propre à chaque instance de `ButtonCount` ;
<2> Incrémentation du compteur de clics en réaction à un clic sur le composant `ButtonCount`.

[TIP]
.[RemarquePreTitre]#Alternative# _ud_ et _browserify-hmr_
====
Deux modules sont à disposition pour respectivement déclarer des modules remplaçables et pour démarrer un serveur de remplacement à chaud minimaliste.

- [URL]#https://npmjs.com/ud#
- [URL]#https://npmjs.com/browserify-hmr#
====

[[node-sass]]
=== Modulariser ses feuilles de style avec _Sass_

La modularité et l'écriture d'un code isolé facilitent sa réutilisation et préviennent les effets de bord. +
Dans le cas des feuilles de style CSS, cela peut aider à éviter de faire _déborder_ la cascade – si l'on peut dire.

Avec le _langage Sass_ ([URL]#http://sass-lang.com#), nous pourrions songer à générer des blocs de code selon des *listes* (idéal pour des thèmes de couleurs, des rubriques produits etc.), à concevoir des *composants comme des fonctions* ou à bénéficier de fonctions de *calcul de couleurs* ou d'unités de mesure.

Le langage _Sass_ est originaire du monde Ruby mais il a été depuis rendu accessible nativement à l'écosystème Node par le biais de _node-sass_ ([URL]#https://npmjs.com/node-sass#)– et par extension, par la librairie C _libsass_.

[TIP]
.[RemarquePreTitre]#Lecture# CSS maintenables avec Sass et Compass
====
Je recommande la lecture de cet ouvrage de référence écrit par _Kaelig Deloumeau-Prigent_ aux éditions _Eyrolles_.
Il décrit très bien les tenants et aboutissants de Sass ainsi que de bonnes méthodes d'organisation du code et de maintenabilité au sein d'une équipe de travail.

- [URL]#http://editions-eyrolles.com/Livre/9782212136401#
====

_node-sass_ offre un outil en ligne de commande pour compiler un fichier Sass, plusieurs fichiers Sass ou encore une arborescence de répertoires contenant des fichiers Sass vers des fichiers CSS compréhensibles par les navigateurs web.

[source,sass]
.ui/buttons.scss
----
include::{sourceDir}/ui/buttons.scss[]
----
<1> Définition d'une `Map` nommée `$sizes` (ensemble clé/valeur) décrivant des tailles et leur facteur multiplicateur ;
<2> Itération et extraction des clés/valeurs de `$sizes` ;
<3> Interpolation d'une variable pour composer un sélecteur CSS (`.btn--small`, `.btn--regular` etc.) ;
<4> Calcul de la taille de la police de caractères (`.8em`, `1em` etc.);
<5> Composition d'un sélecteur de classe à partir du sélecteur courant (`.btn.btn--icon`).

La compilation des fichiers s'effectue très simplement :

[subs="attributes"]
----
$ ./node_modules/.bin/node-sass -o {sourceDir} {sourceDir}/buttons.scss
----

La compilation générera le fichier CSS `button.css`, lisible par tout navigateur web :

[source,css]
.ui/buttons.css
----
include::{sourceDir}/ui/buttons.css[]
----

[TIP]
.[RemarquePreTitre]#Astuce# Oublions les _vendor prefix_
====
Les navigateurs évoluent plus vite que le cycle de vie de nos projets.
Certaines propriétés CSS sont abritées derrière des préfixes (`-moz`, `-webkit` etc.) avant d'être standardisées.

Ces deux modules nous facilitent la vie en préfixant et réécrivant automatiquement les attributs en fonction de nos exigences de compatibilité navigateurs.

- [URL]#https://npmjs.com/autoprefixer#
- [URL]#https://npmjs.com/postcss#
====

[[ui-bundling]]
=== Lier composants visuels et feuilles de style

Souvenons-nous de la section expliquant le <<react,rapprochement entre données, rendu et interactions avec _React_>> de ce même chapitre.
Finalement nous avons presque tout rapproché, exception faite de la présentation avec _Sass_ ou CSS.

En suivant la logique de notre approche modulaire, nous pourrions imaginer un _transform browserify_ pour compiler et/ou extraire notre code _Sass_ ou CSS depuis nos composants _CommonJS_ ou _ECMAScript 2015_.

C'est exactement la proposition du module _sassify_.
Il intègre _node-sass_ en tant que _transform browserify_ et le transforme le code à la volée durant la phase de compilation.
Il se charge lui-même d'ajouter les styles dans le document HTML ou expose le code CSS compilé via la fonction `require()`.

Une saine stratégie serait de charger des CSS de base dans une feuille de style en tête de `<head>` puis de laisser les composants graphiques injecter leurs feuilles CSS respectives après coup.

L'exemple suivant expose deux composants _React_, regroupés dans une thématique de composants de boutons HTML.
Une feuille de style est importée à même le module afin de *gérer à un même niveau, présentation, rendu et interactions* :

[source,jsx]
.ui/Buttons.jsx
----
include::{sourceDir}/ui/Buttons.jsx[]
----
<1> Import d'un fichier _Sass_ qui sera par la suite compilé en CSS par le _transform sassify_.

Sans surprise, le module _sassify_ se charge comme la majorité des _transform browserify_ comme vu dans la section <<browserify,Importer des modules npm pour le web>> dans ce même chapitre :

[subs="attributes"]
----
$ ./node_modules/.bin/browserify \
  -t sassify \
  -t babelify \
  -e {sourceDir}/Buttons.jsx \
  -o {sourceDir}/Button-browserify.js
----

La commande suivante injectera automatiquement les feuilles de style compilées dans le document HTML lors de son exécution dans un navigateur web :

[subs="attributes"]
----
$ ./node_modules/.bin/browserify \
  -t [ sassify --auto-inject ] \
  -t babelify \
  -e {sourceDir}/Buttons.jsx \
  -o {sourceDir}/Button-browserify.js
----

[TIP]
.[RemarquePreTitre]#Alternative# CSS Modules
====
Une autre philosophie émergente est de continuer à transformer son code _Sass_ ou CSS en styles en ligne, à leur adjoindre un préfixe unique et à les insérer directement dans le code HTML. +
Elle demande moins d'outillage et s'applique pleinement à des composants visuels modulaires :

- [URL]#https://npmjs.com/css-modules#
- [URL]#https://npmjs.com/css-modulesify#
====

=== Optimiser ses ressources graphiques

TBD.

== Tester son code


=== Écrire des tests avec tape et chai

TBD.

=== Exécuter les suites de tests avec Karma

TBD.

=== Tester les éléments de lisibilité et de performance

TBD.

=== Tester la compatibilité navigateurs avec BrowserStack

TBD.

=== Le cas Internet Explorer et ievms

TBD.

== Conclusion

TBD.

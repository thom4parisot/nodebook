:appendix-number: A
:chapterId: appendix-a
:sectnums:
:nodeCurrentVersion: v10
:npmCurrentVersion: v6
:revdate: {docdate}
:sourceDir: ./examples
:imagesdir: {indir}
ifdef::env[]
:imagesdir: .
endif::[]

[appendix]
= Sélection de modules{nbsp}npm

Cette annexe est une sélection de modules{nbsp}``npm`` ([URL]#https://npmjs.com#)
à laquelle vous référer pour démarrer rapidement, mais aussi pour découvrir
des usages et des domaines d'application insoupçonnés.

J'ai bâti cette liste à partir de mon expérience personnelle et sur la confiance
que je porte aux personnes à l'origine de ces modules.

include::../docs/tip-versions.adoc[]
include::../docs/tip-examples.adoc[]


== Boîte à outils du quotidien

Ces modules répondent à des besoins quotidiens, pour travailler plus rapidement
sur des structures ECMAScript.

=== lodash

_lodash_ ([URL]#https://npmjs.com/lodash#) est une collection de plusieurs
dizaines de fonctions pour travailler plus facilement avec des chaînes de caractères,
des tableaux, des fonctions et des objets.

Vous pourrez ainsi filtrer, sélectionner, fusionner, vérifier et composer
de nouvelles variables, aussi bien pour Node que dans les navigateurs.

[source%interactive,javascript]
.lodash.js
----
include::{sourceDir}/lodash.js[]
----
<1> Affiche `Thor`.

=== he

_he_ ([URL]#https://npmjs.com/he#) est un utilitaire pour encoder et décoder
des entités HTML dans des chaînes de caractères.

[source%interactive,javascript]
.he.js
----
include::{sourceDir}/he.js[]
----
<1> Affiche `<h1>Blog Post</h1>`.
<2> Affiche `++&#x3C;h1&#x3E;Blog Post&#x3C;/h1&#x3E;++`.

=== chance

_chance_ ([URL]#https://npmjs.com/chance#) crée des données de manière aléatoire.
Le module retourne aussi des prénoms fictifs, mais aussi des numéros de téléphone,
des nombres, des paragraphes, des dates d'anniversaire, des identifiants Android
ou Apple, etc.

Il s'utilise surtout pour générer des données factices à des fins de tests,
en attendant les vraies données.

=== date-fns

_date-fns_ ([URL]#https://npmjs.com/date-fns#) est une collection de fonctions
pour travailler avec des dates, plus facilement qu'avec l'objet natif{nbsp}``Date``.

Vous pouvez formater, ajouter ou retirer des jours, vérifier si deux périodes
de temps se chevauchent ou si deux dates font partie d'une même semaine calendaire.


=== tcomb

_tcomb_ ([URL]#https://npmjs.com/tcomb#) renforce la création de structures
typées et non mutables.
Cela réduit les effets de bord de nos applications lorsque les
données n'ont pas la structure attendue.

[source%interactive,javascript]
.tcomb.js
----
include::{sourceDir}/tcomb.js[]
----
<1> Définition d'une structure stricte qui a pour propriétés `lat` et `lon`, pour _latitude_ et _longitude_.
<2> Cet appel va lancer une exception car la propriété `long` est inconnue.
<3> Cet appel va lancer une exception car la propriété `lon` doit être un nombre.

=== eventemitter3

_eventemitter3_ ([URL]#https://npmjs.com/eventemitter3#) sert à gérer
des événements de manière uniforme dans un script Node et dans les navigateurs.

[source%interactive,javascript]
.eventemitter3.js
----
include::{sourceDir}/eventemitter3.js[]
----
<1> Affiche `[ [Function], [Function] ]`.
<2> Affiche `on: ping,ping` puis `once: ping,ping`.
<3> Affiche `on: ping,ping`.
<4> N'affiche rien, l'événement étant désormais déconnecté.


[[dev]]
== Pendant le développement

=== debug

_debug_ ([URL]#https://npmjs.com/debug#) rend optionnel l'affichage de
messages de débogage.
Les messages s'affichent en présence d'une variable d'environnement.
Nous pouvons ainsi lancer un processus et retracer un cheminement complexe de
données.

Par défaut, les messages ne s'affichent pas :

----
$ node examples/debug.js
----

Les messages du débogueur `app` s'affichent désormais :

[subs="+quotes"]
----
$ ##DEBUG=app## node examples/debug.js
  app fromages [ 'livarot', 'chaource' ] +0ms
----

Nous pouvons en afficher plusieurs en même temps, en usant du caractère{nbsp}``*``
ou en séparant les noms de débogueurs avec des virgules :

[subs="+quotes"]
----
$ DEBUG=app##*## node examples/debug.js
  app fromages [ 'livarot', 'chaource' ] +0ms
  app:timer now 1531304027271 +0ms
----

[source,javascript]
.debug.js
----
include::{sourceDir}/debug.js[]
----
<1> Création du débogueur `app`.
<2> Création du débogueur `app:timer`.
<3> La fonction de débogage s'utilise de la même manière que `console.log`.
<4> Cette fonction fait appel au débogueur `app:timer`.

=== nodemon

_nodemon_ ([URL]#https://npmjs.com/nodemon#) relance le processus actif
dès qu'un fichier ECMAScript ou JSON est modifié.
C'est un module exécutable particulièrement utile lorsque nous voulons prendre
en compte les changements dans une application qui tourne en continu.
C'est le cas des applications web, entre autres.

Pour en savoir plus, rendez-vous à la section
"`<<../chapter-07/index.adoc#dev,Pendant le développement : relancer le serveur automatiquement>>`"
du <<../chapter-07/index.adoc#,chapitre{nbsp}7>>.

=== npm-run-all

_npm-run-all_ ([URL]#https://npmjs.com/npm-run-all#) est mon outil favori
pour composer avec les scripts{nbsp}``npm``.
Il a l'avantage d'être adaptable, de régler finement ce qui
doit être exécuté en parallèle ou séquentiellement.
Le module transfère les arguments aux sous-scripts.

[source,json]
.package.json
----
{
  "...": "...",
  "scripts": {
    "build": "npm-run-all -p 'build:*' -s start",
    "build:css": "sass ...",
    "build:js": "browserify ...",
    "start": "node server.js"
  }
}
----

=== husky

_husky_ ([URL]#https://npmjs.com/husky#) intègre Git aux
<<../chapter-05/index.adoc#scripts,scripts{nbsp}``npm``>>.
Autrement dit, vous pouvez déclencher des scripts lors d'événements Git,
lors d'un `push`, avant un `commit` ou après avoir rapatrié des changements.

[source,json]
.package.json
----
{
  "...": "...",
  "scripts": {
    "precommit": "lint-staged",
    "post-merge": "npm install"
  }
}
----

La liste complète des _hooks_ Git se trouve dans la documentation
officielle : [URL]#https://git-scm.com/docs/githooks#.

=== onchange

_onchange_ ([URL]#https://npmjs.com/onchange#) observe une liste de fichiers
en continu et déclenche une commande dès que l'un d'entre eux est modifié.
C'est particulièrement utile pour reconstruire automatiquement des fichiers
de configuration ou des fichiers _front-end_ pendant le développement.

[source,json]
.package.json
----
{
  "...": "...",
  "scripts": {
    "build:css": "sass ...",
    "dev": "npm-run-script -p 'watch:*' start",
    "watch:css": "onchange '**/*.scss' -- npm run build:css",
    "start": "node server.js"
  }
}
----

=== tiny-lr

_tiny-lr_ ([URL]#https://npmjs.com/tiny-lr#) est une implémentation minimale
du protocole _livereload_ ([URL]#http://livereload.com/#).
Il s'intègre à un serveur HTTP ou à une application _express_ pour relayer
la liste des fichiers modifiés côté client.

Le script ou l'extension navigateur client remplace les anciens fichiers
par les nouveaux pour refléter les changements sans recharger la{nbsp}page.

=== livereactload

_livereactload_ ([URL]#https://npmjs.com/livereactload#) recherche les composants
<<react,React>> à chaud, c'est-à-dire sans rafraîchir la page ni perdre l'état des données.
C'est un module indispensable pour développer des applications front-end réactives.

[NOTE]
====
Rendez-vous dans la section "`<<../chapter-09/index.adoc#livereload,Changements en temps{nbsp}réel>>`"
du <<../chapter-09/index.adoc#,chapitre{nbsp}9>> pour en savoir plus sur son
installation et son intégration.
====

== Protéger nos applications

Le code que nous écrivons se protège dès la conception et dans le temps.
Certains modules filtrent les tentatives d'exploitation de nos
applications, tandis que d'autres vérifient si le code déployé est toujours{nbsp}sûr.

=== sanitize-filename

_sanitize-filename_ ([URL]#https://npmjs.com/sanitize-filename#) nettoie
une variable de tout caractère ambigu ou qui ne serait pas attendu.

[source%interactive,javascript]
.sanitize-filename.js
----
include::{sourceDir}/sanitize-filename.js[]
----
<1> Affiche `aucun-problème.txt`.
<2> Affiche `+.....sshid_rsa+` – les caractères{nbsp}``/`` sont nettoyés car il permettrait de créer des chemins compromettants pour l'application ou le système d'exploitation.

=== helmet

_helmet_ ([URL]#https://npmjs.com/helmet#) est un module à intégrer systématiquement
dans toute application _express_.
Il ajoute des en-têtes HTTP _Content-Security Policy_, _Strict Transport Policy_
et d'autres qui empêchent le détournement d'informations.

Chacune de ses protections se configure aussi au cas par cas.
Elles s'intègrent manuellement dans d'autres types d'applications web,
y{nbsp}compris un serveur HTTP natif à{nbsp}Node.

=== dompurify

_dompurify_ ([URL]#https://npmjs.com/dompurify#) nettoie un contenu HTML
pour le rendre affichable en toute sécurité.
Il nettoie des scripts indésirés, des balises mal formées qui casseraient l'affichage,
ou encore des _iframes_ qui injecteraient des contenus tiers sans notre consentement.

=== filenamify

_filenamify_ ([URL]#https://npmjs.com/filenamify#) nettoie une valeur
pour retirer tout caractère invalide dans un nom de fichier.
C'est pratique pour laisser la possibilité à un utilisateur de choisir
un nom de fichier sans pour autant mettre en danger le système ou l'application.

=== retire.js

_retire.js_ ([URL]#https://npmjs.com/retire#) sert à scanner soi-même des
vulnérabilités connues dans des fichiers JavaScript.
Il est complémentaire de la commande <<../chapter-05/index.adoc#audit,`npm audit`>>
car il inspecte des dépendances qui ne sont pas forcément sur{nbsp}``npm``.

=== snyk

_snyk_ ([URL]#https://npmjs.com/snyk#) est à la fois un service en ligne
et un module pour vérifier la présence de failles de sécurité connues
dans les dépendances de nos projets.


== Vérifier la syntaxe de notre{nbsp}code

La vérification syntaxique est un mécanisme s'assurant que votre code respecte
la grammaire du langage associé.
Elle révèle aussi des anomalies fondamentales (balise mal fermée,
expression inconnue, etc.) et renforce des pratiques de programmation commune
au groupe de développement.

Vérifier la syntaxe de notre code est une excellente première étape avant
d'introduire des tests unitaires ou fonctionnels.

=== htmlhint

_htmlhint_ ([URL]#https://npmjs.com/htmlhint#) vérifie la structure de
nos documents HTML.
Il rapporte les doublons d'attributs{nbsp}``id``, la présence de balises
mal formées, l'absence de balise fermante ou encore l'existence de chaînes de
caractères non imprimables dans des attributs critiques, entre autres.

Prenons en exemple le document suivant :

[source,html]
.sample.html
----
include::{sourceDir}/sample.html[]
----

Une lecture distraite pourrait nous faire passer à côté d'erreurs et
d'incohérences de programmation.
Les erreurs de ce genre passent d'autant plus inaperçues que la base de code
devient volumineuse et change fréquemment.

L'exécution de _htmlhint_ avec ses règles par défaut remontera les alertes
suivantes :

----
$ ../node_modules/.bin/htmlhint sample.html
sample.html:
line 1, col 1: Doctype must be first.
line 8, col 10: Id redefinition of [ btn ].
line 10, col 3: Tagname [ BUTTON ] must be lower case.
...
line 10, col 52: Tagname [ BUTTON ] must be lower case.
----

=== eslint

_eslint_ ([URL]#https://npmjs.com/eslint#) est l'outil de vérification
syntaxique pour ECMAScript par excellence.
Il est souple, rapide à mettre en œuvre et s'adapte à des contextes complexes.
J'aime son mécanisme de configuration de règles : utilisation systématique du
<<../chapter-03/index.adoc#strict,mode strict>>, nombre maximum de paramètres
de fonctions, objets non déclarés, variables inconnues, etc.

_eslint_ expose également des fonctions pour créer vos propres règles métier.

[source,json]
.package.json
----
include::{sourceDir}/package-eslint.json[]
----

Le niveau de sévérité de chaque règle est représenté par un identifiant :

- `none` : règle désactivée ;
- `warn` : affiche un avertissement ;
- `error` : affiche une erreur (le processus se terminera avec un code d'erreur).

Certaines règles demandent ou acceptent des arguments supplémentaires.
Elles sont toutes documentées sur le site web du projet :
[URL]#http://eslint.org/docs/rules/#.

[NOTE]
.[RemarquePreTitre]#Documentation# Règles personnalisées
====
Un exemple réutilisable de règles personnalisées se trouve sur le dépôt
GitHub de Airbnb :

- [URL]#https://github.com/airbnb/javascript#
====

=== csslint

_csslint_ ([URL]#https://npmjs.com/csslint#) est un outil de vérification
syntaxique de feuilles de style CSS.
Il a été créé par deux anciens ingénieurs de Yahoo! dont les anciens travaux
dans le domaine de la performance ont influencé
l'architecture et le choix des règles par défaut.

_csslint_ fournit les mécanismes de vérification adéquats pour alerter de
possibles effets de bord de _box{nbsp}model_, de déclaration incompatible de
`@font-face`, de _vendor prefix_ dépréciés ou encore de combinaisons de
propriétés connues pour casser l'affichage dans certains navigateurs.

Prenons par exemple le fichier CSS suivant :

[source,css]
.sample.css
----
include::{sourceDir}/sample.css[]
----

_csslint_ lancera trois alertes en lisant le fichier `sample.css`,
même si celui-ci est syntaxiquement parfaitement valide :

----
$ ../node_modules/.bin/csslint sample.css

csslint: There are 3 problems in sample.css.

sample.css
1: warning at line 4, col 11
Values of 0 shouldn't have units specified.
  border: 0px solid black;

sample.css
2: warning at line 4, col 3
Using height with border can sometimes make
  elements larger than you expect.
  border: 0px solid black;
...
----

=== doiuse

_doiuse_ ([URL]#https://npmjs.com/doiuse#) est un utilitaire qui repose
sur la base de données du site communautaire [URL]#https://caniuse.com#.
Il nous alerte des possibles incompatibilités de syntaxe en fonction de la liste
de navigateurs à gérer.
Cette liste concerne aussi bien des versions spécifiques (Internet Explorer{nbsp}8)
que des parts de marché (tous les navigateurs avec plus de 5{nbsp}% de parts de marché).

L'exemple suivant illustre les alertes relevées par _doiuse_ dans le cas
d'une recherche de compatibilité avec Internet Explorer{nbsp}6 et Internet
Explorer{nbsp}7 :

----
$ ../node_modules/.bin/doiuse -b 'ie < 8' sample.css
sample.css:1:1: CSS 2.1 selectors not supported by: IE (6)
sample.css:8:1: CSS 2.1 selectors not supported by: IE (6)
sample.css:12:1: CSS3 Transitions not supported by: IE (6,7)
sample.css:14:1: CSS 2.1 selectors not supported by: IE (6)
----

[[optimize]]
== Optimiser notre{nbsp}code

Commentaires, indentations ou encore noms de variables : tout cela occupe de
la place – autant d'octets transférés sur le réseau avant d'être exécutés
par un client web.
Les outils d'optimisation offrent l'opportunité aux développeurs et développeuses
d'écrire du code sans compromettre sa lisibilité et sa maintenabilité.

Les minifieurs et optimiseurs mettent en œuvre différentes techniques pour
réduire le poids de notre{nbsp}code :

- suppression des commentaires et caractères non significatifs ;
- renommage de variables ;
- factorisation d'occurrences multiples similaires ;
- suppression des instructions relatives au débogage/développement ;
- suppression du code inutilisé ;
- écriture automatique de code pour prendre en charge des environnements anciens ou futurs.

=== uglify-es

_UglifyJS_ ([URL]#https://npmjs.com/uglify-es#) est un des premiers
compresseurs à utiliser une représentation syntaxique en arbre
(_Abstract Syntax Tree_ – _AST_) en lieu et place des classiques
optimisations avec expressions régulières.

Cette méthode élargit les perspectives de la compression via de
la réécriture de{nbsp}code :

- _hoisting_ des variables (remontée de leur déclaration en début de portée) ;
- combinaison des déclarations de variables ;
- factorisation des valeurs de variables ;
- réécriture partielle d'expressions ;
- injection en ligne du contenu de variables.

_UglifyJS_ s'utilise en ligne de commande ou comme un module{nbsp}Node.

=== postcss

_PostCSS_ ([URL]#https://npmjs.com/postcss#) est une optimiseur CSS modulaire.
Cet outil est construit autour d'un parseur CSS, d'un arbre syntaxique
et d'un compilateur texte.
C'est la même recette qui a participé au succès et à la richesse fonctionnelle
d'outils comme <<uglify-js2,UglifyJS>> et <<eslint,ESLint>>.

Avec une ou plusieurs extension(s), vous basculez d'un optimiseur de code
vers la possibilité de créer votre propre préprocesseur, comme{nbsp}Sass !

=== autoprefixer

_autoprefixer_ ([URL]#https://npmjs.com/autoprefixer#) est _le_ module qui
vous épargnera l'écriture de centaines de lignes CSS.
Il ajoute automatiquement les préfixes navigateurs aux bons endroits :
`-webkit`, `-moz`, etc.

_autoprefixer_ s'utilise comme extension au module <<postcss,_PostCSS_>>,
en ligne de commande ou comme module{nbsp}Node.

----
$ ../node_modules/.bin/postcss sample.css \
    --use autoprefixer  | grep transition
          transition: font-weight 0.2s ease;
----

Le choix de compatibilité avec les navigateurs repose sur la variable
d'environnement `BROWSERSLIST`, gérée par le module _browserslist_
([URL]#https://npmjs.com/browserslist#) :

----
$ export BROWSERSLIST='firefox > 8'
$ ../node_modules/.bin/postcss sample.css \
    --use autoprefixer | grep transition
     -moz-transition: font-weight 0.2s ease;
          transition: font-weight 0.2s ease;
----

=== uncss

_uncss_ ([URL]#https://npmjs.com/uncss#) est le pendant inverse d'_autoprefixer_
puisqu'il se charge de supprimer le code CSS inutilisé.
Il s'utilise de manière autonome ou comme module <<postcss,PostCSS>>.

Le module charge une ou plusieurs page(s) web, calcule la différence entre
les règles utilisées et celles qui ne le sont pas.
Vous êtes libre de mentionner une liste blanche de règles à ne jamais supprimer.

=== csswring

_csswring_ ([URL]#https://npmjs.com/csswring#) est un minifieur de code CSS
qui s'interface lui aussi avec <<postcss,PostCSS>>.
Vous lui donnez du code, il en ressort une version avec le minimum de caractères
possible.

=== google-closure-compiler-js

_Google Closure Compiler_ ([URL]#https://npmjs.com/google-closure-compiler-js#)
est un compilateur ECMAScript plus poussé qu'_UglifyJS_ mais qui impose un
style d'écriture plus strict, voire plus contraignant.
Ses optimisations sont en général bien plus poussées et permettent d'atteindre
des niveaux de finesse difficiles à obtenir autrement.

=== csso

_csso_ ([URL]#https://npmjs.com/csso#) est une alternative à <<csswring,csswring>>,
écrite par l'équipe derrière la méthodologie BEM ([URL]#https://en.bem.info#).

_csso_ ira jusqu'à réécrire les codes couleurs, les `margin` et `padding` et
factorisera les sélecteurs similaires.

=== svgo

_svgo_ ([URL]#https://www.npmjs.com/svgo#) s'attaque au nettoyage des fichiers
graphiques vectoriels au format SVG.
Il simplifie les chemins et supprime les attributs et déclarations superflues.

Vous pouvez l'essayer en ligne sur [URL]#https://jakearchibald.github.io/svgomg/#
ou l'intégrer comme extension à <<postcss,PostCSS>>.

=== wawoff2

_wawoff2_ ([URL]#https://npmjs.com/wawoff2#) optimise des polices de caractères
pour le Web.
Le module convertit des polices au format TTF vers le format WOFF2 – à préférer
car plus léger et donc rapide à charger.

[[transpiling]]
== Passer d'un langage à un autre

Les préprocesseurs sont des outils de productivité pour CSS.
Ils transforment un langage plus avancé dans quelque chose qui est compris
par un navigateur{nbsp}web.

La même chose s'applique avec la compilation ou la transpilation pour ECMAScript,
pour utiliser dès maintenant une version du futur.

=== less

_less_ ([URL]#https://npmjs.com/less#) est un préprocesseur CSS.
Il gère des variables, des _mixins_, des calculs de couleurs et des fonctions
qui encouragent une écriture modulaire, plus logique et plus succincte.

[source]
.stylesheet.less
----
include::{sourceDir}/stylesheet.less[]
----

L'exécutable `lessc` compile le fichier _Less_:

----
$ ../node_modules/.bin/lessc stylesheet.less
----

=== sass

_Sass_ ([URL]#https://npmjs.com/node-sass#) est un autre préprocesseur CSS.
Il est issu du monde Ruby et est désormais tout aussi puissant dans Node
grâce à _libsass_, un module rapide et portable écrit en{nbsp}{cpp}.

=== browserify

_browserify_ ([URL]#https://npmjs.com/browserify#) transforme des modules et du
code initialement écrit pour Node vers du code exécutable dans un navigateur{nbsp}web.

Un puissant mécanisme de transformations étend ses capacités au coup par{nbsp}coup.

[NOTE]
====
Nous en parlons plus en détail dans la section
"`<<../chapter-09/index.adoc#browserify,Importer des modules{nbsp}``npm`` pour le Web>>`"
au <<../chapter-09/index.adoc#,chapitre{nbsp}9>>.
====

=== babel

_babel_ ([URL]#https://npmjs.com/babel#) est un outil qui permet de passer
d'une version d'ECMAScript à une autre, fonctionnalité par fonctionnalité.
C'est un outil indispensable pour écrire un code moderne et le faire
fonctionner dans des navigateurs anciens.

=== typescript

_TypeScript_ ([URL]#https://npmjs.com/typescript#) est un langage de programmation
typé.
Toute structure utilisée est décrite avec un schéma que TypeScript valide.
Nous sommes prévenu·e·s des erreurs avant même d'avoir exécuté notre code
car l'outillage sait si on manipule des données qui existent.

Au final, le code est transformé en ECMAScript et exécuté en tant que tel.
Le code est tellement propre que nous pouvons arrêter d'utiliser TypeScript
du jour au lendemain et travailler sur le code qu'il aura généré sans aucun problème.


[[fs]]
== Gérer des fichiers

Ces bibliothèques nous aident à écrire moins de lignes de code
pour des besoins quotidiens de manipulation de fichiers.

=== mkdirp

_mkdirp_ ([URL]#https://npmjs.com/mkdirp#) est identique à la
commande Unix `mkdir -p`, c'est-à-dire que les répertoires seront créés récursivement
s'ils n'existent pas au préalable.

Si nous utilisions le module Node{nbsp}``fs``, nous devrions créer l'arborescence de
répertoires par nous-même, niveau par niveau.

=== rimraf

_rimraf_ ([URL]#https://npmjs.com/rimraf#) est le pendant opposé de _mkdirp_.
Il supprime une arborescence de manière récursive.
C'est l'équivalent de la commande Unix{nbsp}``rm -rf``.

Si nous utilisions le module Node{nbsp}``fs``, nous devrions supprimer d'abord
les fichiers puis les répertoires, un par{nbsp}un.

=== glob

_glob_ ([URL]#https://npmjs.com/glob#) est un utilitaire pour obtenir
une liste de fichiers en utilisant des motifs.

[source%interactive,javascript]
.glob.js
----
include::{sourceDir}/glob.js[]
----
<1> Affiche une liste de fichiers dont l'extension est{nbsp}``.js``.
<2> Affiche une liste de fichiers qui commencent par{nbsp}``re`` et dont l'extension est{nbsp}``.js``.
<3> Affiche une liste de fichiers qui s'appellent `sample`, peu importe leur extension.

=== fs-extra

_fs-extra_ ([URL]#https://npmjs.com/fs-extra#) est une collection
de fonctions pour gérer les opérations de fichiers.
Le module inclut _rimraf_ et _mkdirp_ en plus d'autres fonctions récursives,
pour copier, déplacer ou supprimer des fichiers.

=== graceful-fs

_graceful-fs_ ([URL]#https://npmjs.com/graceful-fs#) est identique
au module Node{nbsp}``fs``.

La différence se situe sous le capot : le module gère les défaillances
du système et tente d'accéder à nouveau aux ressources demandées
si les erreurs sont liées à des problèmes de performance.

C'est un module à utiliser si notre application dépend fortement de la disponibilité
du système de fichiers et si celui-ci est fortement sollicité.

=== chokidar

_chokidar_ ([URL]#https://npmjs.com/chokidar#) crée des observateurs du
système de fichiers.
Il gère les différences des systèmes d'exploitation et nous permet d'écrire
un seul et même code.

C'est la bibliothèque vers laquelle se tourner lorsque nous avons besoin
de déclencher des actions quand des fichiers sont modifiés.


[[databases]]
== Stocker dans des bases de données

Node sait communiquer avec tout type de bases de données grâce à l'écosystème{nbsp}``npm``.
Préférez les modules faisant état de pilote natif/binaire –
le transfert de données n'en sera que plus rapide.

=== db-migrate

_db-migrate_ ([URL]#https://npmjs.com/db-migrate#) est un outil de gestion
de migrations pour MySQL, SQLite, MongoDB et PostgreSQL.
À l'aide de scripts de migration, il rend reproductibles des changements
de structure dans une base de données – ajout ou suppression de champ, de table
ou d'index.

=== knex

_knex_ ([URL]#https://npmjs.com/knex#) propose d'interagir et d'interroger
des bases de données SQL comme PostgreSQL, MariaDB, MySQL et SQLite.

Les requêtes s'écrivent en SQL pur ou en utilisant une API dite "`fluide`",
pour ne pas écrire le SQL à la{nbsp}main.

[source,javascript]
.knex.js
----
include::{sourceDir}/knex.js[]
----
<1> Indique que nous allons nous connecter à une base de données de type SQLite.
<2> Spécifie l'emplacement de la base de données.
<3> Effectue une recherche floue sur les lignes dont le titre contient le mot{nbsp}``'Node'``.
<4> Compte le nombre de lignes et retourne le premier (et seul) résultat de la requête.
<5> Affiche `[ { id: 1, title: 'Node.js ', created_at: '2018-07-11 10:34:33' } ]`.
<6> Affiche `{ count: 3 }`.

=== bookshelf

_bookshelf_ ([URL]#https://npmjs.com/bookshelf#) est une surcouche à <<knex,_Knex_>>,
écrite par les mêmes personnes.
Elle modélise les données sous formes d'objets et de schémas (ORM) pour
automatiser des actions et ajouter plus d'"`intelligence`" à notre modèle de données.

=== sequelize

_sequelize_ ([URL]#https://npmjs.com/sequelize#) est une alternative
à <<knex,_Knex_>> et à <<bookshelf,_Bookshelf_>>.
Elle gère des schémas de données de manière optionnelle, mais aussi les migrations.
Ces dernières permettent de scripter les changements de structure d'une base
de données, de les tester en local avant de les jouer en production.

=== mongoose

_mongoose_ ([URL]#https://npmjs.com/mongoose#) sert à composer des modèles
de données pour la base de données MongoDB – dite NoSQL.
Elle définit des comportements annexes comme des mixins
ou des _accesseurs_ dynamiques.

=== levelup

_LevelDB_ ([URL]#https://npmjs.com/levelup#) est un système de bases de
données clé/valeur extrêmement modulaire.
Le stockage se fait sur disque par défaut, mais il peut évoluer vers du stockage
en mémoire (module `memdown`) ou même dans un navigateur web (avec IndexedDB).

[source,javascript]
.levelup.js
----
include::{sourceDir}/levelup.js[]
----
<1> Crée la connexion à la base de données en mémoire.
<2> Recherche un enregistrement après l'avoir enregistré en mémoire.
<3> Affiche `{ title: 'Node.js' }`.

=== redis

_redis_ ([URL]#https://npmjs.com/redis#) est un gestionnaire de bases de données
clés/valeurs distribuées et performantes.

[source,javascript]
.redis.js
----
include::{sourceDir}/redis.js[]
----

_hiredis_ ([URL]#https://npmjs.com/hiredis#) est un pilote {cpp} qui
augmente les performances de connexion à une base de données{nbsp}__redis__.

=== elasticsearch

_elasticsearch_ ([URL]#https://npmjs.com/elasticsearch#) est un client pour
simplifier la connexion à une base de données Elasticsearch.
Une base de ce type est particulièrement adaptée à l'indexation des données,
pour des recherches performantes et complexes.

[[cli]]
== Ligne de commande

Ces modules complètent le panorama déjà très varié présenté
dans le <<../chapter-08/index.adoc,chapitre{nbsp}8>>.

=== yargs-parser

_yargs-parser_ ([URL]#https://npmjs.com/yargs-parser#) est le module
d'interprétation des arguments utilisé par le module _yargs_.
C'est une alternative plus puissante et plus complexe que _minimist_.

=== args

_args_ ([URL]#https://npmjs.com/args#) est un module minimaliste
pour interpréter les arguments, les structurer et afficher une aide
claire à nos utilisateurs et utilisatrices.

Cerise sur le gâteau : le module suggère un choix de commande en cas
d'erreur de frappe.

=== caporal

_caporal_ ([URL]#https://npmjs.com/caporal#) est un framework complet
pour bâtir des applications en ligne de commande.
Il gère les classiques arguments et options ainsi que les sous-commandes,
les types de valeurs et l'autocomplétion.

=== promptly

_promptly_ ([URL]#https://npmjs.com/promptly#) est un utilitaire pour
poser des questions, valider et travailler avec les réponses obtenues.
Il est minimaliste et a un faible nombre de dépendances.

=== supports-color

_supports-color_ ([URL]#https://npmjs.com/supports-color#) vérifie
si le contexte d'exécution du programme en ligne de commande
supporte les couleurs.

Cela nous évite d'envoyer des codes ANSI, qui, seraient affichés
au lieu d'être interprétés comme des couleurs.


[[webapp]]
== Applications{nbsp}web

Ces modules complètent le panorama déjà très varié présenté
dans le <<../chapter-07/index.adoc,chapitre{nbsp}7>>.

=== fastify

_fastify_ ([URL]#https://npmjs.com/fastify#) est un framework
inspiré de _express_.
Il se focalise sur la simplicité de l'expérience de développement et sur
de hautes performances.
Il sait valider les données sortantes à l'aide de schémas.

Pour aller au-delà des données, il se combine avec le module _point-of-view_
([URL]#https://npmjs.com/point-of-view#).
Vous avez ainsi accès à l'utilisation de <<templating,modules de templating>>.

=== passport

_passport_ ([URL]#https://npmjs.com/passport#) est une bibliothèque modulaire
d'authentification pour _express_.
Elle se branche à différents mécanismes pour vérifier les utilisateurs :
utilisateur et mot de passe, compte GitHub, Twitter, OAuth, etc.

Les sessions d'utilisateurs se gèrent à côté – pour mémoriser
qui est connecté ou non, et avec quel identifiant sécurisé et unique.

Référez-vous à sa documentation pour des exemples détaillés d'utilisation.

=== restify

_restify_ ([URL]#https://npmjs.com/restify#) est un framework web
spécialisé dans la création d'API{nbsp}HTTP.

Il gère les versions de routes et expose un client permettant de consommer
des données sur d'autres API{nbsp}REST – proxy.

[source,javascript]
.restify.js
----
include::{sourceDir}/restify.js[]
----


=== faye

_faye_ ([URL]#https://npmjs.com/faye#) est un serveur WebSocket pour communiquer
en temps réel entre un client et un serveur.
Il sait débrayer vers Ajax ou JSON-P pour les navigateurs anciens qui
ne comprennent pas WebSocket.

[source,javascript]
.faye.js
----
include::{sourceDir}/faye.js[]
----

Cet exemple de serveur minimaliste expose un point d'entrée auquel on peut accéder
via le client _Faye_, dans un navigateur ou via un autre script{nbsp}Node.

Tout message émit par un client sera relayé auprès des autres clients
connectés.

=== swagger-client

_swagger-client_ ([URL]#https://npmjs.com/swagger-client#) sert à valider
des requêtes et des réponses HTTP en fonction de schémas qui répondent
à la spécification OpenAPI.

Cette spécification permet entre autres de gérer automatiquement les routes
de notre application pour nous concentrer sur le code qui génère les données de sortie.

[[templating]]
== Modules front-end et templating

Les bibliothèques de templating proposent d'associer
une structure de données à une logique de présentation.
Pour la plupart, elles fonctionnent aussi bien sous Node que dans les navigateurs,
ce qui est une excellente nouvelle pour partager des comportements d'affichage
entre les deux environnements.

Tous les modules que nous allons voir généreront cette sortie{nbsp}HTML :

[source,html]
----
<!DOCTYPE html>
<html>
<head>
  <title>Template demo</title>
</head>
<body>
  <ul>
    <li>CSS maintenables</li>
    <li>Node.js</li>
    <li>Open Sky</li>
  </ul>
</body>
</html>
----

=== nunjucks

_nunjucks_ ([URL]#https://npmjs.com/nunjucks#) est un portage de _Jinja_,
bibliothèque bien connue par les adeptes de Python.
Sa syntaxe inclut des fonctionnalités comme les filtres, les blocs ou
l'héritage de gabarit.

[source,javascript]
.template.html
----
include::{sourceDir}/template.html[]
----

=== handlebars

_handlebars_ ([URL]#https://npmjs.com/handlebars#) et son prédécesseur _mustache_
sont les vétérans du templating Node.
Leur parti pris est de proposer le minimum de logique afin que celle-ci
reste au plus près des données.

_handlebars_ sait aussi précompiler les gabarits sous forme de fonctions ECMAScript.

[source,javascript]
.template.hbs
----
include::{sourceDir}/template.hbs[]
----

=== pug

_pug_ ([URL]#https://npmjs.com/pug#) opte pour un parti minimaliste qui
repose entièrement sur l'indentation.
Son mécanisme de blocs facilite la réutilisation d'éléments de présentation.

[source,javascript]
.template.pug
----
include::{sourceDir}/template.pug[]
----

=== ejs

_ejs_ ([URL]#https://npmjs.com/ejs#) part du principe qu'il n'y a pas besoin
d'un langage de templating autre qu'ECMAScript.
Donc c'est tout simplement ce qui vous sera proposé, impliquant de ce fait
une faible courbe d'apprentissage.

[source,javascript]
.template.ejs
----
include::{sourceDir}/template.ejs[]
----

=== react

_react_ ([URL]#https://npmjs.com/react#) est une bibliothèque de présentation
dite "`réactive`" et orientée composants.
Elle génère un arbre visuel à partir de données passées en entrée.
Cet arbre est ensuite transformé en HTML, en interface iOS ou Android, entre autres.

[source,jsx]
.template.jsx
----
include::{sourceDir}/template.jsx[]
----

=== storybook

_storybook_ ([URL]#https://github.com/storybooks/storybook#) complète <<react,React>>
et d'autres frameworks de _templating_ en créant un catalogue de composants
auto-documentés.
Les composants sont affichés en même temps que le code nécessaire pour les utiliser
dans une autre application.

[[testing]]
== Tester notre code

Le module `assert` intégré à Node suffit pour démarrer.
Il existe cependant tout un outillage pour tester notre code à destination de
Node (tests unitaires) ou des navigateurs (tests fonctionnels) ainsi que pour
écrire des assertions plus facilement.

=== tape

_tape_ ([URL]#https://npmjs.com/tape#) est une bibliothèque
d'exécution de tests minimaliste qui se base sur le
_Test Anything Protocol_ (_TAP_, [URL]#https://testanything.org#).
Elle embarque aussi le minimum vital pour écrire des assertions.

[source,javascript]
.tape.js
----
include::{sourceDir}/tape.js[]
----
<1> Création d'un test.
<2> Écriture d'une assertion.

=== chai

_chai_ ([URL]#https://npmjs.com/chai#) est une bibliothèque poussée d'assertions.
Son mécanisme chaîne permet de quasiment écrire des phrases pour exprimer
l'intention des choses à vérifier.

[source,javascript]
.chai.js
----
include::{sourceDir}/chai.js[]
----
<1> Vérification du type d'une variable.
<2> Vérification stricte de valeur d'une variable.
<3> Double vérification – il s'agit bien d'objet et il est vide, sans clé/valeur.

=== sinon

_sinon_ ([URL]#https://npmjs.com/sinon#) est un compagnon idéal pour
intercepter le fonctionnement interne de variables et d'objets.
Le module propose de créer des écouteurs (_spys_) et des bouchons
(_stubs_, _mocks_).

En d'autres termes, vous prenez la main sur des portions de votre propre
code pendant la durée des tests.
Ces techniques servent pour simuler des erreurs et différentes situations
tout en observant le comportement réel de notre{nbsp}code.

[source,javascript]
.sinon.js
----
include::{sourceDir}/sinon.js[]
----
<1> Création d'un bouchon pour la méthode `now()` d'un objet{nbsp}``Date``.
<2> Surcharge de la valeur retournée par la méthode `d.now()`.
<3> Nous constatons le nombre de fois où la méthode `d.now()` a été appelée.

Le module _sinon-chai_ ([URL]#https://npmjs.com/sinon-chai#)
intègre _sinon_ avec le mécanisme d'assertions de{nbsp}<<chai,_chai_>>.

=== nyc

_nyc_ ([URL]#https://npmjs.com/nyc#) génère une couverture de code.
Il inspecte le code exécuté pendant les tests et en déduit les portions
qui n'ont pas été visitées et, donc, qui n'ont pas été testées.
C'est un indicateur utile pour attester de la fiabilité d'une base de code
– plus la couverture est importante, plus il y a de chances que les cas à la marge
aient été vérifiés.

.Couverture de code visualisée dans un terminal.
image::images/nyc-cli.png[width="85%"]

_nyc_ se greffe sur n'importe quelle bibliothèque d'exécution de tests.
Sous le capot, c'est le module _istanbul_ ([URL]#https://npmjs.com/istanbul#)
qui est utilisé pour effectuer les calculs de couverture de{nbsp}code.

.Couverture de code visualisée dans un navigateur{nbsp}web.
image::images/nyc-web.png[width="85%"]

=== karma

_karma_ ([URL]#https://npmjs.com/karma#) pilote l'exécution de tests
depuis un ou plusieur(s) navigateurs web.
Ces derniers (Chrome, Safari, Firefox, etc.) se pilotent sur notre ordinateur,
depuis une machine virtuelle (VirtualBox) ou même par le biais d'un service
en ligne (SauceLabs, BrowserStack, etc.).

.Exemple d'exécution de tests en continu avec{nbsp}Karma.
image::images/karma.png[width="85%"]

=== supertest

_supertest_ ([URL]#https://npmjs.com/supertest#) sert à tester une interface HTTP.
Le module envoie des requêtes et nos assertions vérifient qu'elles retournent
bien ce qui est attendu – code HTTP, structure de réponse etc.

Je trouve ce module pratique pour tester des choses qui seraient difficiles
à couvrir seulement avec des tests unitaires.

[[internet-of-things]]
== Objets connectés

Node a bénéficié de l'engouement autour des objets connectés grâce à sa nature
asynchrone et à sa légèreté.
C'est une plate-forme de choix pour dialoguer ou embarquer dans des
nano-ordinateurs, réfrigérateurs et autres ampoules connectées.

=== nitrogen

_nitrogen_ ([URL]#https://npmjs.com/nitrogen#) gère les interactions entre
différents périphériques, sur un même réseau local et à travers Internet.

La bibliothèque se base sur un mécanisme déclaratif de fonctionnalités et de
terminaux ainsi que la publication de messages.

=== serialport

_serialport_ ([URL]#https://npmjs.com/serialport#) est la bibliothèque de base
pour communiquer avec le _port série_ d'un appareil.
Un câble USB suffit ensuite pour envoyer nos instructions à cet appareil.

=== firmata

_firmata_ ([URL]#https://npmjs.com/firmata#) est un _firmware_, un protocole
de communication, ainsi qu'une bibliothèque de communication pour microcontrôleur
Arduino.

Le module Node apprend ainsi à communiquer avec un Arduino préalablement
flashé avec Firmata.
Cela nous permet notamment d'écrire des applications en JavaScript au lieu
d'utiliser{nbsp}du{nbsp}C.

=== johnny-five

_johnny-five_ ([URL]#https://npmjs.com/johnny-five#) est une bibliothèque
haut{nbsp}niveau pour Arduino, Raspberry{nbsp}Pi et tout autre microcontrôleur.
Elle simplifie les interactions avec des moteurs, des servo-contrôleurs,
des capteurs etc.

=== node-red

_node-red_ ([URL]#https://npmjs.com/node-red#) est une interface visuelle
pour programmer des flux de données entre objets connectés.
Le projet émane d'employé·e·s{nbsp}d'IBM.

L'exécutable démarre un serveur web dont l'interface nous sert à relier
des sources de données, des réactions à des événements avec des objets prêts à
recevoir les instructions.


== Accessibilité

L'écosystème{nbsp}``npm`` a participé à un essor d'outillage lié à l'accessibilité
d'applications web.
Auparavant, les outils étaient difficilement automatisables.

=== a11y

_a11y_ ([URL]#https://npmjs.com/a11y#) est un automate d'inspection de pages web.
Il détecte des problèmes de contrastes, de calques qui masquent du contenu
ou d'éléments qui ne seraient pas navigables au clavier, entre autres.

C'est un excellent outil pour améliorer la qualité d'une application tout en
l'ouvrant à un public trop souvent mis de{nbsp}côté.

----
$ npx a11y https://oncletom.io
  ✖ Controls and media elements should have labels

  #search > .form-control


✔ This element does not support ARIA roles
✔ Elements with ARIA roles must be in the correct scope
✔ This element has an invalid ARIA attribute
✔ ARIA state and property values must be valid
----

=== a11y.css

_a11y.css_ ([URL]#https://npmjs.com/a11y.css#) est une feuille de styles CSS
à injecter dans une page web pour rendre visible des incohérences.
Parmi ces dernières, nous retrouvons des boutons sans intitulé, l'absence
de langue du document ou encore l'absence de bouton de validation de formulaire
ou de texte alternatif d'images.

=== lighthouse

_lighthouse_ ([URL]#https://npmjs.com/lighthouse#) est l'outil d'analyse de
performances, de référencement (SEO) et d'accessibilité embarqué dans
le navigateur web Google{nbsp}Chrome.

Ce module{nbsp}``npm`` le rend utilisable depuis un terminal et écrit le rapport
dans un fichier{nbsp}HTML.

=== storybook-addon-a11y

_storybook-addon-a11y_ ([URL]#https://npmjs.com/storybook-addon-a11y#)
est une extension au module <<storybook,_storybook_>>.
Le module signale les problèmes d'accessibilité au niveau de chaque composant.
Le suivi est ainsi fait en continu, au plus proche des composants distribués
et utilisés dans les applications.


== Travailler avec des images, des sons et des vidéos

=== sharp

_sharp_ ([URL]#https://npmjs.com/sharp#) est un module de redimensionnement
et de transformation d'images JPG, PNG et WebP écrit en JavaScript et{nbsp}{cpp}.
Il ne nécessite pas de programme externe et est compatible avec une approche
en flux.

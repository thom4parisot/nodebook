:chapterNumber: A
:chapterId: appendix-a
:sectnums:
:nodeCurrentVersion: v10
:npmCurrentVersion: v6
:revdate: {docdate}
:sourceDir: ./examples
:imagesdir: {indir}
ifdef::env[]
:imagesdir: .
endif::[]

[appendix]
= Sélection de modules npm

Cette annexe est une sélection de modules npm ([URL]#https://npmjs.com#)
à laquelle vous réferer pour démarrer rapidement mais aussi pour découvrir
des usages et des domaines d'applications insoupçonnés.

J'ai bâti cette liste à partir de mon expérience personnelle et sur la confiance
que je porte aux personnes à l'origine de ces modules.

include::../docs/tip-versions.adoc[]
include::../docs/tip-examples.adoc[]


== Boîte à outil du quotidien

Ces modules adressent des besoins quotidiens, pour travailler plus rapidement
sur des structures ECMAScript.

=== lodash

_lodash_ ([URL]#https://npmjs.com/lodash#) est une collection de plusieurs
dizaines de fonctions pour travailler plus facilement avec des chaînes de caractères,
des tableaux, des fonctions et des objets.

Vous pourrez ainsi filtrer, sélectionner, fusionner, vérifier et composer
de nouvelles variables aussi bien pour Node que dans les navigateurs web.

[source%interactive,javascript]
.lodash.js
----
include::{sourceDir}/lodash.js[]
----
<1> Affiche `Thor`.

=== he

_he_ ([URL]#https://npmjs.com/he#) est un utilitaire pour encoder et décoder
des entités HTML dans des chaînes de caractères.

[source%interactive,javascript]
.he.js
----
include::{sourceDir}/he.js[]
----
<1> Affiche `<h1>Blog Post</h1>`.
<2> Affiche `++&#x3C;h1&#x3E;Blog Post&#x3C;/h1&#x3E;++`.

=== chance

_chance_ ([URL]#https://npmjs.com/chance#) crée des données de manière aléatoire.
Le module retourne aussi des prénoms fictifs mais aussi des numéros de téléphone,
des nombres, des paragraphes, des dates d'anniversaire, des identifiants Android ou Apple, etc.

Il s'utilise surtout pour générer des données factices à des fins de tests,
en attendant les vraies données.

=== date-fns

_date-fns_ ([URL]#https://npmjs.com/date-fns#) est une collection de fonctions
pour travailler avec des dates, plus facilement qu'avec l'objet natif `Date`.

Vous pouvez formatter, ajouter ou retirer des jours, vérifier si deux périodes
de temps se chevauchent ou si deux dates font partie d'une même semaine calendaire.


=== tcomb

_tcomb_ ([URL]#https://npmjs.com/tcomb#) renforce la création de structures
typées et immutables.
Ça a pour effet de réduire les effets de bord de nos applications lorsque les
données n'ont pas la structure attendue.

[source%interactive,javascript]
.tcomb.js
----
include::{sourceDir}/tcomb.js[]
----
<1> Définition d'une structure stricte qui a pour propriété `lat` et `lon`, pour _latitude_ et _longitude_.
<2> Cet appel va lancer une exception car la propriété `long` est inconnue.
<3> Cet appel va lancer une exception car la propriété `lon` doit être un nombre.

=== eventemitter3

_eventemitter3_ ([URL]#https://npmjs.com/eventemitter3#) permet de gérer
des événements de manière uniforme dans un script Node et dans les navigateurs web.

[source%interactive,javascript]
.eventemitter3.js
----
include::{sourceDir}/eventemitter3.js[]
----
<1> Affiche `[ [Function], [Function] ]`.
<2> Affiche `on: ping,ping` puis `once: ping,ping`.
<3> Affiche `on: ping,ping`.
<4> N'affiche rien, l'événement étant désormais déconnecté.


[[dev]]
== Pendant le développement

=== debug

_debug_ ([URL]#https://npmjs.com/debug#) rend l'affichage de messages de déboguage
optionnels.
Les messages s'affichent en présence d'une variable d'environnement.
Nous pouvons ainsi lancer un processus et retracer un cheminement complexe de
données.

Par défaut, les messages ne s'affichent pas :

----
$ node examples/debug.js
----

Les messages du débogueur `app` s'affichent désormais :

[subs="+quotes"]
----
$ ##DEBUG=app## node examples/debug.js
  app fromages [ 'livarot', 'chaource' ] +0ms
----

Nous pouvons en afficher plusieurs en même temps, en usant du caractère `*`
ou en séparant les noms de débogueurs avec le caractère `,` :

[subs="+quotes"]
----
$ DEBUG=app##*## node examples/debug.js
  app fromages [ 'livarot', 'chaource' ] +0ms
  app:timer now 1531304027271 +0ms
----

[source,javascript]
.debug.js
----
include::{sourceDir}/debug.js[]
----
<1> Création du débogueur `app`.
<2> Création du débogueur `app:timer`.
<3> La fonction de débogage s'utilise de la même manière que `console.log`.
<4> Cette fonction fait appel au débogueur `app:timer`.

=== nodemon

_nodemon_ ([URL]#https://npmjs.com/nodemon#) relance le processus actif
dès qu'un fichier ECMAScript ou JSON est modifié.
C'est un module exécutable particulièrement utile lorsque nous voulons prendre
en compte les changements dans une application qui tourne en continu.
C'est le cas des application web, entre autres.

Pour en savoir plus, rendez-vous à la section
<<../chapter-07/index.adoc#dev,Pendant le développement : relancer le serveur automatiquement>>
du <<../chapter-07/index.adoc#,chapitre 7>>.

=== npm-run-all

_npm-run-all_ ([URL]#https://npmjs.com/npm-run-all#) est mon outil favori
pour composer avec les _scripts npm_.
Il a l'avantage d'être versatile, de régler finement ce qui
doit être exécuté en parallèle ou séquentiellement.
Le module transfère les arguments aux sous-scripts.

[source,json]
.package.json
----
{
  "...": "...",
  "scripts": {
    "build": "npm-run-all -p 'build:*' -s start",
    "build:css": "sass ...",
    "build:js": "browserify ...",
    "start": "node server.js"
  }
}
----

=== husky

_husky_ ([URL]#https://npmjs.com/husky#) intègre Git aux
<<../chapter-05/index.adoc#scripts,scripts npm>>.
Autrement dit, vous pouvez déclencher des scripts lors d'événements Git,
lors d'un _push_, avant un _commit_ ou après avoir rapatrié des changements.

[source,json]
.package.json
----
{
  "...": "...",
  "scripts": {
    "precommit": "lint-staged",
    "post-merge": "npm install"
  }
}
----

La liste complète des _hooks_ Git se trouve dans la documentation
officielle à cette adresse [URL]#https://git-scm.com/docs/githooks#.

=== onchange

_onchange_ ([URL]#https://npmjs.com/onchange#) observe une liste de fichiers
en continu et délenche une commande dès que l'un d'entre eux est modifié.
C'est particulièrement utile pour reconstruire des fichiers de configuration
ou des fichiers front-end pendant le développement, sans avoir à le faire à la main.

[source,json]
.package.json
----
{
  "...": "...",
  "scripts": {
    "build:css": "sass ...",
    "dev": "npm-run-script -p 'watch:*' start",
    "watch:css": "onchange '**/*.scss' -- npm run build:css",
    "start": "node server.js"
  }
}
----

=== tiny-lr

_tiny-lr_ ([URL]#https://npmjs.com/tiny-lr#) est une implémentation minimale
du protocole _livereload_ ([URL]#http://livereload.com/#).
Il s'intègre à un serveur HTTP ou à une application _express_ pour relayer
la liste des fichiers modifié côté client.

Le script ou l'extension navigateur client remplace les anciens fichiers
par les nouveaux pour refléter les changements sans recharger la page.

=== livereactload

_livereactload_ ([URL]#https://npmjs.com/livereactload#) recherche les composants
<<react,React>> à chaud.
C'est à dire sans raffraichir la page et sans perdre l'état des données.
C'est un module indispensable pour développer des applications front-end réactives.

Rendez-vous dans la section <<../chapter-09/index.adoc#livereload,changements en temps-réel>>
du <<../chapter-09/index.adoc#,chapitre 9>> pour en savoir plus sur son
installation et son intégration.


== Protéger nos applications

Le code que nous écrivons se protège dès la conception et dans le temps.
Des modules nous protègent en filtrant les tentatives d'exploitation de nos
applications tandis que d'autres vérifient si le code déployé est toujours sûr.

=== sanitize-filename

_sanitize-filename_ ([URL]#https://npmjs.com/sanitize-filename#) nettoie
une variable de tout caractère ambigü ou qui ne serait pas attendu de la part
d'un·e usagèr·e.

[source%interactive,javascript]
.sanitize-filename.js
----
include::{sourceDir}/sanitize-filename.js[]
----
<1> Affiche `aucun-problème.txt`.
<2> Affiche `+.....sshid_rsa+` — les caractères `/` sont nettoyés car il permettrait de créer des chemins compromettant pour l'application ou le système d'exploitation.

=== helmet

_helmet_ ([URL]#https://npmjs.com/helmet#) est un module à intégrer systématiquement
dans toute application _express_.
Il ajoute des entêtes HTTP _Content-Security Policy_, _Strict Transport Policy_
et d'autres qui empêchent le détournement d'informations.

Chacune de ses protections se configure aussi au cas par cas.
Elles s'intègrent manuellement dans d'autres types d'applications web,
y compris un serveur HTTP natif à Node.

=== dompurify

_dompurify_ ([URL]#https://npmjs.com/dompurify#) nettoie un contenu HTML
pour le rendre affichable en toute sécurité.
Il nettoie des scripts indésirés, des balises mal formées qui casseraient l'affichage,
ou encore des _iframes_ qui injecteraient des contenus tiers sans notre consentement.

=== filenamify

_filenamify_ ([URL]#https://npmjs.com/filenamify#) nettoie une valeur
pour retirer tout caractère invalide dans un nom de fichier.
C'est pratique dans le cas où vous laissez la possibilité à un·e usagèr·e
de choisir un nom de fichier sans pour autant leur laisser la possibilité
de mettre en danger le système ou l'application.

=== retire.js

_retire.js_ ([URL]#https://npmjs.com/retire#) est un module npm pour
scanner soi-même des vulnérabilités connues dans des fichiers JavaScript.
Il est complémentaire de la commande <<../chapter-05/index.adoc#audit,`npm audit`>>
car il inspecte des dépendances qui ne sont pas forcément sur npm.

=== snyk

_snyk_ ([URL]#https://npmjs.com/snyk#) est à la fois un service en ligne
et un module pour vérifier la présence de failles de sécurité connues
dans les dépendances de nos projets.


== Vérifier la syntaxe de notre code

La vérification syntaxique est un mécanisme s'assurant que votre code respecte
la grammaire du langage associé.
Elle révèle aussi des anomalies fondamentales (balise mal fermée,
expression inconnue etc.) et renforce des pratiques de programmation commune
au groupe de développement.

Vérifier la syntaxe de notre code est un excellente première étape avant
d'introduire des tests unitaires ou fonctionnels.

=== htmlhint

_htmlhint_ ([URL]#https://npmjs.com/htmlhint#) vérifie la structure de
nos documents HTML.
Il rapporte les doublons d'attributs `id`, la présence de balises
mal formées, l'absence de balise fermante ou encore l'existance de chaînes de
caractère non-imprimables dans des attributs critiques, entre autres.

Prenons en exemple le document suivant :

[source,html]
.sample.html
----
include::{sourceDir}/sample.html[]
----

Une lecture distraite pourrait nous faire passer à côté d'erreurs et
d'inconsistances de programmation.
Ce genre d'erreurs passe d'autant plus inaperçues que la base de code
devient volumineuse et change fréquemment.

L'exécution de _htmlhint_ avec ses règles par défaut remontera les alertes
suivantes :

----
$ ../node_modules/.bin/htmlhint sample.html
sample.html:
line 1, col 1: Doctype must be first.
line 8, col 10: Id redefinition of [ btn ].
line 10, col 3: Tagname [ BUTTON ] must be lower case.
...
line 10, col 52: Tagname [ BUTTON ] must be lower case.
----

=== eslint

_eslint_ ([URL]#https://npmjs.com/eslint#) est l'outil de vérification
syntaxique pour ECMAScript par excellence.
Il est souple, rapide à mettre en œuvre et s'adapte à des contextes complexes.
J'aime son mécanisme de configuration de règles : utilisation systématique du
<<../chapter-03/index.adoc#strict,mode strict>>, nombre maximum de paramètres
de fonctions, objets non-déclarés, variables inconnues etc. +
_eslint_ expose également des fonctions pour créer vos propres règles métier.

[source,json]
.package.json
----
include::{sourceDir}/package-eslint.json[]
----

Le niveau de sévérité de chaque règle est représenté par un identifiant :

- `none` : règle désactivée ;
- `warn` : affiche un avertissement ;
- `error` : affiche une erreur (le processus se terminera avec un code d'erreur).

Certaines règles demandent ou acceptent des arguments supplémentaires.
Elles sont toutes documentées sur le site web du projet
[URL]#http://eslint.org/docs/rules/#.

Le détail des règles de configuration mises en application sont disponible
simplement en parcourant l'arborescence du dépôt de code disponible sur
[URL]#https://github.com/airbnb/javascript#.

=== csslint

_csslint_ ([URL]#https://npmjs.com/csslint#) est un outil de vérification
syntaxique de feuilles de style CSS.
Il a été créé par deux anciens ingénieurs de _Yahoo!_.
Leurs anciens travaux dans le domaine de la performance ont influencé
l'architecture et le choix des règles par défaut.

_csslint_ fournit les mécanismes de vérification adéquats pour alerter de
possibles effets de bord de _box model_, de déclaration incompatible de
`@font-face`, de _vendor prefix_ dépréciés ou encore de combinaisons de
propriétés connues pour casser l'affichage dans certains navigateurs.

Prenons par exemple le fichier CSS suivant :

[source,css]
.sample.css
----
include::{sourceDir}/sample.css[]
----

_csslint_ génèrera trois alertes en lisant le fichier `sample.css` et ce,
même si celui-ci est syntaxiquement parfaitement valide :

----
$ ../node_modules/.bin/csslint sample.css

csslint: There are 3 problems in sample.css.

sample.css
1: warning at line 4, col 11
Values of 0 shouldn't have units specified.
  border: 0px solid black;

sample.css
2: warning at line 4, col 3
Using height with border can sometimes make
  elements larger than you expect.
  border: 0px solid black;
...
----

=== doiuse

_doiuse_ ([URL]#https://npmjs.com/doiuse#) est un utilitaire qui se repose
sur la base de données du site communautaire [URL]#https://caniuse.com#.
Il nous alerte des possibles incompatibilités de syntaxe en fonction de la liste
de navigateurs web à supporter.
Cette liste concerne aussi bien des versions spécifiques (Internet Explorer 8)
que des parts de marché (tous les navigateurs avec plus de 5% de parts de marché).

L'exemple suivant illustre les alertes relevées par _doiuse_ dans le cas
d'une recherche de compatibilité avec Internet Explorer 6 et Internet
Explorer 7 :

----
$ ../node_modules/.bin/doiuse -b 'ie < 8' sample.css
sample.css:1:1: CSS 2.1 selectors not supported by: IE (6)
sample.css:8:1: CSS 2.1 selectors not supported by: IE (6)
sample.css:12:1: CSS3 Transitions not supported by: IE (6,7)
sample.css:14:1: CSS 2.1 selectors not supported by: IE (6)
----

[[optimize]]
== Optimiser notre code

Commentaires, indentations ou encore noms de variables : tout ça occupe de
la place — autant d'octets transférés sur le réseau avant d'être exécutés
par un client web.
Les outils d'optimisation offrent l'opportunité aux développeurs et développeuses
d'écrire du code sans compromettre sa lisibilité et sa maintenabilité.

Les minifieurs et optimiseurs mettent en œuvre différentes techniques pour
réduire le poids de notre code :

- suppression des commentaires et caractères non-significatifs ;
- renommage de variables ;
- factorisation d'occurrences multiples similaires ;
- suppression des instructions relatives au débogage/développement ;
- suppression du code inutilisé ;
- écriture automatique de code pour supporter des environnements anciens ou futurs.

=== uglify-js2

_UglifyJS_ ([URL]#https://npmjs.com/uglify-js2#) est un des premiers
compresseurs à utiliser une représentation syntaxique en arbre
(_Abstract Syntax Tree_ — _AST_) en lieu et place des classiques
optimisations à coups d'expressions régulières.

Cette méthode élargit les perspectives de la compression via de
la réécriture de code :

- _hoisting_ des variables (remontée de leur déclaration en début de _scope_) ;
- combinaison des déclarations de variables ;
- factorisation des valeurs de variables ;
- réécriture partielle d'expressions ;
- injection en ligne du contenu de variables.

_UglifyJS_ s'utilise en ligne de commande ou comme un module Node.

=== postcss

_PostCSS_ ([URL]#https://npmjs.com/postcss#) est une optimiseur CSS modulaire.
Cet outil est construit autour d'un parseur CSS, d'un arbre syntaxique
et d'un compilateur texte.
C'est la même recette qui a participé au succès et à la richesse fonctionnelle
d'outils comme <<uglify-js2,UglifyJS>> et <<eslint,ESLint>>.

Avec une ou plusieurs extensions, vous basculez d'un optimiseur de code
vers la possibilité de créer votre propre préprocesseur, à la Sass !

=== autoprefixer

_autoprefixer_ ([URL]#https://npmjs.com/autoprefixer#) est _le_ module qui
vous épargnera l'écriture de centaines de lignes CSS.
Il ajoute automatiquement les préfixes navigateurs aux bons endroits
— `-webkit`, `-moz`, etc.

_autoprefixer_ s'utilise comme extension au module <<postcss,PostCSS>>,
en ligne de commande ou comme module Node.

----
$ ../node_modules/.bin/postcss sample.css \
    --use autoprefixer  | grep transition
          transition: font-weight 0.2s ease;
----

Le choix de compatibilité avec les navigateurs repose sur la variable
d'environnement `BROWSERSLIST`, gérée par le module _browserslist_
([URL]#https://npmjs.com/browserslist#) :

----
$ export BROWSERSLIST='firefox > 8'
$ ../node_modules/.bin/postcss sample.css \
    --use autoprefixer | grep transition
     -moz-transition: font-weight 0.2s ease;
          transition: font-weight 0.2s ease;
----

=== uncss

_uncss_ ([URL]#https://npmjs.com/uncss#) est le pendant inverse d'_autoprefixer_
puisqu'il se charge de supprimer le code CSS inutilisé.
Il s'utilise de manière autonome ou comme module <<postcss,PostCSS>>.

Le module charge une ou plusieurs pages web, calcule la différence entre
les règles utilisées et celles qui ne le sont pas.
Libre à vous de mentionner une liste blanche de règles à ne jamais supprimer.

=== csswring

_csswring_ ([URL]#https://npmjs.com/csswring#) est un minifieur de code CSS
qui s'interface lui aussi avec <<postcss,PostCSS>>.
Vous lui donnez du code, il en ressort une version avec le minimum de caractères
possibles.

=== google-closure-compiler-js

_Google Closure Compiler_ ([URL]#https://npmjs.com/google-closure-compiler-js#)
est un compilateur ECMAScript plus poussé qu'_UglifyJS_ mais qui impose un
style d'écriture plus strict, voire plus contraignant.
Ses optimisations sont en général bien plus poussées et permettent d'atteindre
des niveaux de finesse difficiles à obtenir autrement.

=== csso

_csso_ ([URL]#https://npmjs.com/csso#) est une alternative à <<csswring,csswring>>.
Elle est écrite par l'équipe derrière la méthodologie BEM ([URL]#https://en.bem.info#).

_csso_ ira jusqu'à réécrire les codes couleurs, les `margin` et `padding` et
factorisera les sélecteurs similaires.

=== svgo

_svgo_ ([URL]#https://www.npmjs.com/svgo#) s'attaque au nettoyage des fichiers
graphiques vectoriels au format SVG.
Il simplifie les chemins et supprime les attributs et déclarations superflues.

Vous pouvez l'essayer en ligne sur [URL]#https://jakearchibald.github.io/svgomg/#
ou l'intégrer comme extension à <<postcss,PostCSS>>.

[[transpiling]]
== Passer d'un langage à un autre

Les préprocesseurs sont des outils de productivité pour CSS.
Ils transforment un langage plus avancé dans quelque chose qui est compris
par un navigateur web.

La même chose s'applique avec la compilation ou la transpilation pour ECMAScript,
pour utiliser dès maintenant une version du futur.

=== less

_less_ ([URL]#https://npmjs.com/less#) est un préprocesseur CSS.
Il gère des variables, de _mixins_, des calculs de couleurs et des fonctions
qui encouragent une écriture modulaire, plus logique et plus succincte.

[source]
.stylesheet.less
----
include::{sourceDir}/stylesheet.less[]
----

L'exécutable `lessc` compile le fichier LESS:

----
$ ../node_modules/.bin/lessc stylesheet.less
----

=== sass

_Sass_ ([URL]#https://npmjs.com/node-sass#) est un autre préprocesseur CSS.
Il est issu du monde Ruby et est désormais tout aussi puissant dans Node
grâce à _libsass_, un module rapide et portable écrit C++.

=== browserify

_browserify_ ([URL]#https://npmjs.com/browserify#) transforme des modules et du
code initialement écrit pour Node vers du code exécutable dans un navigateur Web.

Un puissant mécanisme de _transformations_ étend ses capacités au coup par coup.

Nous en parlons plus en détails dans la section
<<../chapter-09/index.adoc#browserify,importer des modules npm pour le web>>
au <<../chapter-09/index.adoc#,chapitre 9>>.

=== babel

_babel_ ([URL]#https://npmjs.com/babel#) est un outil qui permet de passer
d'une version d'ECMAScript à une autre, fonctionnalité par fonctionnalité.
C'est un outil indispensable pour écrire un code moderne et le faire
fonctionner dans des navigateurs anciens.

=== typescript

_TypeScript_ ([URL]#https://npmjs.com/typescript#) est un langage de programmation
typé.
Toute structure utilisée est décrite avec un schéma que TypeScript valide.
Nous sommes prévenu·e·s des erreurs avant même d'avoir exécuté notre code
car l'outillage sait si on manipule des données qui existent.

Au final, le code est transformé en ECMAScript et exécuté en tant que tel.
Le code est tellement propre que nous pouvons arrêter d'utiliser TypeScript
du jour au lendemain et travailler sur le code qu'il aura généré sans aucun problème.


[[fs]]
== Gérer des fichiers

Ces librairies nous permettent d'écrire moins de lignes de code
pour des besoins quotidiens de manipulation de fichiers.

=== mkdirp

_mkdirp_ ([URL]#https://npmjs.com/mkdirp#) est identique à la
commande Unix `mkdir -p`.
C'est-à-dire que les répertoires seront créés récursivement
s'ils n'existent pas au préalable.

Si nous utilisions le module Node `fs`, nous devrions créer l'arborescence de
répertoires par nous-même, niveau par niveau.

=== rimraf

_rimraf_ ([URL]#https://npmjs.com/rimraf#) est le pendant opposé _mkdirp_.
Il supprime une arborescence de manière récursive.
C'est l'équivalent de la commande Unix `rm -rf`.

Si nous utilisions le module Node `fs`, nous devrions supprimer d'abord
les fichiers puis les répertoires, un par un.

=== glob

_glob_ ([URL]#https://npmjs.com/glob#) est un utilitaire pour obtenir
une liste de fichiers en utilisant des motifs.

[source%interactive,javascript]
.glob.js
----
include::{sourceDir}/glob.js[]
----
<1> Affiche une liste de fichiers dont l'extension est `.js`.
<2> Affiche une liste de fichiers qui commencent par `re` et dont l'extension est `.js`.
<3> Affiche une liste de fichiers qui s'appelle `sample`, peu importe leur extension.

=== fs-extra

_fs-extra_ ([URL]#https://npmjs.com/fs-extra#) est une collection
de fonctions pour gérer les opérations de fichiers.
Le module inclut _rimraf_ et _mkdirp_ en plus d'autres fonctions récursives,
pour copier, déplacer ou supprimer des fichiers.

=== graceful-fs

_graceful-fs_ ([URL]#https://npmjs.com/graceful-fs#) est identique
au module Node `fs`.

La différence se situe sous le capot : le module gère les défaillances
du système et tente d'accéder à nouveau aux ressources demandées
si les erreurs sont liées à des problèmes de performance.

C'est un module à utiliser si notre application dépend fortement de la disponibilité
du système de fichiers et que celui est fortement sollicité.

=== chokidar

_chokidar_ ([URL]#https://npmjs.com/chokidar#) crée des observateurs du
système de fichiers.
Il gère les différences des systèmes d'exploitation et nous permet d'écrire
un seul et même code.

C'est la librairie vers laquelle se tourner lorsque nous avons besoin
de déclencher des actions quand des fichiers sont modifiés.


[[databases]]
== Stocker dans des bases de données

Node sait communiquer avec tout type de bases de données grâce à l'écosystème npm.
Préférez les modules faisant état de _driver_ natif/binaire —
les transferts de données n'en sera que plus rapide.

=== knex

_knex_ ([URL]#https://npmjs.com/knex#) propose d'interagir et d'interroger
des bases de données SQL comme PostgreSQL, MariaDB, MySQL et SQLite.

Les requêtes s'écrivent en SQL pur ou en utilisant une API dite "fluide",
pour ne pas écrire le SQL à la main.

[source,javascript]
.knex.js
----
include::{sourceDir}/knex.js[]
----
<1> Indique que nous allons nous connecter à une base de données de type SQLite.
<2> Spécifie l'emplacement de la base de données.
<3> Effectue une recherche floue sur les lignes dont le titre contient le mot 'Node'.
<4> Compte le nombre de lignes et retourne le premier (et seul) résultat de la requête.
<5> Affiche `[ { id: 1, title: 'Node.js ', created_at: '2018-07-11 10:34:33' } ]`.
<6> Affiche `{ count: 3 }`.

=== bookshelf

_bookshelf_ ([URL]#https://npmjs.com/bookshelf#) est une surcouche à <<knex>>,
écrite par les mêmes personnes.
Elle modèlise les données sous formes d'objets et de schémas (ORM) pour
automatiser des actions et ajouter plus d'"intelligence" à notre modèle de données.

=== sequelize

_sequelize_ ([URL]#https://npmjs.com/sequelize#) est une alternative
à <<knex>> et <<bookshelf>>.
Elle gère des schémas de données de manière optionnelle mais aussi les migrations.
Ces dernières permettent de scripter les changements de structure d'une base
de données, de les tester en local avant de les jouer en production.

=== mongoose

_mongoose_ ([URL]#https://npmjs.com/mongoose#) sert à composer des modèles
de données pour la base de données MongoDB — dite NoSQL.
Elle définit des comportements annexes comme des mixins
ou des _accesseurs_ dynamiques.

=== levelup

_LevelDB_ ([URL]#https://npmjs.com/levelup#) est un système de base de
données clé/valeur extrêmement modulaire.
Le stockage se fait sur disque par défaut mais il peut évoluer vers du stockage
en mémoire (module `memdown`) ou même dans un navigateur web (avec IndexedDB).

[source,javascript]
.levelup.js
----
include::{sourceDir}/levelup.js[]
----
<1> Crée la connexion à la base de données en mémoire.
<2> Recherche un enregistrement après les avoir enregistré en mémoire.
<3> Affiche `{ title: 'Node.js' }`.

=== redis

_redis_ ([URL]#https://npmjs.com/redis#) est une base de données
clé/valeur distribuée et performante.

[source,javascript]
.redis.js
----
include::{sourceDir}/redis.js[]
----

_hiredis_ ([URL]#https://npmjs.com/hiredis#) est un _driver_ C++ qui
augmente les performances de connexion à une base de données _redis_.

=== elasticsearch

_elasticsearch_ ([URL]#https://npmjs.com/elasticsearch#) est un client pour
simplifier la connexion à une base de données ElasticSearch.
Ce type de base est particulièrement adaptée à l'indexation des données,
pour des recherches performantes et complexes.

[[cli]]
== Ligne de commande

Ces modules complètent le panorama déjà très varié présenté
dans le <<../chapter-08/index.adoc,chapitre 8>>.

=== yargs-parser

_yargs-parser_ ([URL]#https://npmjs.com/yargs-parser#) est le module
d'interprétation des arguments utilisé par le module _yargs_.
C'est une alternative plus puissante et plus complexe que _minimist_.

=== args

_args_ ([URL]#https://npmjs.com/args#) est un module minimaliste
pour interpréter les arguments, les structurer et afficher une aide
claire à nos utilisateurs et utilisatrices.

Cerise sur le gâteau : le module suggère un choix de commande en cas
d'erreur de frappe.

=== caporal

_caporal_ ([URL]#https://npmjs.com/caporal#) est un framework complet
pour bâtir des applications en ligne de commande.
Il gère les classiques arguments et options ainsi que les sous-commandes,
les types de valeurs et l'autocomplétion.

=== promptly

_promptly_ ([URL]#https://npmjs.com/promptly#) est un utilitaire pour
poser des questions, valider et travaillers avec les réponses obtenues.
Il est minimaliste et a un faible nombre de dépendances.

=== supports-color

_supports-color_ ([URL]#https://npmjs.com/supports-color#) est un module
pour vérifier si le contexte d'exécution du programme en ligne de commande
supporte les couleurs.

Ça nous évite d'envoyer des codes ANSI qui du coup, seraient affichés
au lieu d'être interprétés comme des couleurs.


[[webapp]]
== Applications web

Ces modules complètent le panorama déjà très varié présenté
dans le <<../chapter-07/index.adoc,chapitre 7>>.

=== fastify

_fastify_ ([URL]#https://npmjs.com/fastify#) est un framework
inspiré de _express_.
Il se focalise sur la simplicité de l'expérience de développement et sur
de hautes performances.
Il sait valider les données sortantes à l'aide de schémas.

Pour aller au-delà des données, il se combine avec le module _point-of-view_
([URL]#https://npmjs.com/point-of-view#).
Vous avez ainsi accès à l'utilisation de <<templating,modules de templating>>.

=== passport

_passport_ ([URL]#https://npmjs.com/passport#) est une librairie modulaire
d'authentification pour _express_.
Elle permet de se brancher à différents mécanismes pour vérifier les utilisateurs :
utilisateur et mot de passe, compte GitHub, Twitter, OAuth, etc.

Les sessions d'utilisateurs se gèrent à côté — pour mémoriser
qui est connecté ou non, et avec quel identifiant sécurisé et unique.

Référez-vous à sa documentation pour des exemples détaillés d'utilisation.

=== restify

_restify_ ([URL]#https://npmjs.com/restify#) est un framework web
spécialisé dans la création d'API HTTP.

Il gère les versions de routes et expose un client permettant de consommer
des données sur d'autres API REST — proxy.

[source,javascript]
.restify.js
----
include::{sourceDir}/restify.js[]
----


=== faye

_faye_ ([URL]#https://npmjs.com/faye#) est un serveur WebSocket pour communiquer
en temps réel entre un client et un serveur.
Il sait débrayer vers Ajax ou JSON-P pour les navigateurs anciens qui
ne supportent pas WebSocket.

[source,javascript]
.faye.js
----
include::{sourceDir}/faye.js[]
----

Cet exemple de serveur minimaliste expose un point d'entrée qui peut
être accédé via le client _Faye_, dans un navigateur web ou via un autre
script Node.

Tout message émit par un client sera relayé auprès des autres clients
connectés.

=== swagger-client

_swagger-client_ ([URL]#https://npmjs.com/swagger-client#) sert à valider
des requêtes et des réponses HTTP en fonction de schémas qui répondent
à la spécification OpenAPI.

Cette spécification permet entre autre de gérer automatiquement les routes
de notre application pour se concentrer sur le code qui génère les données de sortie.

[[templating]]
== Modules front-end et templating

Les librairies de templating proposent d'associer
une structure de données à une logique de présentation.
La plupart fonctionnent aussi bien sous Node que dans les navigateurs web.
Ce qui est une excellente nouvelle pour partager des comportements d'affichage
entre les deux environnements.

Tous les modules que nous allons voir généreront cette sortie HTML :

[source,html]
----
<!DOCTYPE html>
<html>
<head>
  <title>Template demo</title>
</head>
<body>
  <ul>
    <li>CSS maintenables</li>
    <li>Node.js</li>
    <li>Open Sky</li>
  </ul>
</body>
</html>
----

=== nunjucks

_nunjucks_ ([URL]#https://npmjs.com/nunjucks#) est un portage de _Jinja_,
librairie bien connue par les adeptes de Python.
Sa syntaxe inclut des fonctionnalités comme les filtres, les blocs ou
l'héritage de gabarit.

[source,javascript]
.template.html
----
include::{sourceDir}/template.html[]
----

=== handlebars

_handlebars_ ([URL]#https://npmjs.com/handlebars#) et son prédécesseur _mustache_
sont les vétérans du templating Node.
Leur parti pris est de proposer le minimum de logique afin que celle-ci
reste au plus près des données.

_handlebars_ sait aussi précompiler les gabarits sous forme de fonctions ECMAScript.

[source,javascript]
.template.hbs
----
include::{sourceDir}/template.hbs[]
----

=== pug

_pug_ ([URL]#https://npmjs.com/pug#) opte pour pour un
parti minimaliste qui repose entièrement sur l'indentation.
Son mécanisme de blocs facilite la réutilisation d'éléments de présentation.

[source,javascript]
.template.pug
----
include::{sourceDir}/template.pug[]
----

=== ejs

_ejs_ ([URL]#https://npmjs.com/ejs#) part du principe qu'il n'y a pas besoin
d'un langage de templating autre qu'ECMAScript.
Donc c'est tout simplement ce qui vous sera proposé, impliquant de ce fait
une faible courbe d'apprentissage.

[source,javascript]
.template.ejs
----
include::{sourceDir}/template.ejs[]
----

=== react

_react_ ([URL]#https://npmjs.com/react#) est une librairie de présentation
dite "réactive" et orientée composants.
Elle génère un arbre visuel à partir de données passées en entrée.
Cet arbre est ensuite transformé en HTML, en interface iOS ou Android, entre autres.

[source,javascript]
.template.jsx
----
include::{sourceDir}/template.jsx[]
----

=== storybook

_storybook_ ([URL]#https://github.com/storybooks/storybook#) complète <<react,React>>
et d'autres frameworks de _templating_ en créant un catalogue de composants
auto-documentés.
Les composants sont affichés en même temps que le code nécessaire pour les utiliser
dans une autre application.

[[testing]]
== Tester notre code

L'outillage permettant de tester vos applications est également richement fourni.
Il y a bien sûr de quoi couvrir les tests unitaires, générer des couverture de code, exécuter les tests dans différents navigateurs, tester vos API HTTP ou encore créer des _stubs_ et des _mocks_.

[TIP]
.[RemarquePreTitre]#Remarque# require('assert')
====
Node dispose du module `assert` ([URL]#https://nodejs.org/api/assert.html#).
Vous pouvez donc vous lancer dans vos premiers tests Node avec
ce module de base.

Une exception sera levée à chaque fois qu'une assertion ne sera pas satisfaite.
====

=== tape

_tape_ ([URL]#https://npmjs.com/tape#) est une librairie
d'exécution de tests et d'assertion minimaliste.
Elle se base sur la sortie de `console.log` pour
s'assurer de l'état global d'exécution des tests.

[source,javascript]
.tape.js
----
include::{sourceDir}/tape.js[]
----

=== sinon

_sinon_ ([URL]#https://npmjs.com/sinon#) est votre compagnon idéal pour
gérer _spys_, _stubs_ et _mocks_.
En d'autres termes, vous prenez la main sur des portions de votre propre
API pour vérifier que leur _comportement_ répond comme prévu aux signaux
de leur environnement.

_sinon_ peut étendre _chai_ via le module _sinon-chai_ ou être utilisé
directement avec le _framework_ de tests _buster_.

[source,javascript]
.sinon.js
----
include::{sourceDir}/sinon.js[]
----

=== nyc

_nyc_ ([URL]#https://npmjs.com/nyc#) génère une couverture de code en
inspectant le code exécuté par vos tests unitaires.
Les portions de votre applications ignorées par vos tests sont signalées
et une exception peut être lancée si un seuil de couverture n'est pas atteint.

.Résultat de couverture visualisée dans le terminal
image::images/nyc-cli.png[width="85%"]

_nyc_ se greffe sur n'importe quel librairie d'exécution de tests et se base
sur la librairie _istanbul_ ([URL]#https://npmjs.com/istanbul#) pour calculer
la couverture de code.

.Résultat de couverture visualisée dans un navigateur web
image::images/nyc-web.png[width="85%"]

=== karma

_karma_ ([URL]#https://npmjs.com/karma#) pilote l'exécution de tests unitaires
depuis un ou plusieurs navigateurs web.
Ces navigateurs peuvent tout aussi bien être ceux présents sur votre machine,
que des navigateurs résidant dans une VM ou exécutés à distance via des services
comme SauceLabs ou BrowserStack.

.Exemple d'exécution continues de tests avec Karma
image::images/karma.png[width="85%"]

=== supertest

_supertest_ ([URL]#https://npmjs.com/supertest#) est une librairie de tests
pour API HTTP.
Autrement dit, au lieu de tester directement le code de votre application,
vous testez le comportement de votre API au travers des codes HTTP et des
structures de données exposées.


=== eslint

_eslint_ ([URL]#https://npmjs.com/eslint#) teste la qualité de votre code et
signale des pratiques de programmation à risque.

Disponible via une invocation en ligne de commande, libre à vous de paramétrer
le comportement du _linter_ selon vos propres règles ou selon des règles
pré-établies, partagées sur le registre _npm_.

C'est un excellent moyen d'éviter des bugs tout en uniformisant vos pratiques
de codage au sein de vos applications.


== Objets connectés

=== nitrogen

_nitrogen_ ([URL]#https://npmjs.com/nitrogen#) est une plateforme permettant
de gérer les interactions entre différents périphériques, sur un même réseau
local et à travers Internet.

La librairie se base sur un mécanisme déclaratif de fonctionnalités et de
terminaux ainsi que la publication de messages.

=== serialport

_serialport_ ([URL]#https://npmjs.com/serialport#) est une librairie pour
communiquer avec tout appareil bénéficiant d'un port série et relié à un
périphérique via un port USB.

=== firmata

_firmata_ ([URL]#https://npmjs.com/firmata#) est un _firmware_, un protocole
de communication ainsi qu'une librairie de communication pour microcontrôleur
Arduino.
Le module Node communique via ce protocole avec un Arduino préalablement
flashé avec Firmata.

=== johnny-five

_johnny-five_ ([URL]#https://npmjs.com/johnny-five#) est une librairie
haut-niveau pour Arduino, Raspberry Pi et autres microcontrôleurs.
Son API expose des fonctionnalités de manipulations avancées pour simplifier
les interactions avec des moteurs, des servo-contrôleurs, des capteurs etc.

=== node-red

_node-red_ ([URL]#https://npmjs.com/node-red#) est une interface visuelle de
programmation d'objets connectés.
Le module Node démarre un serveur web dont l'interface a pour but de relier
des sources de données, des interactions possibles ainsi que les objets devant
recevoir les instructions.


== Accessibilité

=== a11y

_a11y_ ([URL]#https://npmjs.com/a11y#).

=== chai-a11y

_chai-a11y_ ([URL]#https://npmjs.com/chai-a11y#).

=== a11y.css

_a11y.css_ ([URL]#https://npmjs.com/a11y.css#).

=== lighthouse

_lighthouse_ ([URL]#https://npmjs.com/lighthouse#).

=== storybook-addon-a11y

_storybook-addon-a11y_ ([URL]#https://npmjs.com/storybook-addon-a11y#).


== Travailler avec des images, des sons et des vidéos

=== sharp

_sharp_ ([URL]#https://npmjs.com/sharp#).


=== wawoff2

_wawoff2_ ([URL]#https://npmjs.com/wawoff2#).

[[av]]
=== av / mp3.js / aac.js

_av_ ([URL]#https://npmjs.com/av#).

=== jsmediatags

_jsmediatags_ ([URL]#https://npmjs.com/jsmediatags#).

=== video.js

_video.js_ ([URL]#https://npmjs.com/video.js#).

=== hlsify

_hlsify_ ([URL]#https://npmjs.com/hlsify#).

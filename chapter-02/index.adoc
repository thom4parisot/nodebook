:nodeCurrentVersion: v6
:nodeNextMajorVersion: v7
:es: ECMAScript 2015
:esNext: ECMAScript 2016
:sourceDir: ./examples/src
:revdate: {docdate}
:imagesdir: {indir}
ifdef::env[]
:imagesdir: .
endif::[]

== [ChapitreNumero]#2# Premiers pas avec Node.js

On aura beau discuter de Node et de son architecture, rien ne vaut quelques lignes de code pour mesurer ce à quoi nous avons affaire.

Ce chapitre contient tout ce qu'il faut savoir pour installer Node et développer son premier programme avec de bons _design patterns_.

====
.Sommaire
- Installer Node.js
- Comprendre le vocabulaire JavaScript à disposition
- Écrire son premier programme Node.js
- Utiliser des modules tiers
====

Il est fortement recommandé d'utiliser un interpréteur de commandes (terminal ou _shell_). Les systèmes d'exploitation modernes en proposent un, y compris les versions récentes de Windows.

Si vous n'utilisez pas encore de terminal, voici une liste de recommandations non exhaustive pour vous aider :

- *macOS* : iTerm2, Terminal.app ;
- *Linux* : GNOME Shell, Terminator ;
- *Windows* : PowerShell, Console.

.Terminal iTerm2 sous macOS.
image::images/terminal.png[align="center",scaledwidth="85%"]

Tous les exemples de ce chapitre sont relatifs à la *branche {nodeCurrentVersion} de Node*. +
Il se peut qu'une nouvelle branche stable soit sortie depuis l'édition de cet ouvrage, par exemple Node {nodeNextMajorVersion}.
Il suffit d'adapter les numéros de version adéquats dans les différents exemples fournis.

toc::[]

=== Préparer son environnement

Installer Node n'est pas très compliqué.
Il existe cependant plusieurs mécanismes d'installation.
Ces mécanismes vont du téléchargement d'un installateur à une compilation manuelle _via_ un terminal.

Voici mes recommandations pour savoir quelle solution d'installation choisir :

- *néophyte ou pressé(e)* : installateur du site nodejs.org, paquet fourni par le système d'exploitation ;
- *vous commencez à maîtriser* : Node Version Manager ;
- *à l'aise avec un terminal* : Node Version Manager ;
- *envie ou besoin de mettre en production* : Node Version Manager ;
- *besoin très spécifique et pointu* : compiler depuis les sources.

L'utilisation et les fonctionnalités de _nvm_ sont détaillées <<nvm,ci-après>>.

Une fois l'étape de l'installation terminée, la suite du livre ne fera plus de distinction entre les différents systèmes d'exploitation : c'est Node qui se chargera des abstractions !

==== Pour les différents systèmes d'exploitation

Certains systèmes d'exploitation fournissent leur propre mouture de Node.
Les procédures les plus courantes sont décrites ci-après.

Une liste complète mais non exhaustive est mise jour sur le wiki du dépôt GitHub de Node à cette adresse : [URL]#https://github.com/joyent/node/wiki/Installing-Node.js-via-package-manager#.

Si malgré tout votre système n'y était pas listé, le mieux reste encore d'*utiliser un binaire*, de *compiler depuis les sources* ou de demander à votre *moteur de recherche* favori !

[TIP]
.[RemarquePreTitre]#URL# Téléchargements officiels
====
Les installateurs, les binaires et les sources de Node sont disponibles sur le site officiel [URL]#nodejs.org#. +
Si vous vous sentez perdu(e), téléchargez l'installateur adapté, ouvrez un terminal et sautez quelques pages pour plonger dans l'utilisation de Node.

- https://nodejs.org/download/
====

===== Linux

Node est disponible dans les dépôts des systèmes suivants :

- *Gentoo* : `emerge nodejs`
- *Ubuntu >= 12.04*, *Debian >= jessie*, *Mint* : `sudo apt-get install nodejs`
- *Fedora >= 18* : `sudo yum install nodejs npm`
- *Arch Linux* : `pacman -S nodejs`
- *FreeBSD*, *OpenBSD* : `pkg install node`

Si votre système d'exploitation ne dispose pas de paquet pour Node, essayez dans l'ordre :

1. <<nvm,Node Version Manager>>;
2. le téléchargement du binaire Node sur son site officiel ;
3. la compilation manuelle de Node.

===== macOS

_macOS_ ne dispose pas de gestionnaire de paquet par défaut.
Quelques projets populaires permettent toutefois d'y remédier :

- *homebrew* : `brew install node`
- *MacPorts* : `port install nodejs`

Si vous n'utilisez aucun de ces gestionnaires de paquet, vous pouvez essayez :

1. _Node Version Manager_ (voir ci-après) ;
2. le téléchargement du binaire Node sur son site officiel ;
3. la compilation manuelle de Node.

===== Windows

Le moyen le plus simple d'installer Node sous Windows est de *télécharger l'installateur officiel* depuis la page de téléchargements de Node.

Toutefois si vous utilisez déjà un gestionnaire de paquet, voici quelques recommandations :

- *scoop.sh* : `scoop install nodejs`
- *Chocolatey* : `cinst nodejs.install`

===== Raspberry Pi

Node a effectué des changements dans son architecture dans sa version 0.8.
Ces changements ont permis d'éviter la compilation systématique sur des architectures processeur autre que l'Intel x86.

Des binaires et installateurs sont de ce fait disponibles pour Raspberry Pi, à base de processeur _ARM_, et très probablement pour d'autres plates-formes de ce genre.

Des binaires et instructions sont disponibles sur le site officiel de Node, pour ARMv6, ARMv7 et ARMv8 : [URL]#https://nodejs.org/en/download/#.

Un paquet `deb` est également proposé pour les utilisateurs du système d'exploitation _Raspbian_.

.Installation de la dernière version stable de Node sur un Raspberry Pi sous _Raspbian_.
----
curl --silent --location https://deb.nodesource.com/setup_6.x | bash -
apt-get install --yes nodejs build-essential
----

[[nvm]]
==== Node Version Manager

_Node Version Manager_ est un logiciel permettant de gérer plusieurs versions de Node en même temps, sur une même machine.
Il est communément abrégé en _nvm_.

_nvm_ est l'équivalent de _rvm_ dans le monde Ruby, de _phpenv_ dans le monde PHP ou encore de _virtualenv_ pour Python.

.Installation de _nvm_ et de Node {nodeCurrentVersion} sur un environnement Linux.
----
curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.0/install.sh | bash
nvm install v6
nvm alias default v6   <1>
----
<1> La version par défaut est désormais la dernière version stable de Node {nodeCurrentVersion}.

.Liste des versions installées de Node.
image::images/nvm-terminal.png[align="center",scaledwidth="85%"]

Les instructions d'installation à jour se trouvent sur [URL]#https://github.com/creationix/nvm#.

[TIP]
.[RemarquePreTitre]#Alternative# _n_
====
_n_ est une alternative à _nvm_ écrite en… JavaScript.
Elle a l'avantage d'être compatible avec tous les systèmes d'exploitation compatibles avec le Shell Unix _Bash_.

- https://www.npmjs.com/n
====

[TIP]
.[RemarquePreTitre]#Alternative# Et pour Windows ?
====
_nvm_ ne fonctionne pas sur les ordinateurs équipés de Windows.
Il existe trois autres alternatives : _nvm-windows_, __nvmw_ et _nodist_.

_nvmw_ nécessite d'avoir Git et Python tandis que _nodist_ se base uniquement sur Node.
Dans les deux cas, leur installation est très simple.

- https://github.com/coreybutler/nvm-windows
- https://github.com/hakobera/nvmw
- https://github.com/marcelklehr/nodist
====

==== Docker

_Docker_ est un outil d'isolation de processus système qui a le vent en poupe depuis 2014.
Sa qualité principale est d'isoler les dépendances logicielles du système qui exécute le-dit processus.
Une image Docker aura la même recette d'installation même si celle-ci est exécutée sous Linux, macOS ou encore Windows.

Lancer un interpréteur Node _sans polluer_ le système hôte revient à exécuter l'image suivante :

----
docker run -ti --rm node:4-slim
----

Nous nous repencherons sur Docker dans la <<../chapter-05/index.adoc,section _Déploiement_>> du chapitre 5.

==== Compiler depuis les sources

Certaines situations exigeront que vous compiliez Node.
Ce sera le cas si vous cherchez à tirer parti au maximum des instructions de votre CPU ou si aucun binaire n'est disponible pour votre plate-forme.

La compilation manuelle requiert la présence de _GCC_ 4.2+, de _Python_ 2.6+ et de _GNU Make_ 3.81+. +
La procédure de compilation ressemble fortement à ceci :

.Étapes de compilation de Node
----
curl -sS \
  https://nodejs.org/dist/v6.9.4/node-v6.9.4.tar.gz \
  | tar -zxf -
cd node-v6.9.4
./configure && make && make install
----

Les instructions pouvant varier fortement d'un système d'exploitation à l'autre, consultez les dépendances et instructions complètes à cette adresse [URL]#https://github.com/joyent/node/wiki/installation#.

=== Outils de développement

Programmer pour Node revient dans la majorité des cas à écrire du JavaScript.
Donc même si un éditeur de texte suffit, il est intéressant de connaître l'offre en outillage autour de Node.

Les logiciels présentés dans les pages suivantes couvrent un large spectre de besoins : écriture du code, coloration syntaxique, inspection dynamique, débogage, productivité et intégration à l'écosystème Node.

Ceci a pour but de vous aider à piocher au plus près de vos goûts, à défaut de continuer à utiliser votre logiciel habituel.

==== WebStorm

_WebStorm_ est un environnement de développement _(IDE)_ commercialisé par la société _JetBrains_.
Il est dédié au développement Web, ce qui inclut JavaScript, Node, mais aussi CSS et HTML.

_JetBrains_ est une entreprise connue dans d'autres écosystèmes pour ses _IDE_ _Pycharm_ (pour Python) et _IntelliJ IDEA_ (pour Java).

_WebStorm_ est compatible Windows, Linux et macOS.
Ses forces résident dans sa relative légèreté (en comparaison à son concurrent _Eclipse_), une auto-complétion intelligente prenant en compte les modules CommonJS et AMD, une intégration des outils populaires dans l'écosystème Node (npm, JSHint, Mocha, Karma, Grunt, Bower etc.) et un débogage avancé.

[TIP]
.[RemarquePreTitre]#Lien# Site officiel
====
Le site officiel de _WebStorm_ met à disposition une documentation lisible et complète ainsi que des vidéos illustrant les fonctionnalités clés du logiciel.

Le téléchargement du logiciel inclut une période d'essai de 30 jours.

- https://www.jetbrains.com/webstorm/
====

image::images/webstorm.png[align="center",scaledwidth="85%"]

[TIP]
.[RemarquePreTitre]#Astuce# Licence open source.
====
L'éditeur de _WebStorm_, _JetBrains_, propose une licence gratuite sous réserve d'une contribution active à un projet open source.
====

==== Atom

image::images/atom.png[align="center",scaledwidth="85%"]

Atom est un éditeur open-source développé avec Electron, un framework pour développer des applications de bureau multiplate-formes avec Node. Il intègre des packages qui facilitent le développement sous Node en proposant l'auto-complétion et l'exécution de processus Node directement depuis l'éditeur.

- https://atom.io/
- https://atom.io/packages/atom-ternjs

==== SublimeText 3

TBD.

- https://sublimecodeintel.github.io/SublimeCodeIntel/
- https://sublime.wbond.net/search/node.js
- https://www.sublimetext.com/3

image::images/sublime-text3.png[align="center",scaledwidth="85%"]

==== Brackets

TBD.

- https://brackets.io/
- https://brackets-registry.aboutweb.com/

image::images/brackets.png[align="center",scaledwidth="85%"]

==== vim

TBD.

- http://www.vim.org/
- https://github.com/moll/vim-node
- https://github.com/Valloric/YouCompleteMe
- https://github.com/joyent/node/wiki/Vim-Plugins


[WARNING]
====
Rajouter une image similaire à Webstorm.
====

==== Visual Studio

_Visual Studio_ est un environnement de développement _(IDE)_ édité par  _Microsoft_.
Historiquement dédié au développement sur Windows (Visual Basic, Visual C++), il gère aujourd'hui bien plus de langages (dont C#, HTML, CSS, JavaScript, ASP.Net).
Il est surtout extensible, ce qui permet, entre autre, de lui apporter le support de _Python_ ou encore Node.

_Visual Studio_ est uniquement compatible Windows, et existe en plusieurs éditions.
La plus intéressante est la Community Edition.
Elle est gratuite mais permet l'ajout d'extensions.

Afin de bénéficier de l'intégration complète de l'écosystème Node, il est nécessaire d'installer l'extensions _Node.js Tools for Visual Studio_ (aussi nommée _NTVS_).
Elle est gratuite, open source et disponible sur GitHub.

- https://www.visualstudio.com/
- https://github.com/Microsoft/nodejstools

image::images/visual-studio.png[align="center",scaledwidth="85%"]

==== Visual Studio Code

TBD.

- https://code.visualstudio.com/

image::images/visual-studio-code.png[align="center",scaledwidth="85%"]


=== Node, JavaScript et ECMAScript

Nous l'avons vu dans le premier chapitre, Node utilise JavaScript comme principal langage de développement.
Mais contrairement à Ruby, Python ou PHP dont le numéro de version annonce les fonctionnalités exploitables, qu'en est-il de Node et de JavaScript ?

Il faut se tourner du côté de _V8_ pour savoir ce que la machine virtuelle est capable de comprendre.
Et comme chaque version de Node est associée à une version spécifique de _V8_, il suffit d'aller regarder les notes de version de V8 pour l'apprendre.

De manière générale, _V8_ implémente les spécifications approuvées ou en passe d'être approuvées par le comité gérant l'évolution du langage JavaScript : le *TC39*.

Enfin si vous n'avez pas envie de retourner la moitié du web pour savoir si _V8_, donc Node, supporte telle ou telle fonctionnalité, partez du principe que *le JavaScript supporté par Chrome ou Opera correspond au JavaScript supporté par Node*.

[TIP]
.[RemarquePreTitre]#FAQ# JavaScript ou ECMAScript ?
====
On peut lire régulièrement les termes _JavaScript_ et _ECMAScript_ comme s'il s'agissait de la même chose, y compris dans cet ouvrage.
*JavaScript et ECMAScript sont la même chose*.

JavaScript a été inventé en 1995 par Brendan Eich alors qu'il était employé de la société _Netscape Communications_.
Microsoft lui emboîte le pas en incluant JavaScript dans son logiciel Internet Explorer, alors en version 3.
Pour des raisons de droits de marque, il y est dénommé _JScript_.

La spécification est ensuite validée par l'organisme _Ecma International_ en juin 1997 sous le nom d'_ECMAScript_, standard ECMA-262.

L'utilisation du terme _JavaScript_ est resté dans le vocabulaire courant. Mais c'est bien d'_ECMAScript_ dont on parle, vraiment.

Adobe Flash utilise un dérivé d'ECMAScript, ActionScript et bien des machines virtuelles sont capables d'interpréter partiellement ou intégralement ECMAScript : Rhino en Java, Konq, BESEN en Object Pascal ou encore Esprima en… ECMAScript.
====

La suite de l'ouvrage emploie principalement le terme _ECMAScript_.

==== Standard ECMA-262 Edition 5

ECMAScript a été standardisé dans sa version 5 en décembre 2009.
Il s'agit de la version d'ECMAScript supportée depuis les débuts de Node.
La révision 5.1 de juin 2011 est une correction mineure de la spécification.

Il s'agit d'une évolution majeure, dix ans après sa précédente édition, ECMAScript 3.

ECMAScript 5 introduit le mode strict limitant fortement les effets de bord indésirables, de nouvelles fonctionnalités pour `Object` et `Array`, le support natif de _JSON_ et `Function.prototype.bind`.

- https://kangax.github.io/compat-table/es5/
- [URL]#https://www.ecma-international.org/ecma-262/5.1/#

==== Standard ECMA-262 Edition 2015

La spécification *ECMAScript 2015* (_ES2015_) a été publiée en juin 2015 et succède à *ECMAScript 5*. +
La spécification _ES2015_ a successivement été appelée _ECMAScript Harmony_ puis _ECMAScript 6_.

La page Web suivante référence l'état de l'implémentation d'ECMAScript 2015 sur différentes plates-formes, dont Node :

- https://kangax.github.io/compat-table/es6/
- [URL]#https://www.ecma-international.org/ecma-262/6.0/#


==== Rappel des primitives ECMAScript

Un des conforts apporté par l'utilisation d'ECMAScript dans Node est qu'il n'y a pas à se soucier de la compatibilité navigateur : vous pouvez utiliser le meilleur de JavaScript !

Ce résumé des primitives et fonctionnalités principales d'_ECMAScript_ a pour but de vous apprendre ou de vous rappeler des fonctionnalités du langage disponibles dans Node {nodeCurrentVersion}.

===== String

Chaque élément d'une chaîne de caractère est encodé au format UTF-16 et peut donc contenir 16 bits de données.

L'opérateur `typeof` permet d'identifier une chaîne :

[source,javascript]
----
typeof 'Eyrolles'; <1>
----
<1> Retourne `'string'`.

On peut connaître la longueur d'une chaîne via son attribut `length`.

[source,javascript]
----
'I ♥ JavaScript'.length; <1>
----
<1> Retourne `14`.

On peut nettoyer les espaces englobant une chaîne avec la méthode `trim` :

[source,javascript]
----
'  w w w  '.trim(); <1>
----
<1> Retourne `'w w w'`.

On peut connaître la position d'un ou plusieurs caractères via la méthode `indexOf` :

[source,javascript]
----
'I ♥ JavaScript'.indexOf('JavaScript'); <1>
'I ♥ JavaScript'.indexOf('I'); <2>
'I ♥ JavaScript'.indexOf('?'); <3>
----
<1> Retourne `4` ;
<2> Retourne `0` ;
<3> Retourne `-1`, aucune occurrence n'ayant été trouvée.

On peut collecter les occurrences correspondantes à un masque de caractères via la méthode `match` :

[source,javascript]
----
'I ♥ JavaScript'.match('♥'); <1>
'I ♥ JavaScript'.match(/\wa/g); <2>
'I ♥ JavaScript'.match('!'); <3>
----
<1> Retourne `['♥']` ;
<2> Retourne `['Ja', 'va']` ;
<3> Retourne `null`.

On peut remplacer les occurrences correspondantes à un masque de caractères via la méthode `replace` :

[source,javascript]
----
'I ♥ JavaScript'.replace('♥', 'love'); // <1>
'I ♥ JavaScript'.replace(/[A-Z]/g, (char) => char.toLowerCase()); // <2>
----
<1> Retourne `'I love JavaScript'` ;
<2> Retourne `'i ♥ javascript'`.

===== Number

Tous les nombres en ECMAScript sont des flottants (double précision) respectant le standard link:https://fr.wikipedia.org/wiki/IEEE_754[_IEEE 754_].
Un nombre peut donc contenir 64 bits de données, comme en Python et PHP, entre autres.

L'opérateur `typeof` permet d'identifier un nombre :

[source,javascript]
----
typeof 42;    // <1>
typeof 13.37; // <1>
typeof NaN;   // <2>
----
<1> Retourne `'number'` ;
<2> Retourne également `'number'`, ce qui est souvent source de confusion.

On peut effectuer des opérations mathématiques grâce aux opérateurs `+` (addition), `-` (soustraction), `*` (multiplication), `/` (division) et `%` (modulo).

L'exception dont il faut se méfier est l'addition, car le signe `+` est également l'opérateur de concaténation de chaîne. +
Dès qu'une chaîne est détectée, l'opération d'addition est remplacée par une concaténation.

[source,javascript]
----
1 + 2;    // <1>
'1' + 2;  // <2>
1 + '2';  // <2>
undefined + 2; // <3>
----
<1> Retourne `3` ;
<2> Retourne `'12'` ;
<3> Retourne `NaN`.

Les fonctions `parseInt` et `parseFloat` permettent de respectivement de convertir en nombre entier et nombre flottant :

[source,javascript]
----
typeof 2.10 === 'number';
typeof '2.10' === 'string';

parseInt('2.10', 10); // <1>
parseFloat('2.10');   // <2>
----
<1> Retourne `2` ;
<2> Retourne `2.10`.

[TIP]
.[RemarquePreTitre]#FAQ# Le second argument de parseInt
====
Le second argument de la fonction `parseInt` indique dans quelle base la valeur est représentée dans la chaîne. La base décimale (10) est la plus souvent utilisée, mais il est également possible de convertir une chaîne représentant un nombre binaire (base 2), ou héxadécimal (base 16).
====

La méthode `isNaN` permet d'être sûr de ne pas manipuler un nombre indésirable :

[source,javascript]
----
Number.isNaN(undefined + 1);  // <1>
Number.isNaN(2.10);           // <2>
Number.isNaN(undefined);      // <2>
----
<1> Retourne `true` ;
<2> Retourne `false`.

Il également possible de choisir le nombre de décimales après la virgule avec la méthode `toFixed`. +
Attention toutefois, la valeur retournée est de type `String` :

[source,javascript]
----
10.0101.toFixed(2);   // <1>
10.0101.toFixed(0);   // <2>
parseInt(10.0101, 10);// <3>
----
<1> Retourne `'10.01'` ;
<2> Retourne `'10'` ;
<3> Retourne `10`.

===== Date

L'opérateur `typeof` ne permet pas d'identifier une date. Il convient d'utiliser `instanceof` :

[source,javascript]
----
typeof (new Date('2014-03-24'));  // <1>
(new Date('2014-03-24 13:37')) instanceof Date; // <2>
typeof Date.parse('2014-03-24 13:37');          // <3>
----
<1> Retourne `'object'` ;
<2> Retourne `true` ;
<3> Retourne `'number'`, car il s'agit d'une date exprimée en millisecondes depuis le 1er janvier 1970 (temps _EPOCH_).

Il également possible d'obtenir la date actuelle exprimée en millisecondes avec `Date.now` :

[source,javascript]
----
Date.parse(new Date()); // <1>
Date.now();             // <2>
----
<1> Retourne `1397381941000` ;
<2> Retourne `1397381941031`, équivalent à la syntaxe précédente donc, la précision à la milliseconde près en plus.

===== Array

L'opérateur `typeof` ne permet pas d'identifier un tableau. Il faut pour cela privilégier la méthode `isArray` :

[source,javascript]
----
typeof [];        // <1>
Array.isArray([]);// <2>
----
<1> Retourne `'object'` ;
<2> Retourne `true`.

Il est possible de connaître la longueur d'un tableau en utilisant la propriété `length` :

[source,javascript]
----
[1, 2, 3].length; // <1>
----
<1> Retourne `3`.

La méthode `join` permet de concaténer tous les éléments d'un tableau avec le séparateur de votre choix :

[source,javascript]
----
[1, 2, 3].join(', ') + '… soleil';  // <1>
----
<1> Retourne `'1, 2, 3… soleil'`.

À l'inverse, la méthode `from` prend en charge la création de tableau à partir d'_itérables_ ou de structures similaires à des tableaux, comme `arguments` ou `NodeList` (dans un navigateur).

[source,javascript]
.primivite-array-from.js (avec l'option `--harmony`)
----
include::{sourceDir}/primitives-array-from.js[]
----
<1> Retourne `[ 'c', 'a', 'm', 'e', 'm', 'b', 'e', 'r', 't' ] ;
<2> Retourne `[ 1, 'b', 3, 'd' ]` ;
<3> Retourne `[ 1, 'b', 3, 'd' ]`.

En complément, la méthode `concat` permet de concaténer d'autres éléments :

[source,javascript]
----
include::{sourceDir}/primitives-array-concat.js[]
----
<1> Retourne `[ 1, 2, 3 ]` ;
<2> Retourne `[ 1, 2, 3, 4 ]` ;
<3> Retourne `[ 1, 2, 3, 4, 4, 5 ]` — cf. <<primitive-set,Set>>.

La fonction de tri via la méthode `sort` se base sur des comparaisons positives, négatives ou neutres pour retourner un nouveau tableau, réindexé :

[source,javascript]
----
[1, 3, 2].sort((a, b) => a - b);  // <1>
[1, 3, 2].sort((a, b) => b - a);  // <2>

['A', 'b', 'c', 'a'].sort((a, b) => a.localeCompare(b))); // <3>
----
<1> Retourne `[1, 2, 3]` ;
<2> Retourne `[3, 2, 1]` ;
<3> Retourne `['a', 'A', 'b', 'c']`.

Les méthodes suivantes sont des nouveautés d'ECMAScript 5.
Elles facilitent énormément les itérations sur les tableaux tout en ajoutant une orientation fonctionnelle, utile pour la lisibilité du code.

La méthode `map` permet de retourner un nouveau tableau avec des valeurs modifiées :

[source,javascript]
----
['a', ' B', 'c '].map(value => value.trim().toUpperCase()); // <1>
----
<1> Retourne `['A', 'B', 'C']`.

La méthode `filter` quant à elle retourne un nouveau tableau ne contenant que les éléments retournant une _valeur positive_ :

[source,javascript]
----
const values = [1, 'a', 120, undefined, 4];
values.filter(value => value < 10); // <1>
----
<1> Retourne `[1, 4]`.

De manière similaire, les méthodes `some` et `every` retournent un booléen si _au moins une itération_ et _toutes les itérations_ ont renvoyé une _valeur positive_ :

[source,javascript]
----
const values = [1, 'a', 120, undefined, 4];
const isUndefined = (value) => value === undefined);

values.some(isUndefined); <1>
values.every(isUndefined); <2>
[undefined, undefined].every(isUndefined); <3>
----
<1> Renvoie `true` puisqu'au moins une valeur équivaut à `undefined` ;
<2> Renvoie `false` puisque toutes les valeurs n'équivalent pas à `undefined` ;
<3> Renvoie `true` puisque toutes les valeurs sont égales à `undefined`.

ECMAScript 2015 introduit les méthodes `find` et `findIndex`, respectivement pour retourner une valeur et son index selon une fonction prédicat :

[source,javascript]
----
include::{sourceDir}/primitives-array-find.js[]
----
<1> Valeur que l'on recherche ;
<2> Affiche `stram` (valeur recherchée) ;
<3> Affiche `1` (index de la valeur recherchée).

La méthode `reduce` a un comportement similaire à `sort` mais fonctionne de manière accumulative :

[source,javascript]
----
const pairs = [[1, 2], [3, 4], [5, 6]];

pairs.reduce((acc, pair) => acc + pair[0] + pair[1], 0); // <1>

pairs.reduce((acc, pair) =>
  acc[0] += pair[0];
  acc[1] += pair[1];
  return acc;
}, [0, 0]); // <2>
----
<1> Retourne `21` ;
<2> Retourne `[9, 12]`.

[TIP]
.[RemarquePreTitre]#FAQ# Tableau non contigu.
====
Il se peut que des valeurs soient manquantes dans un tableau.
On dit alors que les valeurs ne sont pas contiguës.

Cela affecte les fonctions itératives et peut se révéler problématique si vous cherchez à conserver cette absence de valeurs :

----
const a = [1,, 3, undefined, null];
coonst print = (value) => console.log(value);

a.length;         // <1>
a.forEach(print); // <2>
----
<1> Retourne `5` ;
<2> Affiche 4 valeurs : `1`, `3`, `undefined` puis `null`.
====

[[primitive-set]]
===== Set

TBD.

===== Function

Les fonctions permettent d'isoler des portions de code et de les rendre réutilisables via l'utilisation de paramètres.

Vous pouvez les déclarer via une expression ou une déclaration assignée à une variable.
La déclaration d'une fonction est soumise à la portée du contexte dans lequel le bloc de code est placé.
Une fonction peut être _nommée_ (`function nomDeLaFonction(){ ... }`), _anonyme_ (`function (){ ... }`) ou _lexicale_ (`() => ({ ... })`).

Les fonctions anonymes sont fréquemment employées en tant que _callbacks_ ou dans des contextes itératifs (tels `Array.map` etc.)

Il est important de noter que la déclaration d'une fonction et son exécution sont deux choses différentes.

[source,javascript]
.primitives-function.js
----
include::{sourceDir}/primitives-function.js[]
----
<1> Utilisation d'une fonction nommée comme _callback_ de la méthode `Array.map` ;
<2> Utilisation d'une _arrow function_ en tant que fonction anonyme de _callback_ ;
<3> Illustration d'une _Immediatly Invocked Function Expression_, aka _IIFE_ aka _fonction immédiatement exécutée_ ;
<4> Retourne `'function'` ;
<5> Retourne `false` — la valeur étant nulle ;
<6> Retourne `[ 3, 1 ]` — un tableau filtré des valeurs nulles ou égales à `undefined` ;
<7> Lève une exception car la constante `values` n'est pas définie dans ce _scope_.

Le code contenu dans le bloc déclaratif d'une fonction crée une _portée_ (ou _scope_) qui est invisible au contexte parent de l'exécution de cette fonction.
Il s'agit d'une excellente manière d'isoler des variables, notamment pour éviter des effets de bord indésirables liés à l'état d'exécution de vos scripts.

L'exemple précédent illustre un tel cas de portée en contenant la constante `values` dans l'_IIFE_ : le contexte parent n'a aucune connaissance de son existence — et c'est tant mieux.

Une syntaxe abrégée est disponible via les _arrow functions_ :

.Tableau d'équivalence de syntaxe
|=========
| `x => x*2` | `function(x){ return x*2 }`
| `x => { x*2 }` | `function(x){ x*2 }`
| `(x, y) => x+y` | `function (x, y){ return x+y }`
| `x => { const y = 2; return x*y }` | `function(x){ const y = 2; return x*y }`
|=========

Il est possible de composer des fonctions à partir d'autres fonctions en utilisant la méthode `bind`.
Ce _pattern_ est extrêmement puissante car il permet de modifier le contexte d'exécution de ladite fonction.

[source,javascript]
.primitives-function-bind.js
----
include::{sourceDir}/primitives-function-bind.js[]
----
<1> Retourne `'100 EUR'` ;
<2> Retourne `'100 GBP'`.

`bind` est également capable de créer une nouvelle fonction à laquelle vous auriez appliqué partiellement des arguments :

[source,javascript]
.primitives-function-partials.js
----
include::{sourceDir}/primitives-function-partials.js[]
----
<1> Affiche `'Hello World'` ;
<2> Affiche `'Hello Paris'`.

Ce procédé est particulièrement utile pour rendre des fonctions génériques et composer des dérivées, notamment dans le cas de pagination.

Les méthodes `call` et `apply` reposent sur le même principe mais à la différence de `bind`, elles exécutent immédiatement la fonction.
Le seul élément différenciant correspond à la syntaxe d'application des arguments :

[source,javascript]
.primitives-function-call-apply.js
----
include::{sourceDir}/primitives-function-call-apply.js[]
----
<1> Retourne `'<title>'` dans les deux cas.


===== Object

Dans ECMAScript, tout est objet. C'est le _prototype_ qui détermine le comportement dudit objet.
Les objets peuvent être créés de manière littérale, avec la fonction `Object.create` ou via un constructeur.

[source,javascript]
.primitives-object.js
----
include::{sourceDir}/primitives-object.js[]
----
<1> Retourne `'lateral'` ;
<2> Retourne également `'lateral'` ;
<3> Retourne `true`, les deux objets étant la même instance ;
<4> Retourne `false`, les deux objets étant deux instances différentes.

L'opérateur `typeof` permet d'identifier la primitive d'une variable — au sens d'ECMAScript, pas au sens logique de votre application, c'est à dire le prototype d'un objet.

L'opérateur `instanceof` ou la méthode `getPrototypeOf` permettent justement de comparer les appartenances logiques.

[source,javascript]
.primitives-object-typeof-instanceof.js
----
include::{sourceDir}/primitives-object-typeof-instanceof.js[]
----
<1> Affiche `function` ;
<2> Affiche `object` ;
<3> Affiche `true` ;
<4> Affiche `[object Object]` ;
<5> Affiche `PseudoBookClass`.

`Object.keys` extrait les propriétés énumérables d'un objet, à la différence de `Object.getOwnPropertyNames()` :

[source,javascript]
.primitives-object-keys.js
----
include::{sourceDir}/primitives-object-keys.js[]
----
<1> Affiche `[ 'name', 'services' ]` ;
<2> Affiche successivement `name`, `services` et `internal_code`.

`Object.assign` étend des structures existantes et la définition de valeurs par défaut.
Les clés et valeurs sont copiées de gauche à droite avant d'être assignées dans le premier paramètre :

[source,javascript]
.primitives-object-assign.js
----
include::{sourceDir}/primitives-object-assign.js[]
----
<1> Les clés et valeurs de `DEFAULT` et celles de `userOptions` sont copiées dans un objet vide puis retournées dans `mergedOptions` ;
<2> Affiche `{ concurrency: 10, timeout: 'https', tags: [] }` ;
<3> Affiche `[ 'img', 'h1' ]` ;
<4> Affiche `[ 'url', 'env', 'tags' ]` — l'objet `testOptions` est donc modifié.

===== Map

TBD.

===== Class

ECMAScript 2015 ajoute au langage des sucres syntaxiques facilitant la création et maintenance d'objets métier.
Nous bénéficions d'une véritable notion de constructeur, de méthodes statiques et même d'extension de prototype — on pourrait parler d'héritage mais nous n'avons pas envie d'aller dans cette direction, pas vrai ?

Tout ce que nous attachions auparavant à une _fonction_, nous nous référons désormais à une _classe_ à proprement parler. +
En voici un exemple de définition :


[source,javascript]
.class-view.js
----
include::{sourceDir}/class-view.js[]
----

La définition de la classe `View` comporte trois fonctions :

- `constructor` : le constructeur invoqué à chaque nouvelle instantiation via l'opérateur `new` ;
- `render` : une méthode partagée par toutes les instances de `View` — équivalent à `View.prototype.render = () => ({ ... })` ;
- `removeDuplicates` : une méthode statique, utilisable indépendamment des instances de `View` — équivalent à `View.removeDuplicates = () => ({ ... })`.

L'exemple suivant illustre le comportement de la classe `View` :

[source,javascript]
.primitives-class-constructor.js
----
include::{sourceDir}/primitives-class-constructor.js[]
----
<1> Affiche `object` ;
<2> Affiche `true` ;
<3> Affiche `{ blacklist: [ 'object', 'iframe' ] }` — l'objet de configuration initial ;
<4> Affiche `Node.js` ;
<5> Affiche une exception personnalisée.

ECMAScript permet de définir des accesseurs, sur des propriétés existantes ou de manière ad-hoc. +
Dans l'exemple suivant, nous créons la propriété `EAN13` pour coordonner la logique avec les propriétés `GS1` et `ISBN` … mais sans pour autant stocker la valeur `EAN13` à proprement parler :

[source,javascript]
.primitives-class-accessors.js
----
include::{sourceDir}/primitives-class-accessors.js[]
----
<1> Retourne `'978'`;
<2> Retourne `'2212136401'` ;
<3> Retourne `'978-2212136401'`.

Étendre les classes ouvre la porte à des _patterns_ d'interface plus explicites et moins prompts à abimer la chaine prototypale.

L'exemple suivant illustre deux classes héritant de notre classe `View`.

`HTMLView` surcharge le constructeur tandis que `TextView` se contente du comportement par défaut défini par le constructeur de `View`.

L'appel à la fonction `super` revient à _appeler le constructeur de la classe que l'on étend_.
Ne pas l'appeler revient à ne pas exécuter le constructeur de la classe parent.

[source,javascript]
.primitives-class-extends.js
----
include::{sourceDir}/primitives-class-extends.js[]
----
<1> Retourne une chaîne de HTML après avoir interpolé les variables avec leur valeur respective ;
<2> Retourne la chaîne de texte `# Node.js\n#{empty}#\#{empty}#\#{empty}#\#{empty}#{empty}#\n\nHello World!`.

S'il est désormais plus sûr d'utiliser l'extension de chaîne prototypale, *il ne faut pas abandonner la composition* pour autant.

Il est en effet bien plus simple de réutiliser (et de tester) des fonctions agnostiques de contexte — de `this` — que de maintenir de grosses classes héritant sur plusieurs niveaux.

===== Promise

La nature asynchrone et non-bloquante des opérations coûteuses en cycles CPU est quelque chose d'appréciable dans Node.
L'avantage d'un _callback_ est sa possible asynchronicité.
En revanche son inconvénient est la difficulté à être tenu informé de ce qui s'y passe.

Que faire si l'on souhaite exécuter trois fonctions différentes lors de la lecture d'un fichier ?
Et comment gérer les erreurs si l'une de ces fonctions échoue ?
Certainement pas en imbriquant les _callbacks_ les uns dans les autres comme ceci :

[source,javascript]
.callback-hell.js
----
include::{sourceDir}/callback-hell.js[]
----
<1> Affiche le nombre de dépendances combinées pour les trois premiers chapitres de cet ouvrage.

À l'œil nu, on se rend compte de la répétition de la gestion des erreurs — difficilement capturable soit dit en passant — et du caractère monolithique de la structure.
Il est impossible d'exécuter autre chose qu'un `console.log` dans le dernier _callback_ sans en modifier son contenu.

Un motif a émergé en réponse à cette complexité grandissante, à mi-chemin entre les _callbacks_ et les événements : les *promesses*.
*Il s'agit d'une primitive à maitriser* et disponible nativement à la fois dans Node et les navigateurs modernes.

[TIP]
.[RemarquePreTitre]#Définition# Promesse
====
Une promesse est *objet retourné immédiatement* et résolu _positivement_ ou _négativement_ *une seule et _unique_ fois dans le futur*.

C'est un peu comme envoyer un courrier en recommandé :

- le bureau de poste vous remet une preuve de dépôt (la promesse) ;
- vous recevez un accusé de réception lorsque le destinataire atteste sa réception (le _callback_ de succès) ;
- vous recevez un accusé de non-délivrance si le destinataire n'a pas signé, ou récupéré son courrier dans un délai imparti (le _callback_ équivalent d'un _timeout_).
====

`Promise` implémente plusieurs méthodes dont les plus utiles sont certainement `then` et `catch`.
Le pseudocode suivant illustre la migration d'un mécanisme de _callback_ vers les promesses :

[source,javascript]
.primitives-promise-pseudocode.js
----
include::{sourceDir}/primitives-promise-pseudocode.js[]
----

Le résultat est une *lecture séquentielle du code*, plus facile à appréhender mais également la *souscription de multiples fonctions* en cas de succès ou d'erreur grâce aux méthodes `then` et `catch` :

- `then(onSuccess[, onError])` : fonction acceptant un _callback_ de succès obligatoire et un _callback_ d'erreur facultatif ;
- `catch(onError)` : fonction acceptant un _callback_ d'erreur obligatoire, commun à toute la chaine de promesses.

[TIP]
.[RemarquePreTitre]#Bon à savoir# `then` et `return`
====
Le _callback_ de succès contient le résultat de la promesse précédente.

Il y a trois cas de figure si vous chainez plusieurs `then` :

- le callback de succès ne retourne rien : le prochain `then` transmet à nouveau le résultat de la promesse ;
- le callback de succès retourne une valeur arbitraire : le prochain `then` contiendra cette dite valeur ;
- le callback de succès retourne une nouvelle promesse : le prochain `then` retournera la valeur de cette dite promesse, une fois résolue.
====

L'implémentation d'une promesse consiste en la création d'un objet `Promise` acceptant comme argument une fonction.
Cette fonction contient la logique d'exécution, résolue positivement en appelant `resolve` ou à l'inverse, en appelant `reject`.

`resolve` et `reject` transmettent les valeurs passées en argument à vos _callbacks_ souscrivant respectivement à `then` et `catch`.

L'implémentation de `readFilePromise` évoquée dans le pseudocode précédent pourrait se faire de la manière suivante :

[source,javascript]
.readfile-promise.js
----
include::{sourceDir}/readfile-promise.js[]
----
<1> Les fonctions de résolution `resolve` et `reject` sont mises à disposition par l'API des `Promise` ;
<2> La promesse englobe l'exécution asynchrone — toute exception levée revient à implicitement appeler `reject` ;
<3> Résout négativement la promesse en passant le contenu de la dite erreur ;
<4> Résout positivement la promesse — si le _parsing_ échoue, la promesse sera rejetée.

Reprenons maintenant le premier exemple de cette section en utilisant ce que nous venons d'apprendre à propos des `Promise` :

[source,javascript]
.primitives-promise.js
----
include::{sourceDir}/primitives-promise.js[]
----

S'il y un léger mieux — nous n'avons plus d'imbrication de _callbacks_ — nous avons en revanche un problème : comment itérer sur le résultat de plusieurs appels asynchrones sur un nombre indéterminé d'éléments ?

Tout d'abord, nous n'avons pas besoin de récupérer les fichiers séquentiellement : laissons le système gérer au mieux les cycles CPU et opérer avec la charge système pour obtenir les ressources demandées.
En d'autres termes : *parallélisons les appels asynchrones*.

Et combinons le tout avec `Promise.all`, une méthode créant une _promesse de promesses_ : elle résoudra positivement ou négativement lorsque toutes les promesses passées en argument seront résolues.

Notre exemple initial s'en trouve simplifié au maximum :

[source,javascript]
.primitives-promise-all.js
----
include::{sourceDir}/primitives-promise-all.js[]
----
<1> L'unique argument du _callback_ de succès est un tableau des ressources retournées par chaque promesse, en suivant leur ordre respectif d'exécution ;
<2> Résultat identique à celui affiché par `callback-hell.js` — la fierté d'un code maintenable en plus !

Usez et abusez des promesses : elles sont un des meilleurs moyens d'aplatir votre code, d'organiser son déroulement tout en  facilitant sa modularité et sa testabilité.

[TIP]
.Pour aller plus loin
====
Des librairies de promesses ajoutent des sucres syntaxiques pour faciliter encore davantage la manipulation des promesses :

- [URL]#https://npmjs.com/bluebird
- [URL]#https://npmjs.com/when
- [URL]#https://npmjs.com/es6-promise (un polyfill pour Node et les navigateurs Web)

Enfin, il est toujours possible de jeter un œil aux _générateurs_ ainsi qu'aux fonctions _async_ (prévues pour ES2016).
====

===== RegExp

Les expressions régulières en JavaScript permettent de pratiquer des recherches de motifs simples et complexes au sein de chaînes de caractères.
Elles sont inspirées de l'implémentation dans Perl 5.

L'opérateur `instanceof` permet d'identifier une instance d'expression régulière :

[source,javascript]
----
/Eyroll?es/g instanceof RegExp; <1>
(new RegExp('Eyroll?es', 'g')) instanceof RegExp; <1>
----
<1> Retourne `true`.

La méthode `exec` permet de capturer les occurrences d'une expression régulières au sein d'une chaîne de caractères :

[source,javascript]
----
/(.+)(Script)/.exec('ECMAScript'); <1>
----
<1> Retourne `['ECMAScript', 'ECMA', 'Script']`.

Plusieurs drapeaux peuvent être utilisés :

- `g` pour chercher dans toute la chaîne, et ne pas s'arrêter à la première occurrence trouvée ;
- `i` pour ne pas tenir compte de la casse ;
- `m` pour que les caractères `^` et `$` correspondent respectivement au début et à la fin d'une ligne au lieu du début et de la fin de la chaîne ;

[source,javascript]
----
let re;
const text = ['JavaScript', 'ECMAScript'].join("\n");

re = /^([a-z]+)(Script)/;
re.exec(text); <1>

re = /^([a-z]+)(Script)/i;
re.exec(text); <2>

re = /([a-z]+)(Script)$/i;
re.exec(text); <3>

re = /([a-z]+)(Script)$/im;
re.exec(text); <4>

re = /^([a-z]+)(Script)$/gim;
re.exec(text); <5>
re.exec(text); <6>
re.exec(text); <7>
----
<1> Retourne `null` ;
<2> Retourne `['JavaScript', 'Java', 'Script']` ;
<3> Retourne `['ECMAScript', 'ECMA', 'Script']` ;
<4> Retourne `['JavaScript', 'Java', 'Script']`, puisque `$` correspond à la fin de ligne et non la fin de chaîne ;
<5> Retourne `['JavaScript', 'Java', 'Script']` ;
<6> Retourne `['ECMAScript', 'ECMA', 'Script']` puisque le curseur a effectué la recherche après la position de la précédente occurrence ;
<7> Retourne `null` puisque le curseur a rencontré la fin de la chaîne ;

[CAUTION]
.[RemarquePreTitre]#Remarque# Gare à la réutilisation de l'objet _RegExp_ !
====
Vous l'aurez remarqué avec le drapeau `g`, le comportement de la méthode `exec` peut renvoyer un résultat différent à chaque appel.

Il faut juste veiller à ce que ce soit un résultat escompté pour éviter tout effet de bord dans vos applications.
====

À la manière de `exec`, la méthode `test` se contente de renvoyer un booléen si un motif a été trouvé ou non :

[source,javascript]
----
/(.+)(Script)/.test('ECMAScript'); <1>
----
<1> Retourne `true`.

===== JSON

L'introduction du support natif du parsing JSON dans ECMAScript 5 a apporté un grand confort dans la consommation de données issues d'API.
La sécurité de cette consommation a été améliorée de par sa prise en charge par les développeurs de VM ECMAScript.

La fonction `JSON.parse` tente de convertir une chaîne de texte supposée au format JSON en un objet natif :

[source,javascript]
----
const jsonContent = '{ "ECMAScript": 5.1 }';

typeof jsonContent; <1>

const content = JSON.parse(jsonContent);
content.ECMAScript; <2>

try {
  JSON.parse('{ "ECMAScript": 5.1');
}
catch (err) {
  console.log(err.message); <3>
}
----
<1> Retourne `'string'` ;
<2> Retourne `5.1` ;
<3> Affiche `Unexpected end of input` car `JSON.parse` a lancé une exception `SyntaxError`.

À l'inverse, la fonction `JSON.stringify` convertit un objet natif en chaîne de caractère au format JSON :

[source,javascript]
----
JSON.stringify({ ECMAScript: 5.1 }); <1>
JSON.stringify({ ECMAScript: 5.1 }, null, 2); <2>
----
<1> Retourne `'{"ECMAScript":5.1}'` ;
<2> Retourne `'{\n  "ECMAScript": 5.1\n}'`, le troisième argument formate proprement avec la taille d'indentation spécifiée, exprimée en nombre d'espaces par niveau de profondeur.

[TIP]
.[RemarquePreTitre]#URL# Spécification ECMAScript
====
L'ensemble de la spécification ECMAScript est disponible aux formats PDF et HTML.
Il s'agit d'une mine d'or pour comprendre les mécanismes internes du langage, les types et primitives à disposition.

- https://www.ecma-international.org/ecma-262/5.1/
====

==== Variables globales dans Node.js

En plus des primitives ECMAScript, Node introduit des variables globales supplémentaires.
Elles vous seront utiles pour faciliter le débogage ou tout simplement pour la développement et le partage de vos modules.

===== console

Toute personne ayant développé du JavaScript pour le navigateur a très certainement utilisé `console.log` pour tracer l'état d'une expression lors de l'exécution de son code.

Trois fonctions sont à garder dans un coin de la tête :

- `console.log` ;
- `console.error` ;
- `console.trace`.

`console.log` affiche une représentation textuelle d'une expression et la formate avec des motifs équivalents à la fonction C `printf()`. +
Ce contenu est envoyé vers la sortie standard, `process.stdout` :

[source,javascript]
----
console.log('ECMA%s', 'script'); <1>
----
<1> Affiche `'ECMAScript'`.

`console.error` a exactement le même comportement mais redirige vers le flux d'erreur, `process.stderr`.

`console.trace` envoie l'état de la _stack trace_ vers le flux d'erreur :

.stack-trace.js
----
$ node stack-trace.js
At level 1
At level 2
At level 3
At level 4
Trace: Level 5
    at traceAtLevel (…/examples/02-first-steps/stack-trace.js:11:13)
    at traceAtLevel (…/examples/02-first-steps/stack-trace.js:8:5)
    at traceAtLevel (…/examples/02-first-steps/stack-trace.js:8:5)
    at traceAtLevel (…/examples/02-first-steps/stack-trace.js:8:5)
    at traceAtLevel (…/examples/02-first-steps/stack-trace.js:8:5)
    at Object.<anonymous> (…/examples/02-first-steps/stack-trace.js:15:1)
    at Module._compile (module.js:456:26)
    at Object.Module._extensions..js (module.js:474:10)
    at Module.load (module.js:356:32)
    at Function.Module._load (module.js:312:12)
----

Pour en savoir plus sur les méthodes et fonctions disponibles, reportez-vous à la documentation en ligne du module `console` sur [URL]#https://nodejs.org/api/console.html#.

===== process

L'objet `process` correspond à l'instance de l'environnement Node en cours d'exécution.

Il permet de s'interfacer avec le système, en écoutant les évènements qu'il envoie au processus ou en écoutant les évènements que Node s'apprête à envoyer au système d'exploitation.

Le tableau `process.argv` contient le chemin du script exécuté ainsi que les différents arguments transmis à Node :

[source,javascript]
.process.js
----
include::{sourceDir}/process.js[]
----

Exécutons ce même script avec différents arguments :

----
node process.js <1>
node process.js argument1 "argument 2" --option1 <2>
----
<1> Retourne `[ 'node', '…/examples/chapitre-02/process.js' ]` ;
<2> Retourne `[ 'node', '…/examples/chapitre-02/process.js', 'argument1', 'argument 2', '--option1' ]`.

Il n'en faut pas davantage pour bâtir votre premier programme en ligne de commande.
Pour des besoins plus avancés, il existe un certain nombre de modules _npm_ pour exploiter les options et arguments.

[TIP]
.[RemarquePreTitre]#Remarque# Arguments internes
====
Comment faire pour passer des arguments à Node sans qu'ils soient interprétés par le script et vice-versa ?
Il suffit de les placer au bon endroit lorsque vous construisez l'appel à l'exécutable Node :

----
node <arguments node> chemin/vers/script.js <arguments script>
----

Ces arguments se retrouveront respectivement dans `process.execArgv` et `process.argv`.
====

Le deuxième ensemble d'objets à connaître est le trio `process.stdin`, `process.stdout` et `process.stderr`.
Ce sont trois flux (_Streams_) qui permettent d'accéder respectivement à l'entrée standard, à la sortie standard et à l'erreur standard.

Si ces noms ne vous parlent peut-être pas, c'est parce qu'ils sont directement inspirés d'UNIX.
Ils sont directement accessibles via l'interface JavaScript de Node.

Le script suivant convertit toute chaine de caractère envoyée vers l'entrée standard en lettres majuscules :

[source,javascript]
.uppercase.js
----
include::{sourceDir}/uppercase.js[]
----

Exécutons ce script sur un système Unix :

----
echo "Entrée standard" | node uppercase.js <1>
----
<1> Affiche `ENTRÉE STANDARD`.

Le concept de _Streams_ sera développé petit à petit au fil de ce chapitre et dans le reste du livre.
C'est un concept puissant mais il y a des fonctionnalités plus simples à appréhender pour débuter.

Nous venons de voir que `process` est un objet contenant plusieurs attributes précieux.
L'héritage prototypal est utilisé pour le rendre capable d'émettre des évènements via la méthode `process.on()`.
Cette méthode est utilisée pour écouter les évènements système et permettre à nos programmes de réagir convenablement.

L'exemple suivant illustre la réaction face à un signal d'interruption (abrégé en `SIGINT`, pour _Signal Interrupt_).
Ce signal est notamment émis en pressant les touches [Menu]#CTRL# et [Menu]#C#.

[source,javascript]
.interrupt.js
----
include::{sourceDir}/interrupt.js[]
----

Et maintenant son exécution dans un terminal Unix :

----
node interrupt.js 3 <1>
^C <2>
^C <3>
^C <4>
----
<1> Affiche `Appuyer 3 fois sur CTRL+C arrêtera le programme.` ;
<2> Affiche `Nombre d'essais restants: 2` ;
<3> Affiche `Nombre d'essais restants: 1` ;
<4> Affiche `Arrêt du programme…`.

Enfin nous pourrions parler de `process.nextTick()` mais nous développerons davantage cette méthode dans _Comprendre les accès non bloquants_.

Pour en savoir plus sur les méthodes et fonctions disponibles, reportez-vous à la documentation en ligne du module `process` sur [URL]#https://nodejs.org/api/process.html#.

===== module

Les modules CommonJS sont au cœur du fonctionnement de Node.
Ils permettent d'isoler, d'empaqueter et de rendre le code réutilisable.

La magie opère principalement grâce à la fonction `require` et à l'objet `module`.
Ils s'occupent respectivement de _charger_ et de _déclarer_ un module.

Techniquement parlant, un module est un fichier JavaScript dont toutes les variables sont privées et inaccessibles depuis l'extérieur.
Seules les variables exposées par `module.exports` sont publiquement accessibles.

Prenons l'exemple suivant :

[source,javascript]
.currency-format.js
----
include::{sourceDir}/currency-format.js[]
----

Dans le précédent exemple, le module `currency-format.js` est exposé tant que fonction.
Les variables `currencies` et `formatNumber` restent encapsulées dans la portée du module.

Admettons que nous souhaitons utiliser ce module dans un programme, ici `currency-main.js` :

[source,javascript]
.currency-main.js
----
include::{sourceDir}/currency-main.js[]
----

La fonction `require` chargera le fichier `currency-format.js` et assignera le résultat de l'export dans la variable de votre choix, ici, `setupFormatter`.

----
node currency-main.js <1> <2>
----
<1> Affiche `undefined` ;
<2> Puis affiche `'12,00€'`.

Lors de l'exécution du précédent programme, nous avons confirmation que la variable `currencies` contenue dans le module `currency-format.js` n'est pas disponible dans le module `currency-main.js`.

[TIP]
.[RemarquePreTitre]#Remarque# Les modules Node
====
Un module Node est un répertoire contenant un fichier de description `package.json`.
Ce fichier contient notamment une propriété `main` indiquant quel fichier charger par défaut.
Les modules Node sont par convention placés dans un répertoire `node_modules`.

Voici un extrait du fichier `package.json` du module `lodash` :
----
{
  "name": "lodash",
  "version": "2.4.1",
  "main": "dist/lodash.js"
}
----

Ainsi, exécuter `require('lodash');` revient à peu près à faire `require('./node_modules/lodash/dist/lodash.js');`.
====

Pour en savoir plus sur les méthodes et fonctions disponibles, reportez-vous à la documentation en ligne des modules sur [URL]#https://nodejs.org/api/modules.html#.

===== require

Nous avons abordé le mécanisme de chargement de modules dans le point précédent.
Regardons plus en détails le comportement de la fonction `require`.

La fonction `require` permet de charger des fichiers locaux, des modules JavaScript, des modules binaires ou même des fichiers JSON :

[source,javascript]
.require.js
----
include::{sourceDir}/require.js[]
----
<1> Charge le module Node natif `fs` ;
<2> Charge le fichier `currency-format.js` : Node suffixe automatiquement le nom du fichier par `.js` (module JavaScript) ou par `.node` (module binaire) si l'extension manque ;
<3> Charge le fichier `index.js` du répertoire `chapitre-02` car Node détecte que `chapitre-02` est un répertoire ;
<4> Charge le module Node `lodash`, vraisemblablement depuis le répertoire `node_modules/lodash` ;
<5> Charge et parse le fichier `package.json` en tant qu'objet ECMAScript.

`require` est une fonction synchrone _et_ bloquante.
Cela permet de garantir l'ordre de chargement des modules.

[source,javascript]
----
const path = require('path'); <1>
const setupFormatter = require('./currency-format.js'); <2>
----
<1> Node interprète d'abord cette ligne… ;
<2> … puis interprète celle-ci dès que le module `path` est chargé.

Qui dit bloquant dit que si du code exécuté dans le module _avant_ l'export ralentira l'exécution tant que le module n'aura pas été mis en cache. +
L'exemple suivant illustre le phénomène :

[source,javascript]
.blocking-module.js
----
include::{sourceDir}/blocking-module.js[]
----

Dans l'exemple précédent, il faut attendre que la boucle soit complétée avant que la fonction `require` ne rende la main et procède à l'exécution des instructions suivantes :

[source,javascript]
----
require('./blocking-module.js');

console.log('module chargé'); <1>
----
<1> Le message ne sera affiché que tardivement, environ une seconde après le chargement du module `blocking-module.js`.

Il faut s'assurer que le code exécuté pendant le chargement d'un module soit exclusivement non bloquant pour conserver la performance applicative. +
Le concept d'asynchronicité et de non bloquant est explicité plus en détail dans _Comprendre les accès non-bloquants_.

Node optimise le chargement des modules en les mettant en cache.
Autrement dit et de manière générale, *un module est chargé une seule fois*.
L'unicité d'un module est assurée par son emplacement au sein du système de fichiers, en se basant sur la propriété `module.id`.

Prenons le cas de ce module :

[source,javascript]
.increment-module.js
----
include::{sourceDir}/increment-module.js[]
----

Le précédent module affichera son identifiant unique à chaque fois qu'il est _chargé_.
Dès que la méthode `run()` de l'objet exporté sera appelée, elle incrémentera la variable privée `counter` et retournera sa nouvelle valeur.

Le module suivant fait deux fois appel à `increment-module.js` et assigne le résultat dans deux variables différentes.
Ceci dans le but de vérifier le comportement du mécanisme de chargement des modules Node.

[source,javascript]
.increment-main.js
----
include::{sourceDir}/increment-main.js[]
----

Il ne reste plus qu'à l'exécuter pour constater ce qu'il se passe :

----
node increment-main.js <1> <2> <3> <4>
----
<1> Affiche `…/examples/chapitre-02/increment-module.js` ;
<2> Affiche `0` ;
<3> Affiche `1` ;
<4> Affiche `true`.

Le module ayant déjà été chargé une fois, Node n'ira pas charger le fichier une deuxième fois et ne créera pas de nouvelle instance de l'objet `module`.
Il se contente de *retourner la même instance de module*.

Ce comportement peut être exploité	 en tant que _design pattern_ _Singleton_, explicité plus en détail dans ce même chapitre.

Enfin, Node lancera une exception si une erreur se produit lors du chargement (fichier inexistant, erreur de syntaxe dans le fichier à charger).

[source,javascript]
----
try {
  require('./module-inexistant.js');
}
catch (err) {
  console.log('L\'erreur est la suivante : %s', err.message); <1>
}
----
<1> L'exécution de ce module affichera `L'erreur est la suivante : Cannot find module './module-inexistant.js'`.

Pour en savoir plus sur le fonctionnement de la fonction `require`, reportez-vous à la documentation en ligne des modules sur [URL]#https://nodejs.org/api/modules.html#.

===== \__filename et __dirname

`\__filename` et `__dirname` sont des constantes indiquant respectivement le chemin absolu du fichier exécuté et le chemin absolu du répertoire contenant le fichier exécuté.

[source,javascript]
.filename-dirname.js
----
include::{sourceDir}/filename-dirname.js[]
----
<1> Affiche `…/examples/chapitre-02/filename-dirname.js` ;
<2> Affiche `…/examples/chapitre-02` ;
<3> Affiche `true`.

Utiliser `\__filename` et `__dirname` est utile pour travailler avec des chemins absolus, indépendamment du répertoire de travail de Node.

===== setTimeout, setInterval et setImmediate

Pour des raisons de commodité, Node fournit des implémentations de `setTimeout`, de `setInterval` et de `setImmediate`.
Pour rappel, ces fonctions de temps ne font pas partie de JavaScript mais de la spécification _DOM Level 0_.

Ces fonctions exécutent une fonction respectivement une seule fois dans un délai imparti, un nombre de fois indéterminé à un intervalle imparti et une seule fois immédiatement :

[source,javascript]
----
const print = (message) => {
  return print(){
    console.log(message); // <1> <2> <3>
  }
};

const timer = setInterval(print('interval'), 250);
setTimeout(print('timeout'), 200);
setImmediate(print('immediate'));
----
<1> Affichera d'abord `immediate`… ;
<2> … suivi de `timeout` environ 200ms plus tard… ;
<3> … puis `interval` environ 50ms plus tard, et ce, toutes les 250ms tant que le programme ne sera pas arrêté ou que `clearTimeout` n'annule pas l'intervalle.

Pour en savoir plus sur les méthodes et fonctions disponibles, reportez-vous à la documentation en ligne du module `timers` sur [URL]#https://nodejs.org/api/timers.html#.

===== _

La variable globale `_` est un cas spécial.
Elle n'est prédéfinie que dans le terminal interactif (_REPL_).

Cette variable _magique_ contient systématiquement le résultat de la dernière évaluation de code.

----
$ node
> 2 + 2
4
> _ + 2
6
----

=== Invoquer Node.js

C'est bien beau de parler d'histoire, d'architecture et d'interpréteur mais concrètement, comment exécuter du code écrit pour Node ?

La plateforme Node fournit un exécutable système : `node`. C'est lui qui digèrera votre code, préparé à l'avance ou non :

- `node` invoquera le _REPL_, un interpréteur interactif ;
- `node votre-script.js` invoquera le dit script.

==== REPL

Un _REPL_ est un interpréteur interactif exécuté dans votre terminal.
Une fois invoqué, toutes les instructions écrites dans le terminal seront interprétées dès que vous presserez la touche [KEY]#Entrée#.

L'intérêt principal d'utiliser le _REPL_ est de prototyper rapidement du code ; code que l'on pourra éventuellement sauvegarder en tapant `.save` [KEY]#Entrée#.

Autre exemple : vous écrivez un programme qui nécessite que l'utilisateur saisisse lui-même du code à faire interpréter par Node.
On pourrait penser à un programme en ligne de commande éducatif ou encore à une interface web qui commanderait un _REPL_ distant.

image::images/node-repl.png[align="center",scaledwidth="85%"]

Le _REPL_ lui-même est écrit en ECMAScript.
Il est disponible dans le module Node natif `repl` dont la documentation est disponible à l'adresse suivante : [URL]#https://nodejs.org/api/repl.html#.

==== Exécution de script

L'exécution d'un script est très certainement l'invocation la plus classique de Node.

Node tente de charger et d'exécuter le fichier mentionné en argument de l'exécutable `node`.
Le processus Node reste actif tant que l'_Event Loop_ a des instructions à traiter dans le futur.

Un certain nombre d'options sont acceptées par l'exécutable et modifient son comportement en conséquent :

- `node debug votre-script.js` : active le mode débogage ;
- `NODE_ENV=production node votre-script` : transmets une variable d'environnement au processus, et est accessible sous la forme `process.env.NODE_ENV`.

image::images/node-exec.png[align="center",scaledwidth="85%"]

Pour connaître l'ensemble des options disponibles de l'exécutable Node, tapez `node --help` dans votre terminal.

==== Script shell

TBD.

=== Mon premier script Node.js : lire un fichier CSV

Il est temps de passer à la pratique. +
Surtout après autant de théorie et de concepts !

La lecture et l'écriture de fichiers est une activité courante dans le développement d'une application.

Node ne déroge pas à la règle en exposant des méthodes non-bloquantes d'accès au système de fichiers.
Des méthodes bloquantes sont également fournies par praticité mais nous ne nous y intéresserons pas.

==== Intentions et objectifs

Que cherchons-nous à faire au travers de cet exercice ?

Nous voulons un *programme exécutable* capable de lire un *fichier CSV* et d'en *afficher le contenu* de manière intelligible.

Pour ce premier exercice, nous développerons tout par nous-même afin de mieux comprendre en pratiquant les concepts évoqués en amont dans cet ouvrage.

Nous pouvons considérer cet exercice comme une réussite si :

- nous pouvons exécuter le programme avec le fichier d'exemple ;
- nous comprenons l'organisation et l'ordre d'exécution du code ;
- nous comprenons comment Node exprime les erreurs via le mécanisme de _callback_ ;
- nous comprenons quoi modifier pour impacter le comportement du programme.

==== Pré-requis

Nous avons besoin d'utiliser deux modules Node pour accéder au système de fichier :

- `fs` : pour la lecture et l'écriture de données stockées au sein d'un système de fichiers ;
- `path` : pour la construction de chemins d'accès d'une manière compatible avec tous les systèmes d'exploitation.

Le contenu du fichier CSV est le suivant :

[source]
./data/books.csv
----
include::{sourceDir}/../data/books.csv[]
----

L'exécution du script se fait simplement en exécutant la commande suivante :

----
node print-csv.js
----

Le résultat attendu serait le suivant :

----
"CSS maintenables avec Sass et Compass" a été écrit par Kaelig Deloumeau-Prigent
"Intégration Web" a été écrit par Corinne Schillinger
"Projet responsive Web design" a été écrit par Jérémie Patonnier,Rudy Rigot
"Javascript the Definitive Guide" a été écrit par David Flanagan
----

==== Accéder au système de fichier

Itérons une première fois sur l'accès au données.


[source,javascript]
.print-csv.js
----
const fs = require('fs');
const { join } = require('path');

const FILENAME = join(__dirname, 'data', 'books.csv');

fs.readFile(FILENAME, (err, binaryContent) => {
  if (err){
    throw err;
  }

  console.log(String(binaryContent));
});
----

Le premier bloc décrit l'assignation des modules Node `fs` et `path` vers des variables.
Dans un cas on assigne le module entier tandis que dans le second, on n'exporte _que la méthode `join`_.
L'intérêt d'utiliser l'une ou l'autre des méthodes est une *question de lisibilité*.

La construction du chemin vers le fichier `data/books.csv` en utilisant la méthode `join` du module `path` est une bonne habitude à prendre.
Elle garantit la compatibilité avec le séparateur de répertoires du système d'exploitation sur lequel est exécuté le script Node.

La présence de `__dirname` garantit quant à elle une construction du chemin à partir du _fichier exécuté_ et non depuis le répertoire de travail actuel (`process.cwd()`). +
Ce chemin sera construit comme `./data/books.csv` sur les systèmes UNIX tandis qu'il pourra être construit comme `.\data\books.csv` sous Windows ou encore `@.data.books/csv` sous RISC OS. +

L'exécution de `fs.readFile` est asynchrone _et_ non bloquante.
À la manière des requêtes Ajax dans les navigateurs Web, la fonction ne retourne pas de résultat mais elle exécute la fonction de _callback_ dès que la lecture est effectuée avec succès … ou qu'un problème est survenu :

- le premier paramètre du _callback_ sera un objet de type `Error` en cas de problème (fichier inexistant, droit d'accès refusé, secteur disque défectueux etc.) ;
- le second paramètre du _callback_ est un _buffer_ - une chaîne binaire ; à moins de spécifier l'encodage en tant que second argument optionnel de `fs.readFile` :

[source,javascript]
----
const FS_OPTIONS = {
  encoding: 'utf8'
};

fs.readFile(FILENAME, FS_OPTIONS, (err, textContent) => {
  if (err){
    throw err;
  }

  console.log(textContent);
});
----

Enfin, si nous détectons une erreur, nous remontons l'exception au sein du process Node.
Nous lui déléguons ainsi la responsabilité de son usage. +
Cela veut dire que si un mécanisme d'interception est mis en place, il sera prévenu de cette erreur et décidera que faire.
Sinon, Node mettra un terme au processus, tout simplement.

==== Traiter les données

Maintenant que nous avons accédé aux données, le reste du code est de la logique ECMAScript pure, qui ne dépend d'aucune API Node :

[source,javascript]
----
const parseRows = (content) => String(content).split('\n');
const parseRow = (rowContent) => rowContent.split(';');

fs.readFile(FILENAME, (err, binaryContent) => {
  if (err){
    throw err;
  }

  parseRows(binaryContent) // <1>
    .map(parseRow)         //<2>
    .slice(1)              // <3>
    .forEach(row => console.log('"%s" a été écrit par %s', row[0], row[1]));
});

----
<1> transforme le contenu du fichier en tableau de lignes ;
<2> éclate chaque ligne de texte en tableau de cellules ;
<3> supprime la première ligne d'entête.

La syntaxe employée rend explicite l'enchaînement des opérations tout en spécialisant les actions de chaque fonction.
Elles gagnent ainsi en réutilisabilité.

C'est autant de temps de gagné pour un possible _refactoring_ si jamais certaines fonctions devenaient utiles dans d'autres modules de votre application.

==== Pistes d'amélioration

Le code final est relativement élégant et lisible mais souffre de plusieurs inconvénients :

- la lecture CSV n'est ni robuste ni résiliante ni flexible ;
- il n'y a pas de possibilité de configurer le caractère de séparation de cellule ni de configurer de ligne d'entête ;
- la manipulation d'une ligne sous forme d'un tableau peut rapidement devenir illisible en cas de nombreuses colonnes ;
- quid de l'utilisation de ce code dans un autre contexte que celui de la ligne de commande ?

Enfin on notera un autre problème, celui de la performance.
Il ne se révèlera qu'à l'usage, en fonction de la taille du fichier CSV et de sa concurrence d'accès.
En clair, lorsqu'il sera déjà trop tard.

Autrement dit, plus le fichier est gros, plus la phase de lecture sera longue et plus nombreuses seront les chances d'obtenir une erreur.

Autant de problèmes dont nous n'avons pas nécessairement envie de nous soucier mais que l'on aimerait pour autant éviter. +
Et ça tombe bien, d'autres personnes se sont déjà frottés à la lecture de fichiers CSV et ont mis à disposition du code réutilisable donc ne réinventons pas la roue et *utilisons des modules tiers* !

=== Introduction aux modules Node

Nous avons évoqué la notion de _modules_ dans les pages précédentes et il est désormais temps de plonger plus en détails dans le sujet pour mieux comprendre une des pierres angulaires de Node.

Lorsque la fonction globale `require` est invoquée, plusieurs scénarios de chargement peuvent se dérouler, en fonction de la syntaxe employée :

- un fichier local en utilisant un chemin relatif (`require('./mon-fichier.js')`) ;
- un module Node (`require('comma-separated-values')`) ;
- un module Node natif (par exemple, `require('fs')`).

L'objectif de Node est de fournir des modules natifs de bas niveau, stables et robustes.
Le reste est pris en charge par la communauté.
Et c'est de la communauté dont émergent les modules et les _patterns_ utiles et efficaces.

==== npm

Cette communauté a créé, conçu et contribue à alimenter le registre `npm` pour faciliter la distribution, l'installation et la mise à jour des modules.
C'est de loin le mécanisme privilégié pour installer des modules Node de la manière la plus simple qu'il soit.

Si vous avez installé Node depuis les binaires officiels, `npm` est inclus par défaut.
Autrement, il convient de vérifier que le programme `npm` est installé sur votre machine avant de continuer.

----
$ npm --version
4.1.1
----

==== Installer un module

Revenons à notre exemple précédent.
Nous voulons un module Node permettant de parser et d'itérer facilement sur un fichier CSV sans avoir à nous soucier des cas limites.

Après quelques recherches, il se trouve que le module `comma-separated-values` est un bon candidat pour améliorer notre précédent script.
La documentation et les informations relatives à son utilisation sont accessibles sur [URL]#https://npmjs.com/comma-separated-values#.

Après avoir préalablement navigué dans le répertoire `examples/chapitre-02/`, l'installation du module se déroule en invoquant la commande `npm install` de la manière suivante :

----
npm install comma-separated-values
----

Le module est désormais installé dans le répertoire `examples/chapitre-02/node_modules/comma-separated-values` et est disponible pour tout script invoqué dans le répertoire `examples/chapitre-02/`.

Lire un fichier CSV et en afficher son contenu deviendrait aussi simple que le script suivant :

[code,javascript]
----
const fs = require('fs');
const csv = require('comma-separated-values'); // <1>

fs.readFile('./data/books.csv', (err, binaryContent) => {
  const csvFile = new csv(String(binaryContent), { header: true, delimiter: ';' }); // <2>

  console.log(csvFile.parse()); // <3>
});
----
<1> importe le module `comma-separated-values` dans la variable `csv` ;
<2> configure un nouvel objet _CSV_ ;
<3> décode le contenu initial et affiche la structure JavaScript appropriée.

Nous verrons dans le chapitre suivant comment utiliser efficacement le programme `npm` pour initialiser et gérer un projet de bout en bout.

=== Mon premier script Node.js : lire un fichier CSV (bis)

Reprenons désormais notre premier module Node.
Les intentions et objectifs demeurent identiques mais nous allons appliquer nos nouvelles connaissances quant aux modules Node.

.Résultat final
image::images/print-csv-cli.png[align="center",scaledwidth="85%"]

==== Invocation de la ligne de commande

Nous allons créer un module Node explicitement pour l'invocation dans un terminal.
Ce module sera responsable de l'_affichage des données_ :

- il sélectionne la source de données ;
- il choisit le formatage de l'affichage des données ;
- il embellit l'affichage en utilisant des couleurs.

[code,javascript]
.print-csv-cli.js
----
include::{sourceDir}/print-csv-cli.js[]
----

Le code est drastiquement simplifié par rapport à la version finale contenue dans `print-csv.js`.

Et la lecture du fichier CSV a été rendue modulaire et déléguée au module `print-csv-module.js`.

==== Le module de lecture de fichier CSV

Les responsabilités du module `print-csv-module.js` sont les suivantes :

- exposer et _exporter_ une fonction unique et configurable ;
- lire et appliquer une fonction pour chaque ligne du fichier CSV.

De ce fait, nous avons rendu le code générique et réutilisable dans tout contexte, que ce soit en ligne de commande ou dans un autre module Node.

[code,javascript]
.print-csv-module.js
----
include::{sourceDir}/print-csv-module.js[]
----

=== Conclusion

TBD.
